<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2.dev0+g1b644f6.d20200630" />
<title>mici.stagers API documentation</title>
<meta name="description" content="Classes for controlling sampling of Markov chains split into stages." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding-top:5px;padding-bottom:5px;padding-right:10px;padding-left:35px;text-indent:-25px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:1000px){#sidebar{width:540px;position:fixed;z-index:1;top:0;bottom:0;overflow-x:hidden;overflow-y:auto}#content{margin-left:540px;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}#footer{margin-left:540px}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<code><a title="mici.stagers.ChainStage" href="#mici.stagers.ChainStage">ChainStage</a></code>
<ul class="">
<li><code><a title="mici.stagers.ChainStage.n_iter" href="#mici.stagers.ChainStage.n_iter">n_iter</a></code></li>
<li><code><a title="mici.stagers.ChainStage.adapters" href="#mici.stagers.ChainStage.adapters">adapters</a></code></li>
<li><code><a title="mici.stagers.ChainStage.trace_funcs" href="#mici.stagers.ChainStage.trace_funcs">trace_funcs</a></code></li>
</ul>
</li>
<li>
<code><a title="mici.stagers.Stager" href="#mici.stagers.Stager">Stager</a></code>
<ul class="">
<li><code><a title="mici.stagers.Stager.stages" href="#mici.stagers.Stager.stages">stages</a></code></li>
</ul>
</li>
<li>
<code><a title="mici.stagers.WarmUpStager" href="#mici.stagers.WarmUpStager">WarmUpStager</a></code>
<ul class="">
<li><code><a title="mici.stagers.WarmUpStager.stages" href="#mici.stagers.WarmUpStager.stages">stages</a></code></li>
</ul>
</li>
<li>
<code><a title="mici.stagers.WindowedWarmUpStager" href="#mici.stagers.WindowedWarmUpStager">WindowedWarmUpStager</a></code>
<ul class="">
<li><code><a title="mici.stagers.WindowedWarmUpStager.stages" href="#mici.stagers.WindowedWarmUpStager.stages">stages</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Module <code>mici.stagers</code></h1>
</header>
<section id="section-intro">
<p>Classes for controlling sampling of Markov chains split into stages.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/6015d755bbaec077b30609ff8d84b3126e7fcc7a/mici/stagers.py#L0-L213" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Classes for controlling sampling of Markov chains split into stages.&#34;&#34;&#34;

import abc
from collections import OrderedDict, namedtuple


ChainStage = namedtuple(&#34;ChainStage&#34;, [&#34;n_iter&#34;, &#34;adapters&#34;, &#34;trace_funcs&#34;])


class Stager(abc.ABC):
    &#34;&#34;&#34;Abstract chain iteration stager.&#34;&#34;&#34;

    @abc.abstractmethod
    def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
        &#34;&#34;&#34;Create dictionary specifying labels and parameters of sampling stages.

        Constructs an ordered dictionary with entries corresponding to the
        sequence of sampling stages when running chains with one or more initial
        adaptation stages. The keys of each entry are string labels for the
        sampling stage and the values a 3-tuple `(n_iter, adapters,
        trace_funcs)` with `n_iter` the number of chain iterations in the stage,
        `adapters` a dictionary of transition adapters to pass to the
        `_sample_chain` call (or `None` if no adaptation to be used) and
        `trace_func` a list of trace functions to pass to the `_sample_chain`
        call (list may be empty if no values to be traced).

        Args:
            n_warm_up_iter (int): Number of adaptive warm up iterations per
                chain. Depending on the adapters specified by the `adapters`
                argument the warm up iterations may be split between one or more
                adaptive stages.
            n_main_iter (int): Number of iterations (samples to draw) per chain
                during main (non-adaptive) sampling stage.
            trace_funcs (Iterable[Callable[[ChainState], Dict[str, array]]]):
                List of functions which compute the variables to be recorded at
                each chain iteration during the final (non-adaptive) sampling
                stage, with each trace function being passed the current state
                and returning a dictionary of scalar or array values
                corresponding to the variable(s) to be stored. The keys in the
                returned dictionaries are used to index the trace arrays in the
                returned traces dictionary. If a key appears in multiple
                dictionaries only the the value corresponding to the last trace
                function to return that key will be stored.
            adapters (Dict[str, Iterable[Adapter]): Dictionary of iterables
                of `mici.adapters.Adapter` instances keyed by strings
                corresponding to the key of the transition in the `transitions`
                dictionary to apply the adapters to, to use to adaptatively set
                parameters of the transitions during the adaptive stages of the
                chains. Note that the adapter updates are applied in the order
                the adapters appear in the iterables and so if multiple adapters
                change the same parameter(s) the order will matter.

        Returns:
            OrderedDict[str, ChainStage]: Ordered dictionary specifying sampling
                stage parameters.
        &#34;&#34;&#34;


class WarmUpStager(Stager):
    &#34;&#34;&#34;Chain iteration stager with a single adaptive warm up stage.

    Sampling is split in to two stages:

      1. An adaptive warm up stage will all adapters active.
      2. A main sampling stage with no adapters active.

    Only in the main sampling stage are traces of the chain state recorded by
    storing the outputs of functions of the sampled chain state after each
    iteration.
    &#34;&#34;&#34;

    def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
        # adaptive warm up stage
        sampling_stages = OrderedDict(
            {&#34;Adaptive warm up&#34;: ChainStage(n_warm_up_iter, adapters, [])}
        )
        # main non-adaptive stage
        sampling_stages[&#34;Main non-adaptive&#34;] = ChainStage(
            n_main_iter, None, trace_funcs
        )
        return sampling_stages


class WindowedWarmUpStager(Stager):
    &#34;&#34;&#34;Chain iteration stager with a hierarchy of adaptive warm up stages.

    Following the approach of [Stan](https://mc-stan.org) the adaptive
    stages are split in to two types - &#39;fast&#39; adaptation stages which adjust
    only transition parameters which can be adapted quickly using local
    information and &#39;slow&#39; adaptation stages which *addtionally* adjust
    transition parameters which require more global information. The
    adapters to be used in both the fast and slow adaptation stages will be
    referred to as the *fast adapters* and the adapters to use in only the
    slow adaptation stages the *slow adapters*. Each adapter self identifies
    if it is a fast adapter by whether the `is_fast` attribute is set to `True`.

    The adaptive warm up iterations are split into three stages:

      1. An initial fast adaptive stage with only fast adapters active.
      2. A slow adaptive stage with both slow and fast adapters active.
      3. A final adaptive stage with only fast adapters active.

    The slow sampling stage (2) is further split in to a sequence of
    growing, memoryless windows with the adapter stages reset at the
    beginning of each window, and the number of iterations in each window
    increasing (by default doubling). The split of the iterations in each of
    these stages can be controlled using the keyword arguments
    `n_init_fast_stage_iter`, `n_init_slow_window_iter`,
    `n_final_fast_stage_iter` and `slow_window_multiplier` (see descriptions
    below).

    After the initial adaptive warm up stages a subsequent main sampling stage
    with no further adaptation is performed. Only in this main sampling stage
    are traces of the chain state recorded by storing the outputs of functions
    of the sampled chain state after each iteration.
    &#34;&#34;&#34;

    def __init__(
        self,
        n_init_slow_window_iter=25,
        n_init_fast_stage_iter=75,
        n_final_fast_stage_iter=50,
        slow_window_multiplier=2,
    ):
        &#34;&#34;&#34;
        Args:
            n_init_slow_window_iter (int): Number of iterations in the initial
                (smallest) window in the slow adaptation stage. Defaults to 25.
                If the sum of `n_init_slow_window_iter`,
                `n_init_fast_stage_iter` and `n_final_fast_stage_iter` is more
                than `n_warm_up_iter` then `n_init_slow_window_iter` is set to
                approximately 75% of `n_warm_up_iter` (with a single window
                being used in the slow adaptation stage in this case).
            n_init_fast_stage_iter (int): Number of iterations in the initial
                fast adaptation stage. Defaults to 75. If the sum of
                `n_init_slow_window_iter`, n_init_fast_stage_iter` and
                `n_final_fast_stage_iter` is more than `n_warm_up_iter` then
                `n_init_fast_stage_iter` is set to approximately 15% of
                `n_warm_up_iter`.
            n_final_fast_stage_iter (int): Number of iterations in the final
                fast adaptation stage. Defaults to 50. If the sum of
                `n_init_slow_window_iter`, `n_init_fast_stage_iter` and
                `n_final_fast_stage_iter` is more than `n_warm_up_iter` then
                `n_init_fast_stage_iter` is set to approximately 10% of
                `n_warm_up_iter`.
            slow_window_multiplier (float): Multiplier by which to increase the
                number of iterations of each subsequent slow adaptation window
                by. Defaults to 2 such that each window doubles in size.
        &#34;&#34;&#34;
        self.n_init_slow_window_iter = n_init_slow_window_iter
        self.n_init_fast_stage_iter = n_init_fast_stage_iter
        self.n_final_fast_stage_iter = n_final_fast_stage_iter
        self.slow_window_multiplier = slow_window_multiplier

    def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
        fast_adapters = {
            trans_key: [adapter for adapter in adapter_list if adapter.is_fast]
            for trans_key, adapter_list in adapters.items()
        }
        if (
            self.n_init_fast_stage_iter
            + self.n_init_slow_window_iter
            + self.n_final_fast_stage_iter
        ) &gt; n_warm_up_iter:
            n_init_fast_stage_iter = int(0.15 * n_warm_up_iter)
            n_final_fast_stage_iter = int(0.1 * n_warm_up_iter)
            n_init_slow_window_iter = (
                n_warm_up_iter - n_init_fast_stage_iter - n_final_fast_stage_iter
            )
        else:
            n_init_slow_window_iter = self.n_init_slow_window_iter
            n_init_fast_stage_iter = self.n_init_fast_stage_iter
            n_final_fast_stage_iter = self.n_final_fast_stage_iter
        # initial fast adaptation stage
        sampling_stages = OrderedDict(
            {
                &#34;Initial fast adaptive&#34;: ChainStage(
                    n_init_fast_stage_iter, fast_adapters, []
                )
            }
        )
        # growing size slow adaptation windows
        n_window_iter = n_init_slow_window_iter
        slow_windows = []
        counter = 0
        n_slow_stage_iter = (
            n_warm_up_iter - n_init_fast_stage_iter - n_final_fast_stage_iter
        )
        while counter &lt; n_slow_stage_iter:
            # check if iteration counter at end of next loop iteration will be
            # greater than total number of warm up iterations and if so set
            # number of iterations in current window to be equal to all
            # remaining warm up iterations
            counter_next = counter + int(
                (1 + self.slow_window_multiplier) * n_window_iter
            )
            if counter_next &gt; n_slow_stage_iter:
                n_window_iter = n_slow_stage_iter - counter
            slow_windows.append(n_window_iter)
            counter += n_window_iter
            n_window_iter = int(self.slow_window_multiplier * n_window_iter)
        for i, n_iter in enumerate(slow_windows):
            sampling_stages[
                f&#34;Slow adaptive ({i + 1}/{len(slow_windows)})&#34;
            ] = ChainStage(n_iter, adapters, [])
        # final fast adaptation stage
        sampling_stages[&#34;Final fast adaptive&#34;] = ChainStage(
            n_final_fast_stage_iter, fast_adapters, []
        )
        # main non-adaptive stage
        sampling_stages[&#34;Main non-adaptive&#34;] = ChainStage(
            n_main_iter, None, trace_funcs
        )
        return sampling_stages</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.stagers.ChainStage"><code class="flex name class">
<span>class <span class="ident">ChainStage</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>ChainStage(n_iter, adapters, trace_funcs)</p></section>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.stagers.ChainStage.n_iter"><code class="name">var <span class="ident">n_iter</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="mici.stagers.ChainStage.adapters"><code class="name">var <span class="ident">adapters</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="mici.stagers.ChainStage.trace_funcs"><code class="name">var <span class="ident">trace_funcs</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
</dl>
</dd>
<dt id="mici.stagers.Stager"><code class="flex name class">
<span>class <span class="ident">Stager</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Abstract chain iteration stager.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/6015d755bbaec077b30609ff8d84b3126e7fcc7a/mici/stagers.py#L10-L56" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Stager(abc.ABC):
    &#34;&#34;&#34;Abstract chain iteration stager.&#34;&#34;&#34;

    @abc.abstractmethod
    def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
        &#34;&#34;&#34;Create dictionary specifying labels and parameters of sampling stages.

        Constructs an ordered dictionary with entries corresponding to the
        sequence of sampling stages when running chains with one or more initial
        adaptation stages. The keys of each entry are string labels for the
        sampling stage and the values a 3-tuple `(n_iter, adapters,
        trace_funcs)` with `n_iter` the number of chain iterations in the stage,
        `adapters` a dictionary of transition adapters to pass to the
        `_sample_chain` call (or `None` if no adaptation to be used) and
        `trace_func` a list of trace functions to pass to the `_sample_chain`
        call (list may be empty if no values to be traced).

        Args:
            n_warm_up_iter (int): Number of adaptive warm up iterations per
                chain. Depending on the adapters specified by the `adapters`
                argument the warm up iterations may be split between one or more
                adaptive stages.
            n_main_iter (int): Number of iterations (samples to draw) per chain
                during main (non-adaptive) sampling stage.
            trace_funcs (Iterable[Callable[[ChainState], Dict[str, array]]]):
                List of functions which compute the variables to be recorded at
                each chain iteration during the final (non-adaptive) sampling
                stage, with each trace function being passed the current state
                and returning a dictionary of scalar or array values
                corresponding to the variable(s) to be stored. The keys in the
                returned dictionaries are used to index the trace arrays in the
                returned traces dictionary. If a key appears in multiple
                dictionaries only the the value corresponding to the last trace
                function to return that key will be stored.
            adapters (Dict[str, Iterable[Adapter]): Dictionary of iterables
                of `mici.adapters.Adapter` instances keyed by strings
                corresponding to the key of the transition in the `transitions`
                dictionary to apply the adapters to, to use to adaptatively set
                parameters of the transitions during the adaptive stages of the
                chains. Note that the adapter updates are applied in the order
                the adapters appear in the iterables and so if multiple adapters
                change the same parameter(s) the order will matter.

        Returns:
            OrderedDict[str, ChainStage]: Ordered dictionary specifying sampling
                stage parameters.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.stagers.WarmUpStager" href="#mici.stagers.WarmUpStager">WarmUpStager</a></li>
<li><a title="mici.stagers.WindowedWarmUpStager" href="#mici.stagers.WindowedWarmUpStager">WindowedWarmUpStager</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.stagers.Stager.stages"><code class="name flex">
<span>def <span class="ident">stages</span></span>(<span>self, n_warm_up_iter, n_main_iter, adapters, trace_funcs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create dictionary specifying labels and parameters of sampling stages.</p>
<p>Constructs an ordered dictionary with entries corresponding to the
sequence of sampling stages when running chains with one or more initial
adaptation stages. The keys of each entry are string labels for the
sampling stage and the values a 3-tuple <code>(n_iter, adapters,
trace_funcs)</code> with <code>n_iter</code> the number of chain iterations in the stage,
<code>adapters</code> a dictionary of transition adapters to pass to the
<code>_sample_chain</code> call (or <code>None</code> if no adaptation to be used) and
<code>trace_func</code> a list of trace functions to pass to the <code>_sample_chain</code>
call (list may be empty if no values to be traced).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_warm_up_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of adaptive warm up iterations per
chain. Depending on the adapters specified by the <code>adapters</code>
argument the warm up iterations may be split between one or more
adaptive stages.</dd>
<dt><strong><code>n_main_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations (samples to draw) per chain
during main (non-adaptive) sampling stage.</dd>
<dt><strong><code>trace_funcs</code></strong> :&ensp;<code>Iterable</code>[<code>Callable</code>[[<code>ChainState</code>], <code>Dict</code>[<code>str</code>, <code>array</code>]]]</dt>
<dd>
<p>List of functions which compute the variables to be recorded at
each chain iteration during the final (non-adaptive) sampling
stage, with each trace function being passed the current state
and returning a dictionary of scalar or array values
corresponding to the variable(s) to be stored. The keys in the
returned dictionaries are used to index the trace arrays in the
returned traces dictionary. If a key appears in multiple
dictionaries only the the value corresponding to the last trace
function to return that key will be stored.</p>
</dd>
<dt><strong><code>adapters</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>Iterable</code>[<code>Adapter</code>]</dt>
<dd>Dictionary of iterables
of <a title="mici.adapters.Adapter" href="adapters.html#mici.adapters.Adapter"><code>Adapter</code></a> instances keyed by strings
corresponding to the key of the transition in the <code>transitions</code>
dictionary to apply the adapters to, to use to adaptatively set
parameters of the transitions during the adaptive stages of the
chains. Note that the adapter updates are applied in the order
the adapters appear in the iterables and so if multiple adapters
change the same parameter(s) the order will matter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>OrderedDict</code>[<code>str</code>, <code>ChainStage</code>]: <code>Ordered</code> <code>dictionary</code> <code>specifying</code> <code>sampling</code></dt>
<dd>stage parameters.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/6015d755bbaec077b30609ff8d84b3126e7fcc7a/mici/stagers.py#L13-L56" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
    &#34;&#34;&#34;Create dictionary specifying labels and parameters of sampling stages.

    Constructs an ordered dictionary with entries corresponding to the
    sequence of sampling stages when running chains with one or more initial
    adaptation stages. The keys of each entry are string labels for the
    sampling stage and the values a 3-tuple `(n_iter, adapters,
    trace_funcs)` with `n_iter` the number of chain iterations in the stage,
    `adapters` a dictionary of transition adapters to pass to the
    `_sample_chain` call (or `None` if no adaptation to be used) and
    `trace_func` a list of trace functions to pass to the `_sample_chain`
    call (list may be empty if no values to be traced).

    Args:
        n_warm_up_iter (int): Number of adaptive warm up iterations per
            chain. Depending on the adapters specified by the `adapters`
            argument the warm up iterations may be split between one or more
            adaptive stages.
        n_main_iter (int): Number of iterations (samples to draw) per chain
            during main (non-adaptive) sampling stage.
        trace_funcs (Iterable[Callable[[ChainState], Dict[str, array]]]):
            List of functions which compute the variables to be recorded at
            each chain iteration during the final (non-adaptive) sampling
            stage, with each trace function being passed the current state
            and returning a dictionary of scalar or array values
            corresponding to the variable(s) to be stored. The keys in the
            returned dictionaries are used to index the trace arrays in the
            returned traces dictionary. If a key appears in multiple
            dictionaries only the the value corresponding to the last trace
            function to return that key will be stored.
        adapters (Dict[str, Iterable[Adapter]): Dictionary of iterables
            of `mici.adapters.Adapter` instances keyed by strings
            corresponding to the key of the transition in the `transitions`
            dictionary to apply the adapters to, to use to adaptatively set
            parameters of the transitions during the adaptive stages of the
            chains. Note that the adapter updates are applied in the order
            the adapters appear in the iterables and so if multiple adapters
            change the same parameter(s) the order will matter.

    Returns:
        OrderedDict[str, ChainStage]: Ordered dictionary specifying sampling
            stage parameters.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.stagers.WarmUpStager"><code class="flex name class">
<span>class <span class="ident">WarmUpStager</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Chain iteration stager with a single adaptive warm up stage.</p>
<p>Sampling is split in to two stages:</p>
<ol>
<li>An adaptive warm up stage will all adapters active.</li>
<li>A main sampling stage with no adapters active.</li>
</ol>
<p>Only in the main sampling stage are traces of the chain state recorded by
storing the outputs of functions of the sampled chain state after each
iteration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/6015d755bbaec077b30609ff8d84b3126e7fcc7a/mici/stagers.py#L59-L81" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WarmUpStager(Stager):
    &#34;&#34;&#34;Chain iteration stager with a single adaptive warm up stage.

    Sampling is split in to two stages:

      1. An adaptive warm up stage will all adapters active.
      2. A main sampling stage with no adapters active.

    Only in the main sampling stage are traces of the chain state recorded by
    storing the outputs of functions of the sampled chain state after each
    iteration.
    &#34;&#34;&#34;

    def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
        # adaptive warm up stage
        sampling_stages = OrderedDict(
            {&#34;Adaptive warm up&#34;: ChainStage(n_warm_up_iter, adapters, [])}
        )
        # main non-adaptive stage
        sampling_stages[&#34;Main non-adaptive&#34;] = ChainStage(
            n_main_iter, None, trace_funcs
        )
        return sampling_stages</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.stagers.Stager" href="#mici.stagers.Stager">Stager</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.stagers.WarmUpStager.stages"><code class="name flex">
<span>def <span class="ident">stages</span></span>(<span>self, n_warm_up_iter, n_main_iter, adapters, trace_funcs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create dictionary specifying labels and parameters of sampling stages.</p>
<p>Constructs an ordered dictionary with entries corresponding to the
sequence of sampling stages when running chains with one or more initial
adaptation stages. The keys of each entry are string labels for the
sampling stage and the values a 3-tuple <code>(n_iter, adapters,
trace_funcs)</code> with <code>n_iter</code> the number of chain iterations in the stage,
<code>adapters</code> a dictionary of transition adapters to pass to the
<code>_sample_chain</code> call (or <code>None</code> if no adaptation to be used) and
<code>trace_func</code> a list of trace functions to pass to the <code>_sample_chain</code>
call (list may be empty if no values to be traced).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_warm_up_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of adaptive warm up iterations per
chain. Depending on the adapters specified by the <code>adapters</code>
argument the warm up iterations may be split between one or more
adaptive stages.</dd>
<dt><strong><code>n_main_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations (samples to draw) per chain
during main (non-adaptive) sampling stage.</dd>
<dt><strong><code>trace_funcs</code></strong> :&ensp;<code>Iterable</code>[<code>Callable</code>[[<code>ChainState</code>], <code>Dict</code>[<code>str</code>, <code>array</code>]]]</dt>
<dd>
<p>List of functions which compute the variables to be recorded at
each chain iteration during the final (non-adaptive) sampling
stage, with each trace function being passed the current state
and returning a dictionary of scalar or array values
corresponding to the variable(s) to be stored. The keys in the
returned dictionaries are used to index the trace arrays in the
returned traces dictionary. If a key appears in multiple
dictionaries only the the value corresponding to the last trace
function to return that key will be stored.</p>
</dd>
<dt><strong><code>adapters</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>Iterable</code>[<code>Adapter</code>]</dt>
<dd>Dictionary of iterables
of <a title="mici.adapters.Adapter" href="adapters.html#mici.adapters.Adapter"><code>Adapter</code></a> instances keyed by strings
corresponding to the key of the transition in the <code>transitions</code>
dictionary to apply the adapters to, to use to adaptatively set
parameters of the transitions during the adaptive stages of the
chains. Note that the adapter updates are applied in the order
the adapters appear in the iterables and so if multiple adapters
change the same parameter(s) the order will matter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>OrderedDict</code>[<code>str</code>, <code>ChainStage</code>]: <code>Ordered</code> <code>dictionary</code> <code>specifying</code> <code>sampling</code></dt>
<dd>stage parameters.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/6015d755bbaec077b30609ff8d84b3126e7fcc7a/mici/stagers.py#L72-L81" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
    # adaptive warm up stage
    sampling_stages = OrderedDict(
        {&#34;Adaptive warm up&#34;: ChainStage(n_warm_up_iter, adapters, [])}
    )
    # main non-adaptive stage
    sampling_stages[&#34;Main non-adaptive&#34;] = ChainStage(
        n_main_iter, None, trace_funcs
    )
    return sampling_stages</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.stagers.WindowedWarmUpStager"><code class="flex name class">
<span>class <span class="ident">WindowedWarmUpStager</span></span>
<span>(</span><span>n_init_slow_window_iter=25, n_init_fast_stage_iter=75, n_final_fast_stage_iter=50, slow_window_multiplier=2)</span>
</code></dt>
<dd>
<section class="desc"><p>Chain iteration stager with a hierarchy of adaptive warm up stages.</p>
<p>Following the approach of <a href="https://mc-stan.org">Stan</a> the adaptive
stages are split in to two types - 'fast' adaptation stages which adjust
only transition parameters which can be adapted quickly using local
information and 'slow' adaptation stages which <em>addtionally</em> adjust
transition parameters which require more global information. The
adapters to be used in both the fast and slow adaptation stages will be
referred to as the <em>fast adapters</em> and the adapters to use in only the
slow adaptation stages the <em>slow adapters</em>. Each adapter self identifies
if it is a fast adapter by whether the <code>is_fast</code> attribute is set to <code>True</code>.</p>
<p>The adaptive warm up iterations are split into three stages:</p>
<ol>
<li>An initial fast adaptive stage with only fast adapters active.</li>
<li>A slow adaptive stage with both slow and fast adapters active.</li>
<li>A final adaptive stage with only fast adapters active.</li>
</ol>
<p>The slow sampling stage (2) is further split in to a sequence of
growing, memoryless windows with the adapter stages reset at the
beginning of each window, and the number of iterations in each window
increasing (by default doubling). The split of the iterations in each of
these stages can be controlled using the keyword arguments
<code>n_init_fast_stage_iter</code>, <code>n_init_slow_window_iter</code>,
<code>n_final_fast_stage_iter</code> and <code>slow_window_multiplier</code> (see descriptions
below).</p>
<p>After the initial adaptive warm up stages a subsequent main sampling stage
with no further adaptation is performed. Only in this main sampling stage
are traces of the chain state recorded by storing the outputs of functions
of the sampled chain state after each iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_init_slow_window_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations in the initial
(smallest) window in the slow adaptation stage. Defaults to 25.
If the sum of <code>n_init_slow_window_iter</code>,
<code>n_init_fast_stage_iter</code> and <code>n_final_fast_stage_iter</code> is more
than <code>n_warm_up_iter</code> then <code>n_init_slow_window_iter</code> is set to
approximately 75% of <code>n_warm_up_iter</code> (with a single window
being used in the slow adaptation stage in this case).</dd>
<dt><strong><code>n_init_fast_stage_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations in the initial
fast adaptation stage. Defaults to 75. If the sum of
<code>n_init_slow_window_iter</code>, n_init_fast_stage_iter<code>and</code>n_final_fast_stage_iter<code>is more than</code>n_warm_up_iter<code>then</code>n_init_fast_stage_iter<code>is set to approximately 15% of</code>n_warm_up_iter`.</dd>
<dt><strong><code>n_final_fast_stage_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations in the final
fast adaptation stage. Defaults to 50. If the sum of
<code>n_init_slow_window_iter</code>, <code>n_init_fast_stage_iter</code> and
<code>n_final_fast_stage_iter</code> is more than <code>n_warm_up_iter</code> then
<code>n_init_fast_stage_iter</code> is set to approximately 10% of
<code>n_warm_up_iter</code>.</dd>
<dt><strong><code>slow_window_multiplier</code></strong> :&ensp;<code>float</code></dt>
<dd>Multiplier by which to increase the
number of iterations of each subsequent slow adaptation window
by. Defaults to 2 such that each window doubles in size.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/6015d755bbaec077b30609ff8d84b3126e7fcc7a/mici/stagers.py#L84-L214" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WindowedWarmUpStager(Stager):
    &#34;&#34;&#34;Chain iteration stager with a hierarchy of adaptive warm up stages.

    Following the approach of [Stan](https://mc-stan.org) the adaptive
    stages are split in to two types - &#39;fast&#39; adaptation stages which adjust
    only transition parameters which can be adapted quickly using local
    information and &#39;slow&#39; adaptation stages which *addtionally* adjust
    transition parameters which require more global information. The
    adapters to be used in both the fast and slow adaptation stages will be
    referred to as the *fast adapters* and the adapters to use in only the
    slow adaptation stages the *slow adapters*. Each adapter self identifies
    if it is a fast adapter by whether the `is_fast` attribute is set to `True`.

    The adaptive warm up iterations are split into three stages:

      1. An initial fast adaptive stage with only fast adapters active.
      2. A slow adaptive stage with both slow and fast adapters active.
      3. A final adaptive stage with only fast adapters active.

    The slow sampling stage (2) is further split in to a sequence of
    growing, memoryless windows with the adapter stages reset at the
    beginning of each window, and the number of iterations in each window
    increasing (by default doubling). The split of the iterations in each of
    these stages can be controlled using the keyword arguments
    `n_init_fast_stage_iter`, `n_init_slow_window_iter`,
    `n_final_fast_stage_iter` and `slow_window_multiplier` (see descriptions
    below).

    After the initial adaptive warm up stages a subsequent main sampling stage
    with no further adaptation is performed. Only in this main sampling stage
    are traces of the chain state recorded by storing the outputs of functions
    of the sampled chain state after each iteration.
    &#34;&#34;&#34;

    def __init__(
        self,
        n_init_slow_window_iter=25,
        n_init_fast_stage_iter=75,
        n_final_fast_stage_iter=50,
        slow_window_multiplier=2,
    ):
        &#34;&#34;&#34;
        Args:
            n_init_slow_window_iter (int): Number of iterations in the initial
                (smallest) window in the slow adaptation stage. Defaults to 25.
                If the sum of `n_init_slow_window_iter`,
                `n_init_fast_stage_iter` and `n_final_fast_stage_iter` is more
                than `n_warm_up_iter` then `n_init_slow_window_iter` is set to
                approximately 75% of `n_warm_up_iter` (with a single window
                being used in the slow adaptation stage in this case).
            n_init_fast_stage_iter (int): Number of iterations in the initial
                fast adaptation stage. Defaults to 75. If the sum of
                `n_init_slow_window_iter`, n_init_fast_stage_iter` and
                `n_final_fast_stage_iter` is more than `n_warm_up_iter` then
                `n_init_fast_stage_iter` is set to approximately 15% of
                `n_warm_up_iter`.
            n_final_fast_stage_iter (int): Number of iterations in the final
                fast adaptation stage. Defaults to 50. If the sum of
                `n_init_slow_window_iter`, `n_init_fast_stage_iter` and
                `n_final_fast_stage_iter` is more than `n_warm_up_iter` then
                `n_init_fast_stage_iter` is set to approximately 10% of
                `n_warm_up_iter`.
            slow_window_multiplier (float): Multiplier by which to increase the
                number of iterations of each subsequent slow adaptation window
                by. Defaults to 2 such that each window doubles in size.
        &#34;&#34;&#34;
        self.n_init_slow_window_iter = n_init_slow_window_iter
        self.n_init_fast_stage_iter = n_init_fast_stage_iter
        self.n_final_fast_stage_iter = n_final_fast_stage_iter
        self.slow_window_multiplier = slow_window_multiplier

    def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
        fast_adapters = {
            trans_key: [adapter for adapter in adapter_list if adapter.is_fast]
            for trans_key, adapter_list in adapters.items()
        }
        if (
            self.n_init_fast_stage_iter
            + self.n_init_slow_window_iter
            + self.n_final_fast_stage_iter
        ) &gt; n_warm_up_iter:
            n_init_fast_stage_iter = int(0.15 * n_warm_up_iter)
            n_final_fast_stage_iter = int(0.1 * n_warm_up_iter)
            n_init_slow_window_iter = (
                n_warm_up_iter - n_init_fast_stage_iter - n_final_fast_stage_iter
            )
        else:
            n_init_slow_window_iter = self.n_init_slow_window_iter
            n_init_fast_stage_iter = self.n_init_fast_stage_iter
            n_final_fast_stage_iter = self.n_final_fast_stage_iter
        # initial fast adaptation stage
        sampling_stages = OrderedDict(
            {
                &#34;Initial fast adaptive&#34;: ChainStage(
                    n_init_fast_stage_iter, fast_adapters, []
                )
            }
        )
        # growing size slow adaptation windows
        n_window_iter = n_init_slow_window_iter
        slow_windows = []
        counter = 0
        n_slow_stage_iter = (
            n_warm_up_iter - n_init_fast_stage_iter - n_final_fast_stage_iter
        )
        while counter &lt; n_slow_stage_iter:
            # check if iteration counter at end of next loop iteration will be
            # greater than total number of warm up iterations and if so set
            # number of iterations in current window to be equal to all
            # remaining warm up iterations
            counter_next = counter + int(
                (1 + self.slow_window_multiplier) * n_window_iter
            )
            if counter_next &gt; n_slow_stage_iter:
                n_window_iter = n_slow_stage_iter - counter
            slow_windows.append(n_window_iter)
            counter += n_window_iter
            n_window_iter = int(self.slow_window_multiplier * n_window_iter)
        for i, n_iter in enumerate(slow_windows):
            sampling_stages[
                f&#34;Slow adaptive ({i + 1}/{len(slow_windows)})&#34;
            ] = ChainStage(n_iter, adapters, [])
        # final fast adaptation stage
        sampling_stages[&#34;Final fast adaptive&#34;] = ChainStage(
            n_final_fast_stage_iter, fast_adapters, []
        )
        # main non-adaptive stage
        sampling_stages[&#34;Main non-adaptive&#34;] = ChainStage(
            n_main_iter, None, trace_funcs
        )
        return sampling_stages</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.stagers.Stager" href="#mici.stagers.Stager">Stager</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.stagers.WindowedWarmUpStager.stages"><code class="name flex">
<span>def <span class="ident">stages</span></span>(<span>self, n_warm_up_iter, n_main_iter, adapters, trace_funcs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create dictionary specifying labels and parameters of sampling stages.</p>
<p>Constructs an ordered dictionary with entries corresponding to the
sequence of sampling stages when running chains with one or more initial
adaptation stages. The keys of each entry are string labels for the
sampling stage and the values a 3-tuple <code>(n_iter, adapters,
trace_funcs)</code> with <code>n_iter</code> the number of chain iterations in the stage,
<code>adapters</code> a dictionary of transition adapters to pass to the
<code>_sample_chain</code> call (or <code>None</code> if no adaptation to be used) and
<code>trace_func</code> a list of trace functions to pass to the <code>_sample_chain</code>
call (list may be empty if no values to be traced).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_warm_up_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of adaptive warm up iterations per
chain. Depending on the adapters specified by the <code>adapters</code>
argument the warm up iterations may be split between one or more
adaptive stages.</dd>
<dt><strong><code>n_main_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations (samples to draw) per chain
during main (non-adaptive) sampling stage.</dd>
<dt><strong><code>trace_funcs</code></strong> :&ensp;<code>Iterable</code>[<code>Callable</code>[[<code>ChainState</code>], <code>Dict</code>[<code>str</code>, <code>array</code>]]]</dt>
<dd>
<p>List of functions which compute the variables to be recorded at
each chain iteration during the final (non-adaptive) sampling
stage, with each trace function being passed the current state
and returning a dictionary of scalar or array values
corresponding to the variable(s) to be stored. The keys in the
returned dictionaries are used to index the trace arrays in the
returned traces dictionary. If a key appears in multiple
dictionaries only the the value corresponding to the last trace
function to return that key will be stored.</p>
</dd>
<dt><strong><code>adapters</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>Iterable</code>[<code>Adapter</code>]</dt>
<dd>Dictionary of iterables
of <a title="mici.adapters.Adapter" href="adapters.html#mici.adapters.Adapter"><code>Adapter</code></a> instances keyed by strings
corresponding to the key of the transition in the <code>transitions</code>
dictionary to apply the adapters to, to use to adaptatively set
parameters of the transitions during the adaptive stages of the
chains. Note that the adapter updates are applied in the order
the adapters appear in the iterables and so if multiple adapters
change the same parameter(s) the order will matter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>OrderedDict</code>[<code>str</code>, <code>ChainStage</code>]: <code>Ordered</code> <code>dictionary</code> <code>specifying</code> <code>sampling</code></dt>
<dd>stage parameters.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/6015d755bbaec077b30609ff8d84b3126e7fcc7a/mici/stagers.py#L155-L214" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def stages(self, n_warm_up_iter, n_main_iter, adapters, trace_funcs):
    fast_adapters = {
        trans_key: [adapter for adapter in adapter_list if adapter.is_fast]
        for trans_key, adapter_list in adapters.items()
    }
    if (
        self.n_init_fast_stage_iter
        + self.n_init_slow_window_iter
        + self.n_final_fast_stage_iter
    ) &gt; n_warm_up_iter:
        n_init_fast_stage_iter = int(0.15 * n_warm_up_iter)
        n_final_fast_stage_iter = int(0.1 * n_warm_up_iter)
        n_init_slow_window_iter = (
            n_warm_up_iter - n_init_fast_stage_iter - n_final_fast_stage_iter
        )
    else:
        n_init_slow_window_iter = self.n_init_slow_window_iter
        n_init_fast_stage_iter = self.n_init_fast_stage_iter
        n_final_fast_stage_iter = self.n_final_fast_stage_iter
    # initial fast adaptation stage
    sampling_stages = OrderedDict(
        {
            &#34;Initial fast adaptive&#34;: ChainStage(
                n_init_fast_stage_iter, fast_adapters, []
            )
        }
    )
    # growing size slow adaptation windows
    n_window_iter = n_init_slow_window_iter
    slow_windows = []
    counter = 0
    n_slow_stage_iter = (
        n_warm_up_iter - n_init_fast_stage_iter - n_final_fast_stage_iter
    )
    while counter &lt; n_slow_stage_iter:
        # check if iteration counter at end of next loop iteration will be
        # greater than total number of warm up iterations and if so set
        # number of iterations in current window to be equal to all
        # remaining warm up iterations
        counter_next = counter + int(
            (1 + self.slow_window_multiplier) * n_window_iter
        )
        if counter_next &gt; n_slow_stage_iter:
            n_window_iter = n_slow_stage_iter - counter
        slow_windows.append(n_window_iter)
        counter += n_window_iter
        n_window_iter = int(self.slow_window_multiplier * n_window_iter)
    for i, n_iter in enumerate(slow_windows):
        sampling_stages[
            f&#34;Slow adaptive ({i + 1}/{len(slow_windows)})&#34;
        ] = ChainStage(n_iter, adapters, [])
    # final fast adaptation stage
    sampling_stages[&#34;Final fast adaptive&#34;] = ChainStage(
        n_final_fast_stage_iter, fast_adapters, []
    )
    # main non-adaptive stage
    sampling_stages[&#34;Main non-adaptive&#34;] = ChainStage(
        n_main_iter, None, trace_funcs
    )
    return sampling_stages</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
Copyright © 2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2.dev0+g1b644f6.d20200630</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad(); hljs.configure({languages: ["python"]});</script>
</body>
</html>