<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2.dev0+g1b644f6.d20200630" />
<title>mici.transitions API documentation</title>
<meta name="description" content="Markov transition kernels." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding-top:5px;padding-bottom:5px;padding-right:10px;padding-left:35px;text-indent:-25px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:1000px){#sidebar{width:540px;position:fixed;z-index:1;top:0;bottom:0;overflow-x:hidden;overflow-y:auto}#content{margin-left:540px;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}#footer{margin-left:540px}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mici.transitions.euclidean_no_u_turn_criterion" href="#mici.transitions.euclidean_no_u_turn_criterion">euclidean_no_u_turn_criterion</a></code></li>
<li><code><a title="mici.transitions.riemannian_no_u_turn_criterion" href="#mici.transitions.riemannian_no_u_turn_criterion">riemannian_no_u_turn_criterion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<code><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.Transition.sample" href="#mici.transitions.Transition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.Transition.state_variables" href="#mici.transitions.Transition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.Transition.statistic_types" href="#mici.transitions.Transition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.MomentumTransition" href="#mici.transitions.MomentumTransition">MomentumTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.MomentumTransition.sample" href="#mici.transitions.MomentumTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.MomentumTransition.state_variables" href="#mici.transitions.MomentumTransition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.MomentumTransition.statistic_types" href="#mici.transitions.MomentumTransition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.IndependentMomentumTransition" href="#mici.transitions.IndependentMomentumTransition">IndependentMomentumTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.IndependentMomentumTransition.sample" href="#mici.transitions.IndependentMomentumTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.IndependentMomentumTransition.statistic_types" href="#mici.transitions.IndependentMomentumTransition.statistic_types">statistic_types</a></code></li>
<li><code><a title="mici.transitions.IndependentMomentumTransition.state_variables" href="#mici.transitions.IndependentMomentumTransition.state_variables">state_variables</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.CorrelatedMomentumTransition" href="#mici.transitions.CorrelatedMomentumTransition">CorrelatedMomentumTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.CorrelatedMomentumTransition.sample" href="#mici.transitions.CorrelatedMomentumTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.CorrelatedMomentumTransition.statistic_types" href="#mici.transitions.CorrelatedMomentumTransition.statistic_types">statistic_types</a></code></li>
<li><code><a title="mici.transitions.CorrelatedMomentumTransition.state_variables" href="#mici.transitions.CorrelatedMomentumTransition.state_variables">state_variables</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.IntegrationTransition" href="#mici.transitions.IntegrationTransition">IntegrationTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.IntegrationTransition.sample" href="#mici.transitions.IntegrationTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.IntegrationTransition.state_variables" href="#mici.transitions.IntegrationTransition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.IntegrationTransition.statistic_types" href="#mici.transitions.IntegrationTransition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.MetropolisIntegrationTransition" href="#mici.transitions.MetropolisIntegrationTransition">MetropolisIntegrationTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.MetropolisIntegrationTransition.sample" href="#mici.transitions.MetropolisIntegrationTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.MetropolisIntegrationTransition.state_variables" href="#mici.transitions.MetropolisIntegrationTransition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.MetropolisIntegrationTransition.statistic_types" href="#mici.transitions.MetropolisIntegrationTransition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.MetropolisStaticIntegrationTransition" href="#mici.transitions.MetropolisStaticIntegrationTransition">MetropolisStaticIntegrationTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.MetropolisStaticIntegrationTransition.sample" href="#mici.transitions.MetropolisStaticIntegrationTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.MetropolisStaticIntegrationTransition.state_variables" href="#mici.transitions.MetropolisStaticIntegrationTransition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.MetropolisStaticIntegrationTransition.statistic_types" href="#mici.transitions.MetropolisStaticIntegrationTransition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.MetropolisRandomIntegrationTransition" href="#mici.transitions.MetropolisRandomIntegrationTransition">MetropolisRandomIntegrationTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.MetropolisRandomIntegrationTransition.sample" href="#mici.transitions.MetropolisRandomIntegrationTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.MetropolisRandomIntegrationTransition.state_variables" href="#mici.transitions.MetropolisRandomIntegrationTransition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.MetropolisRandomIntegrationTransition.statistic_types" href="#mici.transitions.MetropolisRandomIntegrationTransition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.DynamicIntegrationTransition" href="#mici.transitions.DynamicIntegrationTransition">DynamicIntegrationTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.DynamicIntegrationTransition.sample" href="#mici.transitions.DynamicIntegrationTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.DynamicIntegrationTransition.state_variables" href="#mici.transitions.DynamicIntegrationTransition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.DynamicIntegrationTransition.statistic_types" href="#mici.transitions.DynamicIntegrationTransition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.MultinomialDynamicIntegrationTransition" href="#mici.transitions.MultinomialDynamicIntegrationTransition">MultinomialDynamicIntegrationTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.MultinomialDynamicIntegrationTransition.sample" href="#mici.transitions.MultinomialDynamicIntegrationTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.MultinomialDynamicIntegrationTransition.state_variables" href="#mici.transitions.MultinomialDynamicIntegrationTransition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.MultinomialDynamicIntegrationTransition.statistic_types" href="#mici.transitions.MultinomialDynamicIntegrationTransition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
<li>
<code><a title="mici.transitions.SliceDynamicIntegrationTransition" href="#mici.transitions.SliceDynamicIntegrationTransition">SliceDynamicIntegrationTransition</a></code>
<details class="source">
<summary>
<span>Expand members</span>
</summary>
<ul class="">
<li><code><a title="mici.transitions.SliceDynamicIntegrationTransition.sample" href="#mici.transitions.SliceDynamicIntegrationTransition.sample">sample</a></code></li>
<li><code><a title="mici.transitions.SliceDynamicIntegrationTransition.state_variables" href="#mici.transitions.SliceDynamicIntegrationTransition.state_variables">state_variables</a></code></li>
<li><code><a title="mici.transitions.SliceDynamicIntegrationTransition.statistic_types" href="#mici.transitions.SliceDynamicIntegrationTransition.statistic_types">statistic_types</a></code></li>
</ul>
</details>
</li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Module <code>mici.transitions</code></h1>
</header>
<section id="section-intro">
<p>Markov transition kernels.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L0-L691" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Markov transition kernels.&#34;&#34;&#34;

from abc import ABC, abstractmethod, abstractproperty
from collections import namedtuple
from functools import partial
import logging
import numpy as np
from mici.utils import LogRepFloat
from mici.errors import (IntegratorError, NonReversibleStepError,
                         ConvergenceError, HamiltonianDivergenceError)

logger = logging.getLogger(__name__)


def _process_integrator_error(exception, stats):
    logger.info(f&#39;Terminating trajectory due to error:\n{exception!s}&#39;)
    # Only set stats fields to True if exception is of matching type.
    # Corresponding fields should be set to False by default for transitions
    # which potentially raise these errors.
    if isinstance(exception, HamiltonianDivergenceError):
        stats[&#39;diverging&#39;] = True
    elif isinstance(exception, NonReversibleStepError):
        stats[&#39;non_reversible_step&#39;] = True
    elif isinstance(exception, ConvergenceError):
        stats[&#39;convergence_error&#39;] = True


class Transition(ABC):
    &#34;&#34;&#34;Base class for Markov transition kernels.

    Defines expected interface for transitions by sampler classes.
    &#34;&#34;&#34;

    @abstractproperty
    def state_variables(self):
        &#34;&#34;&#34;A set of names of state variables accessed by this transition.&#34;&#34;&#34;

    @abstractproperty
    def statistic_types(self):
        &#34;&#34;&#34;A dictionary describing the statistics computed during transition.

        Either `None` if no statistics are returned by `sample` method or
        a dictionary with string keys and tuple values, with the keys defining
        the keys of the statistics returned in the `trans_stats` return value
        of the `sample` method and the first entry of the value tuples an
        appropriate NumPy `dtype` for the array used to store the corresponding
        statistic values and second entry the default value to initialize this
        array with.
        &#34;&#34;&#34;

    @abstractmethod
    def sample(self, state, rng):
        &#34;&#34;&#34;Sample a new chain state from the Markov transition kernel.

        Args:
            state (mici.states.ChainState): Current chain state to condition
                transition kernel on.
            rng (Generator or RandomState): Numpy random number generator.

        Returns:
            state (mici.states.ChainState): Updated state object.
            trans_stats (Dict[str, numeric] or None): Any statistics computed
                during the transition or `None` if no statistics.
        &#34;&#34;&#34;


class MomentumTransition(Transition):
    &#34;&#34;&#34;Base class for momentum transitions.

    Markov transition  kernel which leaves the conditional distribution on the
    momentum under the canonical distribution invariant, updating only the
    momentum component of the chain state.
    &#34;&#34;&#34;

    state_variables = {&#39;mom&#39;}
    statistic_types = None

    def __init__(self, system):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system defining
                conditional distribution on momentum to leave invariant.
        &#34;&#34;&#34;
        self.system = system

    @abstractmethod
    def sample(self, state, rng):
        &#34;&#34;&#34;Sample a new momentum component to state.

        Assigns a new momentum component to state by sampling from a Markov
        transition kernel which leaves the conditional distribution on the
        momentum under the canonical distribution defined by the Hamiltonian
        system invariant.

        Args:
            state (mici.states.ChainState): Current chain state to sample new
                momentum (momentum updated in place).
            rng (Generator or RandomState): Numpy random number generator.

        Returns:
            state (mici.states.ChainState): Updated state object.
            trans_stats (Dict[str, numeric] or None): Any statistics computed
                during the transition or `None` if no statistics.
        &#34;&#34;&#34;


class IndependentMomentumTransition(MomentumTransition):
    &#34;&#34;&#34;Independent momentum transition.

    Independently resamples the momentum component of the state from its
    conditional distribution given the remaining state.
    &#34;&#34;&#34;

    def sample(self, state, rng):
        state.mom = self.system.sample_momentum(state, rng)
        return state, None


class CorrelatedMomentumTransition(MomentumTransition):
    &#34;&#34;&#34;Correlated (partial) momentum transition.

    Rather than independently sampling a new momentum, instead a pertubative
    Crank-Nicolson type update which produces a new momentum value with a
    specified correlation with the previous value is used. It is assumed that
    the conditional distribution of the momenta is zero-mean Gaussian such that
    the Crank-Nicolson update leaves the momenta conditional distribution
    exactly invariant. This approach is sometimes known as partial momentum
    refreshing or updating, and was originally proposed in [1].

    If the resampling coefficient is equal to zero then the momentum is not
    randomized at all and succesive applications of the coupled integration
    transitions will continue along the same simulated Hamiltonian trajectory.
    When an integration transition is accepted this means the subsequent
    simulated trajectory will continue evolving in the same direction and so
    not randomising the momentum will reduce random-walk behaviour. However on
    a rejection the integration direction is reversed and so without
    randomisation the trajectory will exactly backtrack along the previous
    tractory states. A resampling coefficient of one corresponds to the
    standard case of independent resampling of the momenta while intermediate
    values between zero and one correspond to varying levels of correlation
    between the pre and post update momentums.

    References:

      1. Horowitz, A.M., 1991. A generalized guided Monte Carlo algorithm.
         Phys. Lett. B, 268(CERN-TH-6172-91), pp.247-252.
    &#34;&#34;&#34;

    def __init__(self, system, mom_resample_coeff=1.):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system defining
                conditional distribution on momentum to leave invariant.
            mom_resample_coeff (float): Scalar value in [0, 1] defining the
                momentum resampling coefficient.
        &#34;&#34;&#34;
        super().__init__(system)
        assert mom_resample_coeff &gt;= 0 and mom_resample_coeff &lt;= 1, (
            &#39;mom_resample_coeff should have a value in the interval [0, 1].&#39;)
        self.mom_resample_coeff = mom_resample_coeff

    def sample(self, state, rng):
        if self.mom_resample_coeff == 1:
            state.mom = self.system.sample_momentum(state, rng)
        elif self.mom_resample_coeff != 0:
            mom_ind = self.system.sample_momentum(state, rng)
            state.mom *= (1. - self.mom_resample_coeff**2)**0.5
            state.mom += self.mom_resample_coeff * mom_ind
        return state, None


class IntegrationTransition(Transition):
    &#34;&#34;&#34;Base class for integration transtions.

    Markov transition kernel which leaves canonical distribution invariant and
    jointly updates the position and momentum components of the chain state by
    integrating the Hamiltonian dynamics of the system to propose new values
    for the state.
    &#34;&#34;&#34;

    state_variables = {&#39;pos&#39;, &#39;mom&#39;, &#39;dir&#39;}
    statistic_types = {
        &#39;n_step&#39;: (np.int64, -1),
        &#39;accept_stat&#39;: (np.float64, np.nan),
        &#39;non_reversible_step&#39;: (np.bool, False),
        &#39;convergence_error&#39;: (np.bool, False)
    }

    def __init__(self, system, integrator):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system to be simulated.
            integrator (mici.integrators.Integrator): Symplectic integrator
                appropriate to the specified Hamiltonian system.
        &#34;&#34;&#34;
        self.system = system
        self.integrator = integrator

    @abstractmethod
    def sample(self, state, rng):
        &#34;&#34;&#34;Sample a position-momentum pair using integration based proposal(s).

        Samples new position and momentum values from a Markov transition
        kernel which leaves the canonical distribution on the state space
        corresponding to the Hamiltonian system invariant.

        Args:
            state (mici.states.ChainState): Current chain state.
            rng (Generator or RandomState): Numpy random number generator.

        Returns:
            state (mici.states.ChainState): Updated state object.
            trans_stats (Dict[str, numeric]): A dictionary of statistics
                computed during the transition to be recorded.
        &#34;&#34;&#34;


class MetropolisIntegrationTransition(IntegrationTransition):
    &#34;&#34;&#34;Base for HMC methods using a Metropolis accept step to sample new state.

    In each transition a trajectory is generated by integrating the Hamiltonian
    dynamics from the current state in the current integration time direction
    for a number of integrator steps.

    The state at the end of the trajectory with the integration direction
    negated (this ensuring the proposed move is an involution) is used as the
    proposal in a Metropolis acceptance step. The integration direction is then
    deterministically negated again irrespective of the accept decision, with
    the effect being that on acceptance the integration direction will be equal
    to its initial value and on rejection the integration direction will be
    the negation of its initial value.
    &#34;&#34;&#34;

    def __init__(self, system, integrator):
        super().__init__(system, integrator)
        self.statistic_types[&#39;metrop_accept_prob&#39;] = (np.float64, np.nan)

    def _sample_n_step(self, state, n_step, rng):
        h_init = self.system.h(state)
        state_p = state
        integration_error = False
        try:
            for s in range(n_step):
                state_p = self.integrator.step(state_p)
        except IntegratorError as e:
            integration_error = True
            stats = {&#39;n_step&#39;: s}
            _process_integrator_error(e, stats)
        else:
            stats = {&#39;n_step&#39;: n_step}
            # Reverse integration direction of proposal to form an involution
            state_p.dir *= -1
        if state_p is not state:
            h_final = self.system.h(state_p)
            metrop_ratio = np.exp(h_init - h_final)
            accept_prob = 0 if np.isnan(metrop_ratio) else min(1, metrop_ratio)
        else:
            accept_prob = 0.
        stats[&#39;metrop_accept_prob&#39;] = accept_prob
        stats[&#39;accept_stat&#39;] = accept_prob if not integration_error else 0
        if not integration_error and rng.uniform() &lt; accept_prob:
            state = state_p
        # Reverse integration direction of new state
        # As extended target distribution is symmetric in direction indicator
        # this always leaves the distribution invariant
        state.dir *= -1
        return state, stats


class MetropolisStaticIntegrationTransition(MetropolisIntegrationTransition):
    &#34;&#34;&#34;Static integration transition with Metropolis sampling of new state.

    In this variant the trajectory is generated by integrating the state
    through time a fixed number of integrator steps. This is original proposed
    Hybrid Monte Carlo (often now instead termed Hamiltonian Monte Carlo)
    algorithm [1,2].

    References:

      1. Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
         Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.
      2. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, n_step):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system to be simulated.
            integrator (mici.integrators.Integrator): Symplectic integrator
                appropriate to the specified Hamiltonian system.
            n_step (int): Number of integrator steps to simulate in each
                transition.
        &#34;&#34;&#34;
        super().__init__(system, integrator)
        assert n_step &gt; 0, &#39;Number of integrator steps must be positive&#39;
        self.n_step = n_step

    def sample(self, state, rng):
        return self._sample_n_step(state, self.n_step, rng)


class MetropolisRandomIntegrationTransition(MetropolisIntegrationTransition):
    &#34;&#34;&#34;Random integration transition with Metropolis sampling of new state.

    In each transition a trajectory is generated by integrating the state in
    the current integration direction in time a random integer number of
    integrator steps sampled from the uniform distribution on an integer
    interval. The randomisation of the number of integration steps avoids the
    potential of the chain mixing poorly due to using an integration time close
    to the period of (near) periodic systems [1,2].

    References:

      1. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
      2. Mackenzie, P.B., 1989. An improved hybrid Monte Carlo method.
         Physics Letters B, 226(3-4), pp.369-371.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, n_step_range):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system to be simulated.
            integrator (mici.integrators.Integrator): Symplectic integrator
                appropriate to the specified Hamiltonian system.
            n_step_range (Tuple[int, int]): Tuple `(lower, upper)` with two
                positive integer entries `lower` and `upper` (with
                `upper &gt; lower`) specifying respectively the lower and upper
                bounds (inclusive) of integer interval to uniformly draw random
                number integrator steps to simulate in each transition.
        &#34;&#34;&#34;
        super().__init__(system, integrator)
        n_step_lower, n_step_upper = n_step_range
        assert n_step_lower &gt; 0 and n_step_lower &lt; n_step_upper, (
            &#39;Range bounds must be non-negative and first entry less than last&#39;)
        self.n_step_range = n_step_range

    def sample(self, state, rng):
        n_step = rng.random_integers(*self.n_step_range)
        return self._sample_n_step(state, n_step, rng)


def euclidean_no_u_turn_criterion(system, state_1, state_2, sum_mom):
    &#34;&#34;&#34;No-U-turn termination criterion for Euclidean manifolds [1].

    Terminates trajectories when the velocities at the terminal states of
    the trajectory both have negative dot products with the vector from
    the position of the first terminal state to the position of the second
    terminal state, corresponding to further evolution of the trajectory
    reducing the distance between the terminal state positions.

    Args:
        system (mici.systems.System): Hamiltonian system being integrated.
        state_1 (mici.states.ChainState): First terminal state of trajectory.
        state_2 (mici.states.ChainState): Second terminal state of trajectory.
        sum_mom (array): Sum of momentums of trajectory states.

    Returns:
        terminate (bool): True if termination criterion is satisfied.

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
    &#34;&#34;&#34;
    return (
        np.sum(system.dh_dmom(state_1) * (state_2.pos - state_1.pos)) &lt; 0 or
        np.sum(system.dh_dmom(state_2) * (state_2.pos - state_1.pos)) &lt; 0)


def riemannian_no_u_turn_criterion(system, state_1, state_2, sum_mom):
    &#34;&#34;&#34;Generalized no-U-turn termination criterion on Riemannian manifolds [2].

    Terminates trajectories when the velocities at the terminal states of
    the trajectory both have negative dot products with the sum of the
    the momentums across the trajectory from the first to second terminal state
    of the first terminal state to the position of the second terminal state.
    This generalizes the no-U-turn criterion of [1] to Riemannian manifolds
    where due to the intrinsic curvature of the space the geodesic between
    two points is general no longer a straight line.

    Args:
        system (mici.systems.System): Hamiltonian system being integrated.
        state_1 (mici.states.ChainState): First terminal state of trajectory.
        state_2 (mici.states.ChainState): Second terminal state of trajectory.
        sum_mom (array): Sum of momentums of trajectory states.

    Returns:
        terminate (bool): True if termination criterion is satisfied.

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
      2. Betancourt, M., 2013. Generalizing the no-U-turn sampler to Riemannian
         manifolds. arXiv preprint arXiv:1304.1920.
    &#34;&#34;&#34;
    return (
        np.sum(system.dh_dmom(state_1) * sum_mom) &lt; 0 or
        np.sum(system.dh_dmom(state_2) * sum_mom) &lt; 0)


_SubTree = namedtuple(&#39;_SubTree&#39;, [
    &#39;negative&#39;, &#39;positive&#39;, &#39;sum_mom&#39;, &#39;weight&#39;, &#39;depth&#39;])


class DynamicIntegrationTransition(IntegrationTransition):
    &#34;&#34;&#34;Base class for dynamic integration transitions.

    In each transition a binary tree of states is recursively computed by
    integrating randomly forward and backward in time by a number of steps equal
    to the previous tree size until a termination criteria on the tree&#39;s
    subtrees is met. The next chain state is chosen from the candidate states
    using a progressive sampling scheme based on relative weights of the
    different candidate states, with the sampling biased towards states further
    from the current state [1, 2].

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
      2. Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
         Carlo. arXiv preprint arXiv:1701.02434.
    &#34;&#34;&#34;
    def __init__(self, system, integrator,
                 max_tree_depth=10, max_delta_h=1000,
                 termination_criterion=riemannian_no_u_turn_criterion,
                 do_extra_subtree_checks=True):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system to be simulated.
            integrator (mici.integrators.Integrator): Symplectic integrator
                appropriate to the specified Hamiltonian system.
            max_tree_depth (int): Maximum depth to expand trajectory binary
                tree to. The maximum number of integrator steps corresponds to
                `2**max_tree_depth`.
            max_delta_h (float): Maximum change to tolerate in the Hamiltonian
                function over a trajectory before signalling a divergence.
            termination_criterion (
                    Callable[[System, ChainState, ChainState, array], bool]):
                Function computing criterion to use to determine when to
                terminate trajectory tree expansion. The function should take a
                Hamiltonian system as its first argument, a pair of states
                corresponding to the two edge nodes in the trajectory
                (sub-)tree being checked and an array containing the sum of the
                momentums over the trajectory (sub)-tree. Defaults to
                `riemannian_no_u_turn_criterion`.
            do_extra_subtree_checks (bool): Whether to perform additional
                termination criterion checks on overlapping subtrees of the
                current tree to improve robustness in systems with dynamics
                which are well approximated by independent system of simple
                harmonic oscillators. In such systems (corresponding to e.g.
                a standard normal target distribution and identity metric
                matrix representation) at certain step sizes a &#39;resonant&#39;
                behaviour is seen by which the termination criterion fails to
                detect that the trajectory has expanded past a half-period i.e.
                has &#39;U-turned&#39; resulting in trajectories continuing to expand,
                potentially up until the `max_tree_depth` limit is hit. For
                more details see the Stan Discourse discussion at kutt.it/yAkIES
                If `do_extra_subtree_checks` is set to `True` additional
                termination criterion checks are performed on overlapping
                subtrees which help to reduce this resonant behaviour at the
                cost of more conservative trajectory termination in some
                correlated models and some overhead from additional checks.
        &#34;&#34;&#34;
        super().__init__(system, integrator)
        assert max_tree_depth &gt; 0, &#39;max_tree_depth must be non-negative&#39;
        self.max_tree_depth = max_tree_depth
        self.max_delta_h = max_delta_h
        self.termination_criterion = termination_criterion
        self.do_extra_subtree_checks = do_extra_subtree_checks
        self.statistic_types[&#39;av_metrop_accept_prob&#39;] = (np.float64, np.nan)
        self.statistic_types[&#39;reject_prob&#39;] = (np.float64, np.nan)
        self.statistic_types[&#39;tree_depth&#39;] = (np.int64, -1)
        self.statistic_types[&#39;diverging&#39;] = (np.bool, False)

    def _termination_criterion(self, tree, neg_subtree, pos_subtree):
        # If performing extra subtree checks evaluate lazily i.e. only evaluate
        # if initial whole tree check fails. Extra subtree checks also only
        # performed for trees of depth 2 and above (i.e. containing at least
        # 4 states) as for trees of depth 1 they are redundant.
        if self.termination_criterion(
                self.system, tree.negative, tree.positive, tree.sum_mom):
            return True
        elif tree.depth &gt; 1 and self.do_extra_subtree_checks:
            if self.termination_criterion(
                    self.system, neg_subtree.negative, pos_subtree.negative,
                    neg_subtree.sum_mom + pos_subtree.negative.mom):
                return True
            elif self.termination_criterion(
                    self.system, neg_subtree.positive, pos_subtree.positive,
                    pos_subtree.sum_mom + neg_subtree.positive.mom):
                return True
        return False

    def _new_leave(self, state, h, aux_info):
        return _SubTree(
            negative=state, positive=state, sum_mom=np.asarray(state.mom),
            weight=self._weight_function(h, aux_info), depth=0)

    def _merge_subtrees(self, neg_subtree, pos_subtree):
        assert neg_subtree.depth == pos_subtree.depth, (
            &#39;Cannot merge subtrees of different depths&#39;)
        return _SubTree(
            negative=neg_subtree.negative, positive=pos_subtree.positive,
            weight=neg_subtree.weight + pos_subtree.weight,
            sum_mom=neg_subtree.sum_mom + pos_subtree.sum_mom,
            depth=neg_subtree.depth + 1)

    def _init_aux_vars(self, state, rng):
        return {&#39;h_init&#39;: self.system.h(state)}

    @abstractmethod
    def _weight_function(self, h, aux_vars):
        pass

    @abstractmethod
    def _weight_ratio(self, numerator, denominator):
        pass

    @abstractmethod
    def _check_divergence(self, h, aux_vars):
        pass

    def _build_tree(self, depth, state, stats, rng, aux_vars):
        if depth == 0:
            # recursion base case
            try:
                # integrate forward/backward one step depending on state.dir
                state = self.integrator.step(state)
                h = self.system.h(state)
                h = np.inf if np.isnan(h) else h
                # create new tree leave
                tree = self._new_leave(state, h, aux_vars)
                proposal = state
                # accumulate stats
                stats[&#39;sum_metrop_accept_prob&#39;] += min(
                    1, np.exp(aux_vars[&#39;h_init&#39;] - h))
                stats[&#39;n_step&#39;] += 1
                # default to assuming valid and then check for divergence
                terminate = False
                self._check_divergence(h, aux_vars)
            except IntegratorError as e:
                _process_integrator_error(e, stats)
                terminate, tree, proposal = True, None, None
            return terminate, tree, proposal
        # build &#39;inner&#39; subtree, i.e. starting from current state
        terminate, inner_tree, inner_proposal = self._build_tree(
            depth - 1, state, stats, rng, aux_vars)
        if terminate:
            return terminate, None, None
        # build &#39;outer&#39; subtree, i.e. starting from terminus of inner subtree
        state = inner_tree.positive if state.dir == 1 else inner_tree.negative
        terminate, outer_tree, outer_proposal = self._build_tree(
            depth - 1, state, stats, rng, aux_vars)
        if terminate:
            return terminate, None, None
        # merge two subtrees accounting for integration direction
        neg_subtree = inner_tree if state.dir == 1 else outer_tree
        pos_subtree = outer_tree if state.dir == 1 else inner_tree
        tree = self._merge_subtrees(neg_subtree, pos_subtree)
        # sample new proposal from two subtree proposals according to weights
        accept_outer_prob = self._weight_ratio(outer_tree.weight, tree.weight)
        proposal = (
            outer_proposal if rng.uniform() &lt; accept_outer_prob else
            inner_proposal)
        # check termination criterion on tree and subtrees
        terminate = self._termination_criterion(tree, neg_subtree, pos_subtree)
        return terminate, tree, proposal

    def sample(self, state, rng):
        stats = {&#39;n_step&#39;: 0, &#39;sum_metrop_accept_prob&#39;: 0., &#39;reject_prob&#39;: 1.}
        aux_vars = self._init_aux_vars(state, rng)
        tree = self._new_leave(state, aux_vars[&#39;h_init&#39;], aux_vars)
        next_state = state
        for depth in range(self.max_tree_depth):
            # uniformly sample direction to expand tree in
            direction = 2 * (rng.uniform() &lt; 0.5) - 1
            state = tree.positive if direction == 1 else tree.negative
            state.dir = direction
            # expand tree by building new subtree of current depth
            terminate, new_tree, new_proposal = self._build_tree(
                depth, state, stats, rng, aux_vars)
            if terminate:
                break
            # progressively sample new state by choosing between
            # current new state and proposal from new subtree, biasing
            # towards the new subtree proposal
            accept_proposal_prob = self._weight_ratio(
                new_tree.weight, tree.weight)
            if rng.uniform() &lt; accept_proposal_prob:
                next_state = new_proposal
            # each proposal acceptance independent therefore overall probability
            # of &#39;rejecting&#39; - i.e. not accepting all proposals is product of
            # probabilties of not accepting each proposal
            stats[&#39;reject_prob&#39;] *= (1. - accept_proposal_prob)
            # merge new subtree into current tree accounting for direction
            neg_subtree = tree if direction == 1 else new_tree
            pos_subtree = new_tree if direction == 1 else tree
            tree = self._merge_subtrees(neg_subtree, pos_subtree)
            # check termination criterion on new tree and subtrees
            if self._termination_criterion(tree, neg_subtree, pos_subtree):
                break
        sum_accept_prob = stats.pop(&#39;sum_metrop_accept_prob&#39;)
        if stats[&#39;n_step&#39;] &gt; 0:
            stats[&#39;av_metrop_accept_prob&#39;] = sum_accept_prob / stats[&#39;n_step&#39;]
        else:
            stats[&#39;av_metrop_accept_prob&#39;] = 0.
        if any(stats.get(key, False) for key in
               [&#39;diverging&#39;, &#39;convergence_error&#39;, &#39;non_reversible_step&#39;]):
            stats[&#39;accept_stat&#39;] = 0.
        else:
            stats[&#39;accept_stat&#39;] = stats[&#39;av_metrop_accept_prob&#39;]
        stats[&#39;tree_depth&#39;] = depth
        return next_state, stats


class MultinomialDynamicIntegrationTransition(DynamicIntegrationTransition):
    &#34;&#34;&#34;Dynamic integration transition with multinomial sampling of new state.

    In each transition a binary tree of states is recursively computed by
    integrating randomly forward and backward in time by a number of steps
    equal to the previous tree size [1,2] until a termination criteria on the
    tree leaves is met. The next chain state is chosen from the candidate
    states using a progressive multinomial sampling scheme [2] based on the
    relative probability densities of the different candidate states, with the
    sampling biased towards states further from the current state.

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
      2. Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
         Carlo. arXiv preprint arXiv:1701.02434.
    &#34;&#34;&#34;

    def _weight_function(self, h, aux_vars):
        return LogRepFloat(log_val=-h)

    def _weight_ratio(self, numerator, denominator):
        return min(numerator / denominator, 1)

    def _check_divergence(self, h, aux_vars):
        if h - aux_vars[&#39;h_init&#39;] &gt; self.max_delta_h:
            raise HamiltonianDivergenceError(
                f&#39;delta_h = {h - aux_vars[&#34;h_init&#34;]}&#39;)


class SliceDynamicIntegrationTransition(DynamicIntegrationTransition):
    &#34;&#34;&#34;Dynamic integration transition with slice sampling of new state.

    In each transition a binary tree of states is recursively computed by
    integrating randomly forward and backward in time by a number of steps equal
    to the previous tree size until a termination criteria on the tree leaves is
    met. The next chain state is chosen from the candidate states using a
    progressive slice sampling scheme based on the relative probability
    densities of the different candidate states, with the slice sampler biased
    towards states further from the current state.

    When used with the `euclidean_no_u_turn_criterion` this transition is
    equivalent to the transitions in &#39;Algorithm 3: Efficient No-U-Turn Sampler&#39;
    in [1].

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
    &#34;&#34;&#34;

    def _init_aux_vars(self, state, rng):
        aux_vars = super()._init_aux_vars(state, rng)
        aux_vars[&#39;log_u&#39;] = np.log(rng.uniform()) - aux_vars[&#39;h_init&#39;]
        return aux_vars

    def _weight_function(self, h, aux_vars):
        return (aux_vars[&#39;log_u&#39;] &lt;= -h) * 1

    def _weight_ratio(self, numerator, denominator):
        return (
            min(numerator / denominator, 1) if denominator &gt; 0 else
            min(numerator, 1))

    def _check_divergence(self, h, aux_vars):
        if h + aux_vars[&#39;log_u&#39;] &gt; self.max_delta_h:
            raise HamiltonianDivergenceError(
                f&#39;delta_h = {h + aux_vars[&#34;log_u&#34;]}&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mici.transitions.euclidean_no_u_turn_criterion"><code class="name flex">
<span>def <span class="ident">euclidean_no_u_turn_criterion</span></span>(<span>system, state_1, state_2, sum_mom)</span>
</code></dt>
<dd>
<section class="desc"><p>No-U-turn termination criterion for Euclidean manifolds [1].</p>
<p>Terminates trajectories when the velocities at the terminal states of
the trajectory both have negative dot products with the vector from
the position of the first terminal state to the position of the second
terminal state, corresponding to further evolution of the trajectory
reducing the distance between the terminal state positions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system being integrated.</dd>
<dt><strong><code>state_1</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>First terminal state of trajectory.</dd>
<dt><strong><code>state_2</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Second terminal state of trajectory.</dd>
<dt><strong><code>sum_mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sum of momentums of trajectory states.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>terminate</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if termination criterion is satisfied.</dd>
</dl>
<h2 id="references">References</h2>
<ol>
<li>Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
adaptively setting path lengths in Hamiltonian Monte Carlo.
Journal of Machine Learning Research, 15(1), pp.1593-1623.</li>
</ol></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L344-L370" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def euclidean_no_u_turn_criterion(system, state_1, state_2, sum_mom):
    &#34;&#34;&#34;No-U-turn termination criterion for Euclidean manifolds [1].

    Terminates trajectories when the velocities at the terminal states of
    the trajectory both have negative dot products with the vector from
    the position of the first terminal state to the position of the second
    terminal state, corresponding to further evolution of the trajectory
    reducing the distance between the terminal state positions.

    Args:
        system (mici.systems.System): Hamiltonian system being integrated.
        state_1 (mici.states.ChainState): First terminal state of trajectory.
        state_2 (mici.states.ChainState): Second terminal state of trajectory.
        sum_mom (array): Sum of momentums of trajectory states.

    Returns:
        terminate (bool): True if termination criterion is satisfied.

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
    &#34;&#34;&#34;
    return (
        np.sum(system.dh_dmom(state_1) * (state_2.pos - state_1.pos)) &lt; 0 or
        np.sum(system.dh_dmom(state_2) * (state_2.pos - state_1.pos)) &lt; 0)</code></pre>
</details>
</dd>
<dt id="mici.transitions.riemannian_no_u_turn_criterion"><code class="name flex">
<span>def <span class="ident">riemannian_no_u_turn_criterion</span></span>(<span>system, state_1, state_2, sum_mom)</span>
</code></dt>
<dd>
<section class="desc"><p>Generalized no-U-turn termination criterion on Riemannian manifolds [2].</p>
<p>Terminates trajectories when the velocities at the terminal states of
the trajectory both have negative dot products with the sum of the
the momentums across the trajectory from the first to second terminal state
of the first terminal state to the position of the second terminal state.
This generalizes the no-U-turn criterion of [1] to Riemannian manifolds
where due to the intrinsic curvature of the space the geodesic between
two points is general no longer a straight line.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system being integrated.</dd>
<dt><strong><code>state_1</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>First terminal state of trajectory.</dd>
<dt><strong><code>state_2</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Second terminal state of trajectory.</dd>
<dt><strong><code>sum_mom</code></strong> :&ensp;<code>array</code></dt>
<dd>Sum of momentums of trajectory states.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>terminate</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if termination criterion is satisfied.</dd>
</dl>
<h2 id="references">References</h2>
<ol>
<li>Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
adaptively setting path lengths in Hamiltonian Monte Carlo.
Journal of Machine Learning Research, 15(1), pp.1593-1623.</li>
<li>Betancourt, M., 2013. Generalizing the no-U-turn sampler to Riemannian
manifolds. arXiv preprint arXiv:1304.1920.</li>
</ol></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L373-L403" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def riemannian_no_u_turn_criterion(system, state_1, state_2, sum_mom):
    &#34;&#34;&#34;Generalized no-U-turn termination criterion on Riemannian manifolds [2].

    Terminates trajectories when the velocities at the terminal states of
    the trajectory both have negative dot products with the sum of the
    the momentums across the trajectory from the first to second terminal state
    of the first terminal state to the position of the second terminal state.
    This generalizes the no-U-turn criterion of [1] to Riemannian manifolds
    where due to the intrinsic curvature of the space the geodesic between
    two points is general no longer a straight line.

    Args:
        system (mici.systems.System): Hamiltonian system being integrated.
        state_1 (mici.states.ChainState): First terminal state of trajectory.
        state_2 (mici.states.ChainState): Second terminal state of trajectory.
        sum_mom (array): Sum of momentums of trajectory states.

    Returns:
        terminate (bool): True if termination criterion is satisfied.

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
      2. Betancourt, M., 2013. Generalizing the no-U-turn sampler to Riemannian
         manifolds. arXiv preprint arXiv:1304.1920.
    &#34;&#34;&#34;
    return (
        np.sum(system.dh_dmom(state_1) * sum_mom) &lt; 0 or
        np.sum(system.dh_dmom(state_2) * sum_mom) &lt; 0)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.transitions.Transition"><code class="flex name class">
<span>class <span class="ident">Transition</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for Markov transition kernels.</p>
<p>Defines expected interface for transitions by sampler classes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L28-L64" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Transition(ABC):
    &#34;&#34;&#34;Base class for Markov transition kernels.

    Defines expected interface for transitions by sampler classes.
    &#34;&#34;&#34;

    @abstractproperty
    def state_variables(self):
        &#34;&#34;&#34;A set of names of state variables accessed by this transition.&#34;&#34;&#34;

    @abstractproperty
    def statistic_types(self):
        &#34;&#34;&#34;A dictionary describing the statistics computed during transition.

        Either `None` if no statistics are returned by `sample` method or
        a dictionary with string keys and tuple values, with the keys defining
        the keys of the statistics returned in the `trans_stats` return value
        of the `sample` method and the first entry of the value tuples an
        appropriate NumPy `dtype` for the array used to store the corresponding
        statistic values and second entry the default value to initialize this
        array with.
        &#34;&#34;&#34;

    @abstractmethod
    def sample(self, state, rng):
        &#34;&#34;&#34;Sample a new chain state from the Markov transition kernel.

        Args:
            state (mici.states.ChainState): Current chain state to condition
                transition kernel on.
            rng (Generator or RandomState): Numpy random number generator.

        Returns:
            state (mici.states.ChainState): Updated state object.
            trans_stats (Dict[str, numeric] or None): Any statistics computed
                during the transition or `None` if no statistics.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.transitions.MomentumTransition" href="#mici.transitions.MomentumTransition">MomentumTransition</a></li>
<li><a title="mici.transitions.IntegrationTransition" href="#mici.transitions.IntegrationTransition">IntegrationTransition</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.transitions.Transition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>A set of names of state variables accessed by this transition.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L34-L36" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractproperty
def state_variables(self):
    &#34;&#34;&#34;A set of names of state variables accessed by this transition.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.transitions.Transition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>A dictionary describing the statistics computed during transition.</p>
<p>Either <code>None</code> if no statistics are returned by <code>sample</code> method or
a dictionary with string keys and tuple values, with the keys defining
the keys of the statistics returned in the <code>trans_stats</code> return value
of the <code>sample</code> method and the first entry of the value tuples an
appropriate NumPy <code>dtype</code> for the array used to store the corresponding
statistic values and second entry the default value to initialize this
array with.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L38-L49" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractproperty
def statistic_types(self):
    &#34;&#34;&#34;A dictionary describing the statistics computed during transition.

    Either `None` if no statistics are returned by `sample` method or
    a dictionary with string keys and tuple values, with the keys defining
    the keys of the statistics returned in the `trans_stats` return value
    of the `sample` method and the first entry of the value tuples an
    appropriate NumPy `dtype` for the array used to store the corresponding
    statistic values and second entry the default value to initialize this
    array with.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.Transition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a new chain state from the Markov transition kernel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state to condition
transition kernel on.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>] or <code>None</code></dt>
<dd>Any statistics computed
during the transition or <code>None</code> if no statistics.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L51-L64" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def sample(self, state, rng):
    &#34;&#34;&#34;Sample a new chain state from the Markov transition kernel.

    Args:
        state (mici.states.ChainState): Current chain state to condition
            transition kernel on.
        rng (Generator or RandomState): Numpy random number generator.

    Returns:
        state (mici.states.ChainState): Updated state object.
        trans_stats (Dict[str, numeric] or None): Any statistics computed
            during the transition or `None` if no statistics.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.transitions.MomentumTransition"><code class="flex name class">
<span>class <span class="ident">MomentumTransition</span></span>
<span>(</span><span>system)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for momentum transitions.</p>
<p>Markov transition
kernel which leaves the conditional distribution on the
momentum under the canonical distribution invariant, updating only the
momentum component of the chain state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system defining
conditional distribution on momentum to leave invariant.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L67-L104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MomentumTransition(Transition):
    &#34;&#34;&#34;Base class for momentum transitions.

    Markov transition  kernel which leaves the conditional distribution on the
    momentum under the canonical distribution invariant, updating only the
    momentum component of the chain state.
    &#34;&#34;&#34;

    state_variables = {&#39;mom&#39;}
    statistic_types = None

    def __init__(self, system):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system defining
                conditional distribution on momentum to leave invariant.
        &#34;&#34;&#34;
        self.system = system

    @abstractmethod
    def sample(self, state, rng):
        &#34;&#34;&#34;Sample a new momentum component to state.

        Assigns a new momentum component to state by sampling from a Markov
        transition kernel which leaves the conditional distribution on the
        momentum under the canonical distribution defined by the Hamiltonian
        system invariant.

        Args:
            state (mici.states.ChainState): Current chain state to sample new
                momentum (momentum updated in place).
            rng (Generator or RandomState): Numpy random number generator.

        Returns:
            state (mici.states.ChainState): Updated state object.
            trans_stats (Dict[str, numeric] or None): Any statistics computed
                during the transition or `None` if no statistics.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.transitions.IndependentMomentumTransition" href="#mici.transitions.IndependentMomentumTransition">IndependentMomentumTransition</a></li>
<li><a title="mici.transitions.CorrelatedMomentumTransition" href="#mici.transitions.CorrelatedMomentumTransition">CorrelatedMomentumTransition</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.MomentumTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
<dt id="mici.transitions.MomentumTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>A dictionary describing the statistics computed during transition.</p>
<p>Either <code>None</code> if no statistics are returned by <code>sample</code> method or
a dictionary with string keys and tuple values, with the keys defining
the keys of the statistics returned in the <code>trans_stats</code> return value
of the <code>sample</code> method and the first entry of the value tuples an
appropriate NumPy <code>dtype</code> for the array used to store the corresponding
statistic values and second entry the default value to initialize this
array with.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.MomentumTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a new momentum component to state.</p>
<p>Assigns a new momentum component to state by sampling from a Markov
transition kernel which leaves the conditional distribution on the
momentum under the canonical distribution defined by the Hamiltonian
system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state to sample new
momentum (momentum updated in place).</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>] or <code>None</code></dt>
<dd>Any statistics computed
during the transition or <code>None</code> if no statistics.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L86-L104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def sample(self, state, rng):
    &#34;&#34;&#34;Sample a new momentum component to state.

    Assigns a new momentum component to state by sampling from a Markov
    transition kernel which leaves the conditional distribution on the
    momentum under the canonical distribution defined by the Hamiltonian
    system invariant.

    Args:
        state (mici.states.ChainState): Current chain state to sample new
            momentum (momentum updated in place).
        rng (Generator or RandomState): Numpy random number generator.

    Returns:
        state (mici.states.ChainState): Updated state object.
        trans_stats (Dict[str, numeric] or None): Any statistics computed
            during the transition or `None` if no statistics.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.transitions.IndependentMomentumTransition"><code class="flex name class">
<span>class <span class="ident">IndependentMomentumTransition</span></span>
<span>(</span><span>system)</span>
</code></dt>
<dd>
<section class="desc"><p>Independent momentum transition.</p>
<p>Independently resamples the momentum component of the state from its
conditional distribution given the remaining state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system defining
conditional distribution on momentum to leave invariant.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L107-L116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IndependentMomentumTransition(MomentumTransition):
    &#34;&#34;&#34;Independent momentum transition.

    Independently resamples the momentum component of the state from its
    conditional distribution given the remaining state.
    &#34;&#34;&#34;

    def sample(self, state, rng):
        state.mom = self.system.sample_momentum(state, rng)
        return state, None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.MomentumTransition" href="#mici.transitions.MomentumTransition">MomentumTransition</a></li>
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.IndependentMomentumTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mici.transitions.IndependentMomentumTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>A dictionary describing the statistics computed during transition.</p>
<p>Either <code>None</code> if no statistics are returned by <code>sample</code> method or
a dictionary with string keys and tuple values, with the keys defining
the keys of the statistics returned in the <code>trans_stats</code> return value
of the <code>sample</code> method and the first entry of the value tuples an
appropriate NumPy <code>dtype</code> for the array used to store the corresponding
statistic values and second entry the default value to initialize this
array with.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.IndependentMomentumTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a new momentum component to state.</p>
<p>Assigns a new momentum component to state by sampling from a Markov
transition kernel which leaves the conditional distribution on the
momentum under the canonical distribution defined by the Hamiltonian
system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state to sample new
momentum (momentum updated in place).</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>] or <code>None</code></dt>
<dd>Any statistics computed
during the transition or <code>None</code> if no statistics.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L114-L116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample(self, state, rng):
    state.mom = self.system.sample_momentum(state, rng)
    return state, None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.transitions.CorrelatedMomentumTransition"><code class="flex name class">
<span>class <span class="ident">CorrelatedMomentumTransition</span></span>
<span>(</span><span>system, mom_resample_coeff=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Correlated (partial) momentum transition.</p>
<p>Rather than independently sampling a new momentum, instead a pertubative
Crank-Nicolson type update which produces a new momentum value with a
specified correlation with the previous value is used. It is assumed that
the conditional distribution of the momenta is zero-mean Gaussian such that
the Crank-Nicolson update leaves the momenta conditional distribution
exactly invariant. This approach is sometimes known as partial momentum
refreshing or updating, and was originally proposed in [1].</p>
<p>If the resampling coefficient is equal to zero then the momentum is not
randomized at all and succesive applications of the coupled integration
transitions will continue along the same simulated Hamiltonian trajectory.
When an integration transition is accepted this means the subsequent
simulated trajectory will continue evolving in the same direction and so
not randomising the momentum will reduce random-walk behaviour. However on
a rejection the integration direction is reversed and so without
randomisation the trajectory will exactly backtrack along the previous
tractory states. A resampling coefficient of one corresponds to the
standard case of independent resampling of the momenta while intermediate
values between zero and one correspond to varying levels of correlation
between the pre and post update momentums.</p>
<h2 id="references">References</h2>
<ol>
<li>Horowitz, A.M., 1991. A generalized guided Monte Carlo algorithm.
Phys. Lett. B, 268(CERN-TH-6172-91), pp.247-252.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system defining
conditional distribution on momentum to leave invariant.</dd>
<dt><strong><code>mom_resample_coeff</code></strong> :&ensp;<code>float</code></dt>
<dd>Scalar value in [0, 1] defining the
momentum resampling coefficient.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L119-L169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CorrelatedMomentumTransition(MomentumTransition):
    &#34;&#34;&#34;Correlated (partial) momentum transition.

    Rather than independently sampling a new momentum, instead a pertubative
    Crank-Nicolson type update which produces a new momentum value with a
    specified correlation with the previous value is used. It is assumed that
    the conditional distribution of the momenta is zero-mean Gaussian such that
    the Crank-Nicolson update leaves the momenta conditional distribution
    exactly invariant. This approach is sometimes known as partial momentum
    refreshing or updating, and was originally proposed in [1].

    If the resampling coefficient is equal to zero then the momentum is not
    randomized at all and succesive applications of the coupled integration
    transitions will continue along the same simulated Hamiltonian trajectory.
    When an integration transition is accepted this means the subsequent
    simulated trajectory will continue evolving in the same direction and so
    not randomising the momentum will reduce random-walk behaviour. However on
    a rejection the integration direction is reversed and so without
    randomisation the trajectory will exactly backtrack along the previous
    tractory states. A resampling coefficient of one corresponds to the
    standard case of independent resampling of the momenta while intermediate
    values between zero and one correspond to varying levels of correlation
    between the pre and post update momentums.

    References:

      1. Horowitz, A.M., 1991. A generalized guided Monte Carlo algorithm.
         Phys. Lett. B, 268(CERN-TH-6172-91), pp.247-252.
    &#34;&#34;&#34;

    def __init__(self, system, mom_resample_coeff=1.):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system defining
                conditional distribution on momentum to leave invariant.
            mom_resample_coeff (float): Scalar value in [0, 1] defining the
                momentum resampling coefficient.
        &#34;&#34;&#34;
        super().__init__(system)
        assert mom_resample_coeff &gt;= 0 and mom_resample_coeff &lt;= 1, (
            &#39;mom_resample_coeff should have a value in the interval [0, 1].&#39;)
        self.mom_resample_coeff = mom_resample_coeff

    def sample(self, state, rng):
        if self.mom_resample_coeff == 1:
            state.mom = self.system.sample_momentum(state, rng)
        elif self.mom_resample_coeff != 0:
            mom_ind = self.system.sample_momentum(state, rng)
            state.mom *= (1. - self.mom_resample_coeff**2)**0.5
            state.mom += self.mom_resample_coeff * mom_ind
        return state, None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.MomentumTransition" href="#mici.transitions.MomentumTransition">MomentumTransition</a></li>
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.CorrelatedMomentumTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mici.transitions.CorrelatedMomentumTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>A dictionary describing the statistics computed during transition.</p>
<p>Either <code>None</code> if no statistics are returned by <code>sample</code> method or
a dictionary with string keys and tuple values, with the keys defining
the keys of the statistics returned in the <code>trans_stats</code> return value
of the <code>sample</code> method and the first entry of the value tuples an
appropriate NumPy <code>dtype</code> for the array used to store the corresponding
statistic values and second entry the default value to initialize this
array with.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.CorrelatedMomentumTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a new momentum component to state.</p>
<p>Assigns a new momentum component to state by sampling from a Markov
transition kernel which leaves the conditional distribution on the
momentum under the canonical distribution defined by the Hamiltonian
system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state to sample new
momentum (momentum updated in place).</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>] or <code>None</code></dt>
<dd>Any statistics computed
during the transition or <code>None</code> if no statistics.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L162-L169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample(self, state, rng):
    if self.mom_resample_coeff == 1:
        state.mom = self.system.sample_momentum(state, rng)
    elif self.mom_resample_coeff != 0:
        mom_ind = self.system.sample_momentum(state, rng)
        state.mom *= (1. - self.mom_resample_coeff**2)**0.5
        state.mom += self.mom_resample_coeff * mom_ind
    return state, None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.transitions.IntegrationTransition"><code class="flex name class">
<span>class <span class="ident">IntegrationTransition</span></span>
<span>(</span><span>system, integrator)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for integration transtions.</p>
<p>Markov transition kernel which leaves canonical distribution invariant and
jointly updates the position and momentum components of the chain state by
integrating the Hamiltonian dynamics of the system to propose new values
for the state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>integrator</code></strong> :&ensp;<a title="mici.integrators.Integrator" href="integrators.html#mici.integrators.Integrator"><code>Integrator</code></a></dt>
<dd>Symplectic integrator
appropriate to the specified Hamiltonian system.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L172-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IntegrationTransition(Transition):
    &#34;&#34;&#34;Base class for integration transtions.

    Markov transition kernel which leaves canonical distribution invariant and
    jointly updates the position and momentum components of the chain state by
    integrating the Hamiltonian dynamics of the system to propose new values
    for the state.
    &#34;&#34;&#34;

    state_variables = {&#39;pos&#39;, &#39;mom&#39;, &#39;dir&#39;}
    statistic_types = {
        &#39;n_step&#39;: (np.int64, -1),
        &#39;accept_stat&#39;: (np.float64, np.nan),
        &#39;non_reversible_step&#39;: (np.bool, False),
        &#39;convergence_error&#39;: (np.bool, False)
    }

    def __init__(self, system, integrator):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system to be simulated.
            integrator (mici.integrators.Integrator): Symplectic integrator
                appropriate to the specified Hamiltonian system.
        &#34;&#34;&#34;
        self.system = system
        self.integrator = integrator

    @abstractmethod
    def sample(self, state, rng):
        &#34;&#34;&#34;Sample a position-momentum pair using integration based proposal(s).

        Samples new position and momentum values from a Markov transition
        kernel which leaves the canonical distribution on the state space
        corresponding to the Hamiltonian system invariant.

        Args:
            state (mici.states.ChainState): Current chain state.
            rng (Generator or RandomState): Numpy random number generator.

        Returns:
            state (mici.states.ChainState): Updated state object.
            trans_stats (Dict[str, numeric]): A dictionary of statistics
                computed during the transition to be recorded.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.transitions.MetropolisIntegrationTransition" href="#mici.transitions.MetropolisIntegrationTransition">MetropolisIntegrationTransition</a></li>
<li><a title="mici.transitions.DynamicIntegrationTransition" href="#mici.transitions.DynamicIntegrationTransition">DynamicIntegrationTransition</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.IntegrationTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
<dt id="mici.transitions.IntegrationTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.IntegrationTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a position-momentum pair using integration based proposal(s).</p>
<p>Samples new position and momentum values from a Markov transition
kernel which leaves the canonical distribution on the state space
corresponding to the Hamiltonian system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>]</dt>
<dd>A dictionary of statistics
computed during the transition to be recorded.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L199-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def sample(self, state, rng):
    &#34;&#34;&#34;Sample a position-momentum pair using integration based proposal(s).

    Samples new position and momentum values from a Markov transition
    kernel which leaves the canonical distribution on the state space
    corresponding to the Hamiltonian system invariant.

    Args:
        state (mici.states.ChainState): Current chain state.
        rng (Generator or RandomState): Numpy random number generator.

    Returns:
        state (mici.states.ChainState): Updated state object.
        trans_stats (Dict[str, numeric]): A dictionary of statistics
            computed during the transition to be recorded.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.transitions.MetropolisIntegrationTransition"><code class="flex name class">
<span>class <span class="ident">MetropolisIntegrationTransition</span></span>
<span>(</span><span>system, integrator)</span>
</code></dt>
<dd>
<section class="desc"><p>Base for HMC methods using a Metropolis accept step to sample new state.</p>
<p>In each transition a trajectory is generated by integrating the Hamiltonian
dynamics from the current state in the current integration time direction
for a number of integrator steps.</p>
<p>The state at the end of the trajectory with the integration direction
negated (this ensuring the proposed move is an involution) is used as the
proposal in a Metropolis acceptance step. The integration direction is then
deterministically negated again irrespective of the accept decision, with
the effect being that on acceptance the integration direction will be equal
to its initial value and on rejection the integration direction will be
the negation of its initial value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>integrator</code></strong> :&ensp;<a title="mici.integrators.Integrator" href="integrators.html#mici.integrators.Integrator"><code>Integrator</code></a></dt>
<dd>Symplectic integrator
appropriate to the specified Hamiltonian system.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L218-L267" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MetropolisIntegrationTransition(IntegrationTransition):
    &#34;&#34;&#34;Base for HMC methods using a Metropolis accept step to sample new state.

    In each transition a trajectory is generated by integrating the Hamiltonian
    dynamics from the current state in the current integration time direction
    for a number of integrator steps.

    The state at the end of the trajectory with the integration direction
    negated (this ensuring the proposed move is an involution) is used as the
    proposal in a Metropolis acceptance step. The integration direction is then
    deterministically negated again irrespective of the accept decision, with
    the effect being that on acceptance the integration direction will be equal
    to its initial value and on rejection the integration direction will be
    the negation of its initial value.
    &#34;&#34;&#34;

    def __init__(self, system, integrator):
        super().__init__(system, integrator)
        self.statistic_types[&#39;metrop_accept_prob&#39;] = (np.float64, np.nan)

    def _sample_n_step(self, state, n_step, rng):
        h_init = self.system.h(state)
        state_p = state
        integration_error = False
        try:
            for s in range(n_step):
                state_p = self.integrator.step(state_p)
        except IntegratorError as e:
            integration_error = True
            stats = {&#39;n_step&#39;: s}
            _process_integrator_error(e, stats)
        else:
            stats = {&#39;n_step&#39;: n_step}
            # Reverse integration direction of proposal to form an involution
            state_p.dir *= -1
        if state_p is not state:
            h_final = self.system.h(state_p)
            metrop_ratio = np.exp(h_init - h_final)
            accept_prob = 0 if np.isnan(metrop_ratio) else min(1, metrop_ratio)
        else:
            accept_prob = 0.
        stats[&#39;metrop_accept_prob&#39;] = accept_prob
        stats[&#39;accept_stat&#39;] = accept_prob if not integration_error else 0
        if not integration_error and rng.uniform() &lt; accept_prob:
            state = state_p
        # Reverse integration direction of new state
        # As extended target distribution is symmetric in direction indicator
        # this always leaves the distribution invariant
        state.dir *= -1
        return state, stats</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.IntegrationTransition" href="#mici.transitions.IntegrationTransition">IntegrationTransition</a></li>
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.transitions.MetropolisStaticIntegrationTransition" href="#mici.transitions.MetropolisStaticIntegrationTransition">MetropolisStaticIntegrationTransition</a></li>
<li><a title="mici.transitions.MetropolisRandomIntegrationTransition" href="#mici.transitions.MetropolisRandomIntegrationTransition">MetropolisRandomIntegrationTransition</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.MetropolisIntegrationTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
<dt id="mici.transitions.MetropolisIntegrationTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.MetropolisIntegrationTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a position-momentum pair using integration based proposal(s).</p>
<p>Samples new position and momentum values from a Markov transition
kernel which leaves the canonical distribution on the state space
corresponding to the Hamiltonian system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>]</dt>
<dd>A dictionary of statistics
computed during the transition to be recorded.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.transitions.MetropolisStaticIntegrationTransition"><code class="flex name class">
<span>class <span class="ident">MetropolisStaticIntegrationTransition</span></span>
<span>(</span><span>system, integrator, n_step)</span>
</code></dt>
<dd>
<section class="desc"><p>Static integration transition with Metropolis sampling of new state.</p>
<p>In this variant the trajectory is generated by integrating the state
through time a fixed number of integrator steps. This is original proposed
Hybrid Monte Carlo (often now instead termed Hamiltonian Monte Carlo)
algorithm [1,2].</p>
<h2 id="references">References</h2>
<ol>
<li>Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.</li>
<li>Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
Handbook of Markov Chain Monte Carlo, 2(11), p.2.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>integrator</code></strong> :&ensp;<a title="mici.integrators.Integrator" href="integrators.html#mici.integrators.Integrator"><code>Integrator</code></a></dt>
<dd>Symplectic integrator
appropriate to the specified Hamiltonian system.</dd>
<dt><strong><code>n_step</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of integrator steps to simulate in each
transition.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L270-L300" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MetropolisStaticIntegrationTransition(MetropolisIntegrationTransition):
    &#34;&#34;&#34;Static integration transition with Metropolis sampling of new state.

    In this variant the trajectory is generated by integrating the state
    through time a fixed number of integrator steps. This is original proposed
    Hybrid Monte Carlo (often now instead termed Hamiltonian Monte Carlo)
    algorithm [1,2].

    References:

      1. Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
         Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.
      2. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, n_step):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system to be simulated.
            integrator (mici.integrators.Integrator): Symplectic integrator
                appropriate to the specified Hamiltonian system.
            n_step (int): Number of integrator steps to simulate in each
                transition.
        &#34;&#34;&#34;
        super().__init__(system, integrator)
        assert n_step &gt; 0, &#39;Number of integrator steps must be positive&#39;
        self.n_step = n_step

    def sample(self, state, rng):
        return self._sample_n_step(state, self.n_step, rng)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.MetropolisIntegrationTransition" href="#mici.transitions.MetropolisIntegrationTransition">MetropolisIntegrationTransition</a></li>
<li><a title="mici.transitions.IntegrationTransition" href="#mici.transitions.IntegrationTransition">IntegrationTransition</a></li>
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.MetropolisStaticIntegrationTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
<dt id="mici.transitions.MetropolisStaticIntegrationTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.MetropolisStaticIntegrationTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a position-momentum pair using integration based proposal(s).</p>
<p>Samples new position and momentum values from a Markov transition
kernel which leaves the canonical distribution on the state space
corresponding to the Hamiltonian system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>]</dt>
<dd>A dictionary of statistics
computed during the transition to be recorded.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L299-L300" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample(self, state, rng):
    return self._sample_n_step(state, self.n_step, rng)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.transitions.MetropolisRandomIntegrationTransition"><code class="flex name class">
<span>class <span class="ident">MetropolisRandomIntegrationTransition</span></span>
<span>(</span><span>system, integrator, n_step_range)</span>
</code></dt>
<dd>
<section class="desc"><p>Random integration transition with Metropolis sampling of new state.</p>
<p>In each transition a trajectory is generated by integrating the state in
the current integration direction in time a random integer number of
integrator steps sampled from the uniform distribution on an integer
interval. The randomisation of the number of integration steps avoids the
potential of the chain mixing poorly due to using an integration time close
to the period of (near) periodic systems [1,2].</p>
<h2 id="references">References</h2>
<ol>
<li>Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
Handbook of Markov Chain Monte Carlo, 2(11), p.2.</li>
<li>Mackenzie, P.B., 1989. An improved hybrid Monte Carlo method.
Physics Letters B, 226(3-4), pp.369-371.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>integrator</code></strong> :&ensp;<a title="mici.integrators.Integrator" href="integrators.html#mici.integrators.Integrator"><code>Integrator</code></a></dt>
<dd>Symplectic integrator
appropriate to the specified Hamiltonian system.</dd>
<dt><strong><code>n_step_range</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Tuple <code>(lower, upper)</code> with two
positive integer entries <code>lower</code> and <code>upper</code> (with
<code>upper &gt; lower</code>) specifying respectively the lower and upper
bounds (inclusive) of integer interval to uniformly draw random
number integrator steps to simulate in each transition.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L303-L341" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MetropolisRandomIntegrationTransition(MetropolisIntegrationTransition):
    &#34;&#34;&#34;Random integration transition with Metropolis sampling of new state.

    In each transition a trajectory is generated by integrating the state in
    the current integration direction in time a random integer number of
    integrator steps sampled from the uniform distribution on an integer
    interval. The randomisation of the number of integration steps avoids the
    potential of the chain mixing poorly due to using an integration time close
    to the period of (near) periodic systems [1,2].

    References:

      1. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
      2. Mackenzie, P.B., 1989. An improved hybrid Monte Carlo method.
         Physics Letters B, 226(3-4), pp.369-371.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, n_step_range):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system to be simulated.
            integrator (mici.integrators.Integrator): Symplectic integrator
                appropriate to the specified Hamiltonian system.
            n_step_range (Tuple[int, int]): Tuple `(lower, upper)` with two
                positive integer entries `lower` and `upper` (with
                `upper &gt; lower`) specifying respectively the lower and upper
                bounds (inclusive) of integer interval to uniformly draw random
                number integrator steps to simulate in each transition.
        &#34;&#34;&#34;
        super().__init__(system, integrator)
        n_step_lower, n_step_upper = n_step_range
        assert n_step_lower &gt; 0 and n_step_lower &lt; n_step_upper, (
            &#39;Range bounds must be non-negative and first entry less than last&#39;)
        self.n_step_range = n_step_range

    def sample(self, state, rng):
        n_step = rng.random_integers(*self.n_step_range)
        return self._sample_n_step(state, n_step, rng)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.MetropolisIntegrationTransition" href="#mici.transitions.MetropolisIntegrationTransition">MetropolisIntegrationTransition</a></li>
<li><a title="mici.transitions.IntegrationTransition" href="#mici.transitions.IntegrationTransition">IntegrationTransition</a></li>
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.MetropolisRandomIntegrationTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
<dt id="mici.transitions.MetropolisRandomIntegrationTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.MetropolisRandomIntegrationTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a position-momentum pair using integration based proposal(s).</p>
<p>Samples new position and momentum values from a Markov transition
kernel which leaves the canonical distribution on the state space
corresponding to the Hamiltonian system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>]</dt>
<dd>A dictionary of statistics
computed during the transition to be recorded.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L339-L341" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample(self, state, rng):
    n_step = rng.random_integers(*self.n_step_range)
    return self._sample_n_step(state, n_step, rng)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.transitions.DynamicIntegrationTransition"><code class="flex name class">
<span>class <span class="ident">DynamicIntegrationTransition</span></span>
<span>(</span><span>system, integrator, max_tree_depth=10, max_delta_h=1000, termination_criterion=&lt;function riemannian_no_u_turn_criterion&gt;, do_extra_subtree_checks=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for dynamic integration transitions.</p>
<p>In each transition a binary tree of states is recursively computed by
integrating randomly forward and backward in time by a number of steps equal
to the previous tree size until a termination criteria on the tree's
subtrees is met. The next chain state is chosen from the candidate states
using a progressive sampling scheme based on relative weights of the
different candidate states, with the sampling biased towards states further
from the current state [1, 2].</p>
<h2 id="references">References</h2>
<ol>
<li>Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
adaptively setting path lengths in Hamiltonian Monte Carlo.
Journal of Machine Learning Research, 15(1), pp.1593-1623.</li>
<li>Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
Carlo. arXiv preprint arXiv:1701.02434.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>integrator</code></strong> :&ensp;<a title="mici.integrators.Integrator" href="integrators.html#mici.integrators.Integrator"><code>Integrator</code></a></dt>
<dd>Symplectic integrator
appropriate to the specified Hamiltonian system.</dd>
<dt><strong><code>max_tree_depth</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum depth to expand trajectory binary
tree to. The maximum number of integrator steps corresponds to
<code>2**max_tree_depth</code>.</dd>
<dt><strong><code>max_delta_h</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum change to tolerate in the Hamiltonian
function over a trajectory before signalling a divergence.</dd>
<dt><strong><code>termination_criterion</code></strong> :&ensp;</dt>
<dt><code>Callable</code>[[<code>System</code>, <code>ChainState</code>, <code>ChainState</code>, <code>array</code>], <code>bool</code>]</dt>
<dd>
<p>Function computing criterion to use to determine when to
terminate trajectory tree expansion. The function should take a
Hamiltonian system as its first argument, a pair of states
corresponding to the two edge nodes in the trajectory
(sub-)tree being checked and an array containing the sum of the
momentums over the trajectory (sub)-tree. Defaults to
<a title="mici.transitions.riemannian_no_u_turn_criterion" href="#mici.transitions.riemannian_no_u_turn_criterion"><code>riemannian_no_u_turn_criterion()</code></a>.</p>
</dd>
<dt><strong><code>do_extra_subtree_checks</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to perform additional
termination criterion checks on overlapping subtrees of the
current tree to improve robustness in systems with dynamics
which are well approximated by independent system of simple
harmonic oscillators. In such systems (corresponding to e.g.
a standard normal target distribution and identity metric
matrix representation) at certain step sizes a 'resonant'
behaviour is seen by which the termination criterion fails to
detect that the trajectory has expanded past a half-period i.e.
has 'U-turned' resulting in trajectories continuing to expand,
potentially up until the <code>max_tree_depth</code> limit is hit. For
more details see the Stan Discourse discussion at kutt.it/yAkIES
If <code>do_extra_subtree_checks</code> is set to <code>True</code> additional
termination criterion checks are performed on overlapping
subtrees which help to reduce this resonant behaviour at the
cost of more conservative trajectory termination in some
correlated models and some overhead from additional checks.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L410-L619" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DynamicIntegrationTransition(IntegrationTransition):
    &#34;&#34;&#34;Base class for dynamic integration transitions.

    In each transition a binary tree of states is recursively computed by
    integrating randomly forward and backward in time by a number of steps equal
    to the previous tree size until a termination criteria on the tree&#39;s
    subtrees is met. The next chain state is chosen from the candidate states
    using a progressive sampling scheme based on relative weights of the
    different candidate states, with the sampling biased towards states further
    from the current state [1, 2].

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
      2. Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
         Carlo. arXiv preprint arXiv:1701.02434.
    &#34;&#34;&#34;
    def __init__(self, system, integrator,
                 max_tree_depth=10, max_delta_h=1000,
                 termination_criterion=riemannian_no_u_turn_criterion,
                 do_extra_subtree_checks=True):
        &#34;&#34;&#34;
        Args:
            system (mici.systems.System): Hamiltonian system to be simulated.
            integrator (mici.integrators.Integrator): Symplectic integrator
                appropriate to the specified Hamiltonian system.
            max_tree_depth (int): Maximum depth to expand trajectory binary
                tree to. The maximum number of integrator steps corresponds to
                `2**max_tree_depth`.
            max_delta_h (float): Maximum change to tolerate in the Hamiltonian
                function over a trajectory before signalling a divergence.
            termination_criterion (
                    Callable[[System, ChainState, ChainState, array], bool]):
                Function computing criterion to use to determine when to
                terminate trajectory tree expansion. The function should take a
                Hamiltonian system as its first argument, a pair of states
                corresponding to the two edge nodes in the trajectory
                (sub-)tree being checked and an array containing the sum of the
                momentums over the trajectory (sub)-tree. Defaults to
                `riemannian_no_u_turn_criterion`.
            do_extra_subtree_checks (bool): Whether to perform additional
                termination criterion checks on overlapping subtrees of the
                current tree to improve robustness in systems with dynamics
                which are well approximated by independent system of simple
                harmonic oscillators. In such systems (corresponding to e.g.
                a standard normal target distribution and identity metric
                matrix representation) at certain step sizes a &#39;resonant&#39;
                behaviour is seen by which the termination criterion fails to
                detect that the trajectory has expanded past a half-period i.e.
                has &#39;U-turned&#39; resulting in trajectories continuing to expand,
                potentially up until the `max_tree_depth` limit is hit. For
                more details see the Stan Discourse discussion at kutt.it/yAkIES
                If `do_extra_subtree_checks` is set to `True` additional
                termination criterion checks are performed on overlapping
                subtrees which help to reduce this resonant behaviour at the
                cost of more conservative trajectory termination in some
                correlated models and some overhead from additional checks.
        &#34;&#34;&#34;
        super().__init__(system, integrator)
        assert max_tree_depth &gt; 0, &#39;max_tree_depth must be non-negative&#39;
        self.max_tree_depth = max_tree_depth
        self.max_delta_h = max_delta_h
        self.termination_criterion = termination_criterion
        self.do_extra_subtree_checks = do_extra_subtree_checks
        self.statistic_types[&#39;av_metrop_accept_prob&#39;] = (np.float64, np.nan)
        self.statistic_types[&#39;reject_prob&#39;] = (np.float64, np.nan)
        self.statistic_types[&#39;tree_depth&#39;] = (np.int64, -1)
        self.statistic_types[&#39;diverging&#39;] = (np.bool, False)

    def _termination_criterion(self, tree, neg_subtree, pos_subtree):
        # If performing extra subtree checks evaluate lazily i.e. only evaluate
        # if initial whole tree check fails. Extra subtree checks also only
        # performed for trees of depth 2 and above (i.e. containing at least
        # 4 states) as for trees of depth 1 they are redundant.
        if self.termination_criterion(
                self.system, tree.negative, tree.positive, tree.sum_mom):
            return True
        elif tree.depth &gt; 1 and self.do_extra_subtree_checks:
            if self.termination_criterion(
                    self.system, neg_subtree.negative, pos_subtree.negative,
                    neg_subtree.sum_mom + pos_subtree.negative.mom):
                return True
            elif self.termination_criterion(
                    self.system, neg_subtree.positive, pos_subtree.positive,
                    pos_subtree.sum_mom + neg_subtree.positive.mom):
                return True
        return False

    def _new_leave(self, state, h, aux_info):
        return _SubTree(
            negative=state, positive=state, sum_mom=np.asarray(state.mom),
            weight=self._weight_function(h, aux_info), depth=0)

    def _merge_subtrees(self, neg_subtree, pos_subtree):
        assert neg_subtree.depth == pos_subtree.depth, (
            &#39;Cannot merge subtrees of different depths&#39;)
        return _SubTree(
            negative=neg_subtree.negative, positive=pos_subtree.positive,
            weight=neg_subtree.weight + pos_subtree.weight,
            sum_mom=neg_subtree.sum_mom + pos_subtree.sum_mom,
            depth=neg_subtree.depth + 1)

    def _init_aux_vars(self, state, rng):
        return {&#39;h_init&#39;: self.system.h(state)}

    @abstractmethod
    def _weight_function(self, h, aux_vars):
        pass

    @abstractmethod
    def _weight_ratio(self, numerator, denominator):
        pass

    @abstractmethod
    def _check_divergence(self, h, aux_vars):
        pass

    def _build_tree(self, depth, state, stats, rng, aux_vars):
        if depth == 0:
            # recursion base case
            try:
                # integrate forward/backward one step depending on state.dir
                state = self.integrator.step(state)
                h = self.system.h(state)
                h = np.inf if np.isnan(h) else h
                # create new tree leave
                tree = self._new_leave(state, h, aux_vars)
                proposal = state
                # accumulate stats
                stats[&#39;sum_metrop_accept_prob&#39;] += min(
                    1, np.exp(aux_vars[&#39;h_init&#39;] - h))
                stats[&#39;n_step&#39;] += 1
                # default to assuming valid and then check for divergence
                terminate = False
                self._check_divergence(h, aux_vars)
            except IntegratorError as e:
                _process_integrator_error(e, stats)
                terminate, tree, proposal = True, None, None
            return terminate, tree, proposal
        # build &#39;inner&#39; subtree, i.e. starting from current state
        terminate, inner_tree, inner_proposal = self._build_tree(
            depth - 1, state, stats, rng, aux_vars)
        if terminate:
            return terminate, None, None
        # build &#39;outer&#39; subtree, i.e. starting from terminus of inner subtree
        state = inner_tree.positive if state.dir == 1 else inner_tree.negative
        terminate, outer_tree, outer_proposal = self._build_tree(
            depth - 1, state, stats, rng, aux_vars)
        if terminate:
            return terminate, None, None
        # merge two subtrees accounting for integration direction
        neg_subtree = inner_tree if state.dir == 1 else outer_tree
        pos_subtree = outer_tree if state.dir == 1 else inner_tree
        tree = self._merge_subtrees(neg_subtree, pos_subtree)
        # sample new proposal from two subtree proposals according to weights
        accept_outer_prob = self._weight_ratio(outer_tree.weight, tree.weight)
        proposal = (
            outer_proposal if rng.uniform() &lt; accept_outer_prob else
            inner_proposal)
        # check termination criterion on tree and subtrees
        terminate = self._termination_criterion(tree, neg_subtree, pos_subtree)
        return terminate, tree, proposal

    def sample(self, state, rng):
        stats = {&#39;n_step&#39;: 0, &#39;sum_metrop_accept_prob&#39;: 0., &#39;reject_prob&#39;: 1.}
        aux_vars = self._init_aux_vars(state, rng)
        tree = self._new_leave(state, aux_vars[&#39;h_init&#39;], aux_vars)
        next_state = state
        for depth in range(self.max_tree_depth):
            # uniformly sample direction to expand tree in
            direction = 2 * (rng.uniform() &lt; 0.5) - 1
            state = tree.positive if direction == 1 else tree.negative
            state.dir = direction
            # expand tree by building new subtree of current depth
            terminate, new_tree, new_proposal = self._build_tree(
                depth, state, stats, rng, aux_vars)
            if terminate:
                break
            # progressively sample new state by choosing between
            # current new state and proposal from new subtree, biasing
            # towards the new subtree proposal
            accept_proposal_prob = self._weight_ratio(
                new_tree.weight, tree.weight)
            if rng.uniform() &lt; accept_proposal_prob:
                next_state = new_proposal
            # each proposal acceptance independent therefore overall probability
            # of &#39;rejecting&#39; - i.e. not accepting all proposals is product of
            # probabilties of not accepting each proposal
            stats[&#39;reject_prob&#39;] *= (1. - accept_proposal_prob)
            # merge new subtree into current tree accounting for direction
            neg_subtree = tree if direction == 1 else new_tree
            pos_subtree = new_tree if direction == 1 else tree
            tree = self._merge_subtrees(neg_subtree, pos_subtree)
            # check termination criterion on new tree and subtrees
            if self._termination_criterion(tree, neg_subtree, pos_subtree):
                break
        sum_accept_prob = stats.pop(&#39;sum_metrop_accept_prob&#39;)
        if stats[&#39;n_step&#39;] &gt; 0:
            stats[&#39;av_metrop_accept_prob&#39;] = sum_accept_prob / stats[&#39;n_step&#39;]
        else:
            stats[&#39;av_metrop_accept_prob&#39;] = 0.
        if any(stats.get(key, False) for key in
               [&#39;diverging&#39;, &#39;convergence_error&#39;, &#39;non_reversible_step&#39;]):
            stats[&#39;accept_stat&#39;] = 0.
        else:
            stats[&#39;accept_stat&#39;] = stats[&#39;av_metrop_accept_prob&#39;]
        stats[&#39;tree_depth&#39;] = depth
        return next_state, stats</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.IntegrationTransition" href="#mici.transitions.IntegrationTransition">IntegrationTransition</a></li>
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.transitions.MultinomialDynamicIntegrationTransition" href="#mici.transitions.MultinomialDynamicIntegrationTransition">MultinomialDynamicIntegrationTransition</a></li>
<li><a title="mici.transitions.SliceDynamicIntegrationTransition" href="#mici.transitions.SliceDynamicIntegrationTransition">SliceDynamicIntegrationTransition</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.DynamicIntegrationTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
<dt id="mici.transitions.DynamicIntegrationTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.DynamicIntegrationTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a position-momentum pair using integration based proposal(s).</p>
<p>Samples new position and momentum values from a Markov transition
kernel which leaves the canonical distribution on the state space
corresponding to the Hamiltonian system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>]</dt>
<dd>A dictionary of statistics
computed during the transition to be recorded.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L575-L619" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample(self, state, rng):
    stats = {&#39;n_step&#39;: 0, &#39;sum_metrop_accept_prob&#39;: 0., &#39;reject_prob&#39;: 1.}
    aux_vars = self._init_aux_vars(state, rng)
    tree = self._new_leave(state, aux_vars[&#39;h_init&#39;], aux_vars)
    next_state = state
    for depth in range(self.max_tree_depth):
        # uniformly sample direction to expand tree in
        direction = 2 * (rng.uniform() &lt; 0.5) - 1
        state = tree.positive if direction == 1 else tree.negative
        state.dir = direction
        # expand tree by building new subtree of current depth
        terminate, new_tree, new_proposal = self._build_tree(
            depth, state, stats, rng, aux_vars)
        if terminate:
            break
        # progressively sample new state by choosing between
        # current new state and proposal from new subtree, biasing
        # towards the new subtree proposal
        accept_proposal_prob = self._weight_ratio(
            new_tree.weight, tree.weight)
        if rng.uniform() &lt; accept_proposal_prob:
            next_state = new_proposal
        # each proposal acceptance independent therefore overall probability
        # of &#39;rejecting&#39; - i.e. not accepting all proposals is product of
        # probabilties of not accepting each proposal
        stats[&#39;reject_prob&#39;] *= (1. - accept_proposal_prob)
        # merge new subtree into current tree accounting for direction
        neg_subtree = tree if direction == 1 else new_tree
        pos_subtree = new_tree if direction == 1 else tree
        tree = self._merge_subtrees(neg_subtree, pos_subtree)
        # check termination criterion on new tree and subtrees
        if self._termination_criterion(tree, neg_subtree, pos_subtree):
            break
    sum_accept_prob = stats.pop(&#39;sum_metrop_accept_prob&#39;)
    if stats[&#39;n_step&#39;] &gt; 0:
        stats[&#39;av_metrop_accept_prob&#39;] = sum_accept_prob / stats[&#39;n_step&#39;]
    else:
        stats[&#39;av_metrop_accept_prob&#39;] = 0.
    if any(stats.get(key, False) for key in
           [&#39;diverging&#39;, &#39;convergence_error&#39;, &#39;non_reversible_step&#39;]):
        stats[&#39;accept_stat&#39;] = 0.
    else:
        stats[&#39;accept_stat&#39;] = stats[&#39;av_metrop_accept_prob&#39;]
    stats[&#39;tree_depth&#39;] = depth
    return next_state, stats</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.transitions.MultinomialDynamicIntegrationTransition"><code class="flex name class">
<span>class <span class="ident">MultinomialDynamicIntegrationTransition</span></span>
<span>(</span><span>system, integrator, max_tree_depth=10, max_delta_h=1000, termination_criterion=&lt;function riemannian_no_u_turn_criterion&gt;, do_extra_subtree_checks=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Dynamic integration transition with multinomial sampling of new state.</p>
<p>In each transition a binary tree of states is recursively computed by
integrating randomly forward and backward in time by a number of steps
equal to the previous tree size [1,2] until a termination criteria on the
tree leaves is met. The next chain state is chosen from the candidate
states using a progressive multinomial sampling scheme [2] based on the
relative probability densities of the different candidate states, with the
sampling biased towards states further from the current state.</p>
<h2 id="references">References</h2>
<ol>
<li>Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
adaptively setting path lengths in Hamiltonian Monte Carlo.
Journal of Machine Learning Research, 15(1), pp.1593-1623.</li>
<li>Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
Carlo. arXiv preprint arXiv:1701.02434.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>integrator</code></strong> :&ensp;<a title="mici.integrators.Integrator" href="integrators.html#mici.integrators.Integrator"><code>Integrator</code></a></dt>
<dd>Symplectic integrator
appropriate to the specified Hamiltonian system.</dd>
<dt><strong><code>max_tree_depth</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum depth to expand trajectory binary
tree to. The maximum number of integrator steps corresponds to
<code>2**max_tree_depth</code>.</dd>
<dt><strong><code>max_delta_h</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum change to tolerate in the Hamiltonian
function over a trajectory before signalling a divergence.</dd>
<dt><strong><code>termination_criterion</code></strong> :&ensp;</dt>
<dt><code>Callable</code>[[<code>System</code>, <code>ChainState</code>, <code>ChainState</code>, <code>array</code>], <code>bool</code>]</dt>
<dd>
<p>Function computing criterion to use to determine when to
terminate trajectory tree expansion. The function should take a
Hamiltonian system as its first argument, a pair of states
corresponding to the two edge nodes in the trajectory
(sub-)tree being checked and an array containing the sum of the
momentums over the trajectory (sub)-tree. Defaults to
<a title="mici.transitions.riemannian_no_u_turn_criterion" href="#mici.transitions.riemannian_no_u_turn_criterion"><code>riemannian_no_u_turn_criterion()</code></a>.</p>
</dd>
<dt><strong><code>do_extra_subtree_checks</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to perform additional
termination criterion checks on overlapping subtrees of the
current tree to improve robustness in systems with dynamics
which are well approximated by independent system of simple
harmonic oscillators. In such systems (corresponding to e.g.
a standard normal target distribution and identity metric
matrix representation) at certain step sizes a 'resonant'
behaviour is seen by which the termination criterion fails to
detect that the trajectory has expanded past a half-period i.e.
has 'U-turned' resulting in trajectories continuing to expand,
potentially up until the <code>max_tree_depth</code> limit is hit. For
more details see the Stan Discourse discussion at kutt.it/yAkIES
If <code>do_extra_subtree_checks</code> is set to <code>True</code> additional
termination criterion checks are performed on overlapping
subtrees which help to reduce this resonant behaviour at the
cost of more conservative trajectory termination in some
correlated models and some overhead from additional checks.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L622-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MultinomialDynamicIntegrationTransition(DynamicIntegrationTransition):
    &#34;&#34;&#34;Dynamic integration transition with multinomial sampling of new state.

    In each transition a binary tree of states is recursively computed by
    integrating randomly forward and backward in time by a number of steps
    equal to the previous tree size [1,2] until a termination criteria on the
    tree leaves is met. The next chain state is chosen from the candidate
    states using a progressive multinomial sampling scheme [2] based on the
    relative probability densities of the different candidate states, with the
    sampling biased towards states further from the current state.

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
      2. Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
         Carlo. arXiv preprint arXiv:1701.02434.
    &#34;&#34;&#34;

    def _weight_function(self, h, aux_vars):
        return LogRepFloat(log_val=-h)

    def _weight_ratio(self, numerator, denominator):
        return min(numerator / denominator, 1)

    def _check_divergence(self, h, aux_vars):
        if h - aux_vars[&#39;h_init&#39;] &gt; self.max_delta_h:
            raise HamiltonianDivergenceError(
                f&#39;delta_h = {h - aux_vars[&#34;h_init&#34;]}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.DynamicIntegrationTransition" href="#mici.transitions.DynamicIntegrationTransition">DynamicIntegrationTransition</a></li>
<li><a title="mici.transitions.IntegrationTransition" href="#mici.transitions.IntegrationTransition">IntegrationTransition</a></li>
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.MultinomialDynamicIntegrationTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
<dt id="mici.transitions.MultinomialDynamicIntegrationTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.MultinomialDynamicIntegrationTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a position-momentum pair using integration based proposal(s).</p>
<p>Samples new position and momentum values from a Markov transition
kernel which leaves the canonical distribution on the state space
corresponding to the Hamiltonian system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>]</dt>
<dd>A dictionary of statistics
computed during the transition to be recorded.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.transitions.SliceDynamicIntegrationTransition"><code class="flex name class">
<span>class <span class="ident">SliceDynamicIntegrationTransition</span></span>
<span>(</span><span>system, integrator, max_tree_depth=10, max_delta_h=1000, termination_criterion=&lt;function riemannian_no_u_turn_criterion&gt;, do_extra_subtree_checks=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Dynamic integration transition with slice sampling of new state.</p>
<p>In each transition a binary tree of states is recursively computed by
integrating randomly forward and backward in time by a number of steps equal
to the previous tree size until a termination criteria on the tree leaves is
met. The next chain state is chosen from the candidate states using a
progressive slice sampling scheme based on the relative probability
densities of the different candidate states, with the slice sampler biased
towards states further from the current state.</p>
<p>When used with the <a title="mici.transitions.euclidean_no_u_turn_criterion" href="#mici.transitions.euclidean_no_u_turn_criterion"><code>euclidean_no_u_turn_criterion()</code></a> this transition is
equivalent to the transitions in 'Algorithm 3: Efficient No-U-Turn Sampler'
in [1].</p>
<h2 id="references">References</h2>
<ol>
<li>Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
adaptively setting path lengths in Hamiltonian Monte Carlo.
Journal of Machine Learning Research, 15(1), pp.1593-1623.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.System" href="systems.html#mici.systems.System"><code>System</code></a></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>integrator</code></strong> :&ensp;<a title="mici.integrators.Integrator" href="integrators.html#mici.integrators.Integrator"><code>Integrator</code></a></dt>
<dd>Symplectic integrator
appropriate to the specified Hamiltonian system.</dd>
<dt><strong><code>max_tree_depth</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum depth to expand trajectory binary
tree to. The maximum number of integrator steps corresponds to
<code>2**max_tree_depth</code>.</dd>
<dt><strong><code>max_delta_h</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum change to tolerate in the Hamiltonian
function over a trajectory before signalling a divergence.</dd>
<dt><strong><code>termination_criterion</code></strong> :&ensp;</dt>
<dt><code>Callable</code>[[<code>System</code>, <code>ChainState</code>, <code>ChainState</code>, <code>array</code>], <code>bool</code>]</dt>
<dd>
<p>Function computing criterion to use to determine when to
terminate trajectory tree expansion. The function should take a
Hamiltonian system as its first argument, a pair of states
corresponding to the two edge nodes in the trajectory
(sub-)tree being checked and an array containing the sum of the
momentums over the trajectory (sub)-tree. Defaults to
<a title="mici.transitions.riemannian_no_u_turn_criterion" href="#mici.transitions.riemannian_no_u_turn_criterion"><code>riemannian_no_u_turn_criterion()</code></a>.</p>
</dd>
<dt><strong><code>do_extra_subtree_checks</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to perform additional
termination criterion checks on overlapping subtrees of the
current tree to improve robustness in systems with dynamics
which are well approximated by independent system of simple
harmonic oscillators. In such systems (corresponding to e.g.
a standard normal target distribution and identity metric
matrix representation) at certain step sizes a 'resonant'
behaviour is seen by which the termination criterion fails to
detect that the trajectory has expanded past a half-period i.e.
has 'U-turned' resulting in trajectories continuing to expand,
potentially up until the <code>max_tree_depth</code> limit is hit. For
more details see the Stan Discourse discussion at kutt.it/yAkIES
If <code>do_extra_subtree_checks</code> is set to <code>True</code> additional
termination criterion checks are performed on overlapping
subtrees which help to reduce this resonant behaviour at the
cost of more conservative trajectory termination in some
correlated models and some overhead from additional checks.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/transitions.py#L654-L692" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SliceDynamicIntegrationTransition(DynamicIntegrationTransition):
    &#34;&#34;&#34;Dynamic integration transition with slice sampling of new state.

    In each transition a binary tree of states is recursively computed by
    integrating randomly forward and backward in time by a number of steps equal
    to the previous tree size until a termination criteria on the tree leaves is
    met. The next chain state is chosen from the candidate states using a
    progressive slice sampling scheme based on the relative probability
    densities of the different candidate states, with the slice sampler biased
    towards states further from the current state.

    When used with the `euclidean_no_u_turn_criterion` this transition is
    equivalent to the transitions in &#39;Algorithm 3: Efficient No-U-Turn Sampler&#39;
    in [1].

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
    &#34;&#34;&#34;

    def _init_aux_vars(self, state, rng):
        aux_vars = super()._init_aux_vars(state, rng)
        aux_vars[&#39;log_u&#39;] = np.log(rng.uniform()) - aux_vars[&#39;h_init&#39;]
        return aux_vars

    def _weight_function(self, h, aux_vars):
        return (aux_vars[&#39;log_u&#39;] &lt;= -h) * 1

    def _weight_ratio(self, numerator, denominator):
        return (
            min(numerator / denominator, 1) if denominator &gt; 0 else
            min(numerator, 1))

    def _check_divergence(self, h, aux_vars):
        if h + aux_vars[&#39;log_u&#39;] &gt; self.max_delta_h:
            raise HamiltonianDivergenceError(
                f&#39;delta_h = {h + aux_vars[&#34;log_u&#34;]}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.transitions.DynamicIntegrationTransition" href="#mici.transitions.DynamicIntegrationTransition">DynamicIntegrationTransition</a></li>
<li><a title="mici.transitions.IntegrationTransition" href="#mici.transitions.IntegrationTransition">IntegrationTransition</a></li>
<li><a title="mici.transitions.Transition" href="#mici.transitions.Transition">Transition</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mici.transitions.SliceDynamicIntegrationTransition.state_variables"><code class="name">var <span class="ident">state_variables</span></code></dt>
<dd>
<section class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></section>
</dd>
<dt id="mici.transitions.SliceDynamicIntegrationTransition.statistic_types"><code class="name">var <span class="ident">statistic_types</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.transitions.SliceDynamicIntegrationTransition.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, state, rng)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a position-momentum pair using integration based proposal(s).</p>
<p>Samples new position and momentum values from a Markov transition
kernel which leaves the canonical distribution on the state space
corresponding to the Hamiltonian system invariant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Current chain state.</dd>
<dt><strong><code>rng</code></strong> :&ensp;<code>Generator</code> or <code>RandomState</code></dt>
<dd>Numpy random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Updated state object.</dd>
<dt><strong><code>trans_stats</code></strong> :&ensp;<code>Dict</code>[<code>str</code>, <code>numeric</code>]</dt>
<dd>A dictionary of statistics
computed during the transition to be recorded.</dd>
</dl></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
Copyright © 2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2.dev0+g1b644f6.d20200630</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad(); hljs.configure({languages: ["python"]});</script>
</body>
</html>