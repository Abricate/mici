<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2.dev0+g1b644f6.d20200507" />
<title>mici.matrices API documentation</title>
<meta name="description" content="Structured matrix classes implementing basic linear algebra operations." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding-top:5px;padding-bottom:5px;padding-right:10px;padding-left:35px;text-indent:-25px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:1000px){#sidebar{width:600px;position:fixed;z-index:1;top:0;bottom:0;overflow-x:hidden;overflow-y:auto}#content{margin-left:600px;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}#footer{margin-left:600px}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.Matrix.shape" href="#mici.matrices.Matrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.Matrix.array" href="#mici.matrices.Matrix.array">array</a></code></li>
<li><code><a title="mici.matrices.Matrix.T" href="#mici.matrices.Matrix.T">T</a></code></li>
<li><code><a title="mici.matrices.Matrix.diagonal" href="#mici.matrices.Matrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.ExplicitArrayMatrix.array" href="#mici.matrices.ExplicitArrayMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.ExplicitArrayMatrix.shape" href="#mici.matrices.ExplicitArrayMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.ExplicitArrayMatrix.T" href="#mici.matrices.ExplicitArrayMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.ExplicitArrayMatrix.diagonal" href="#mici.matrices.ExplicitArrayMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.ImplicitArrayMatrix.array" href="#mici.matrices.ImplicitArrayMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.ImplicitArrayMatrix.shape" href="#mici.matrices.ImplicitArrayMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.ImplicitArrayMatrix.T" href="#mici.matrices.ImplicitArrayMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.ImplicitArrayMatrix.diagonal" href="#mici.matrices.ImplicitArrayMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.MatrixProduct" href="#mici.matrices.MatrixProduct">MatrixProduct</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.MatrixProduct.matrices" href="#mici.matrices.MatrixProduct.matrices">matrices</a></code></li>
<li><code><a title="mici.matrices.MatrixProduct.T" href="#mici.matrices.MatrixProduct.T">T</a></code></li>
<li><code><a title="mici.matrices.MatrixProduct.array" href="#mici.matrices.MatrixProduct.array">array</a></code></li>
<li><code><a title="mici.matrices.MatrixProduct.shape" href="#mici.matrices.MatrixProduct.shape">shape</a></code></li>
<li><code><a title="mici.matrices.MatrixProduct.diagonal" href="#mici.matrices.MatrixProduct.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.SquareMatrix.log_abs_det" href="#mici.matrices.SquareMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SquareMatrix.shape" href="#mici.matrices.SquareMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.SquareMatrix.array" href="#mici.matrices.SquareMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.SquareMatrix.T" href="#mici.matrices.SquareMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.SquareMatrix.diagonal" href="#mici.matrices.SquareMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.SquareMatrixProduct" href="#mici.matrices.SquareMatrixProduct">SquareMatrixProduct</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.SquareMatrixProduct.log_abs_det" href="#mici.matrices.SquareMatrixProduct.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SquareMatrixProduct.T" href="#mici.matrices.SquareMatrixProduct.T">T</a></code></li>
<li><code><a title="mici.matrices.SquareMatrixProduct.array" href="#mici.matrices.SquareMatrixProduct.array">array</a></code></li>
<li><code><a title="mici.matrices.SquareMatrixProduct.shape" href="#mici.matrices.SquareMatrixProduct.shape">shape</a></code></li>
<li><code><a title="mici.matrices.SquareMatrixProduct.diagonal" href="#mici.matrices.SquareMatrixProduct.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.InvertibleMatrix.inv" href="#mici.matrices.InvertibleMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrix.log_abs_det" href="#mici.matrices.InvertibleMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrix.shape" href="#mici.matrices.InvertibleMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrix.array" href="#mici.matrices.InvertibleMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrix.T" href="#mici.matrices.InvertibleMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrix.diagonal" href="#mici.matrices.InvertibleMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.InvertibleMatrixProduct" href="#mici.matrices.InvertibleMatrixProduct">InvertibleMatrixProduct</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.InvertibleMatrixProduct.inv" href="#mici.matrices.InvertibleMatrixProduct.inv">inv</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrixProduct.log_abs_det" href="#mici.matrices.InvertibleMatrixProduct.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrixProduct.T" href="#mici.matrices.InvertibleMatrixProduct.T">T</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrixProduct.array" href="#mici.matrices.InvertibleMatrixProduct.array">array</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrixProduct.shape" href="#mici.matrices.InvertibleMatrixProduct.shape">shape</a></code></li>
<li><code><a title="mici.matrices.InvertibleMatrixProduct.diagonal" href="#mici.matrices.InvertibleMatrixProduct.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.SymmetricMatrix.eigval" href="#mici.matrices.SymmetricMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.SymmetricMatrix.eigvec" href="#mici.matrices.SymmetricMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.SymmetricMatrix.T" href="#mici.matrices.SymmetricMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.SymmetricMatrix.log_abs_det" href="#mici.matrices.SymmetricMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SymmetricMatrix.shape" href="#mici.matrices.SymmetricMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.SymmetricMatrix.array" href="#mici.matrices.SymmetricMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.SymmetricMatrix.diagonal" href="#mici.matrices.SymmetricMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.sqrt" href="#mici.matrices.PositiveDefiniteMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.eigval" href="#mici.matrices.PositiveDefiniteMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.eigvec" href="#mici.matrices.PositiveDefiniteMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.T" href="#mici.matrices.PositiveDefiniteMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.log_abs_det" href="#mici.matrices.PositiveDefiniteMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.shape" href="#mici.matrices.PositiveDefiniteMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.array" href="#mici.matrices.PositiveDefiniteMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.diagonal" href="#mici.matrices.PositiveDefiniteMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteMatrix.inv" href="#mici.matrices.PositiveDefiniteMatrix.inv">inv</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.IdentityMatrix" href="#mici.matrices.IdentityMatrix">IdentityMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.IdentityMatrix.eigval" href="#mici.matrices.IdentityMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.IdentityMatrix.sqrt" href="#mici.matrices.IdentityMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.IdentityMatrix.eigvec" href="#mici.matrices.IdentityMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.IdentityMatrix.inv" href="#mici.matrices.IdentityMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.IdentityMatrix.diagonal" href="#mici.matrices.IdentityMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.IdentityMatrix.log_abs_det" href="#mici.matrices.IdentityMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.IdentityMatrix.T" href="#mici.matrices.IdentityMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.IdentityMatrix.shape" href="#mici.matrices.IdentityMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.IdentityMatrix.array" href="#mici.matrices.IdentityMatrix.array">array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.DifferentiableMatrix.grad_quadratic_form_inv" href="#mici.matrices.DifferentiableMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.DifferentiableMatrix.grad_log_abs_det" href="#mici.matrices.DifferentiableMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DifferentiableMatrix.inv" href="#mici.matrices.DifferentiableMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.DifferentiableMatrix.log_abs_det" href="#mici.matrices.DifferentiableMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DifferentiableMatrix.shape" href="#mici.matrices.DifferentiableMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.DifferentiableMatrix.array" href="#mici.matrices.DifferentiableMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.DifferentiableMatrix.T" href="#mici.matrices.DifferentiableMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.DifferentiableMatrix.diagonal" href="#mici.matrices.DifferentiableMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.ScaledIdentityMatrix" href="#mici.matrices.ScaledIdentityMatrix">ScaledIdentityMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.ScaledIdentityMatrix.grad_quadratic_form_inv" href="#mici.matrices.ScaledIdentityMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.scalar" href="#mici.matrices.ScaledIdentityMatrix.scalar">scalar</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.eigval" href="#mici.matrices.ScaledIdentityMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.eigvec" href="#mici.matrices.ScaledIdentityMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.inv" href="#mici.matrices.ScaledIdentityMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.diagonal" href="#mici.matrices.ScaledIdentityMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.log_abs_det" href="#mici.matrices.ScaledIdentityMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.grad_log_abs_det" href="#mici.matrices.ScaledIdentityMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.T" href="#mici.matrices.ScaledIdentityMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.shape" href="#mici.matrices.ScaledIdentityMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.ScaledIdentityMatrix.array" href="#mici.matrices.ScaledIdentityMatrix.array">array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.PositiveScaledIdentityMatrix" href="#mici.matrices.PositiveScaledIdentityMatrix">PositiveScaledIdentityMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.grad_quadratic_form_inv" href="#mici.matrices.PositiveScaledIdentityMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.inv" href="#mici.matrices.PositiveScaledIdentityMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.sqrt" href="#mici.matrices.PositiveScaledIdentityMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.scalar" href="#mici.matrices.PositiveScaledIdentityMatrix.scalar">scalar</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.eigval" href="#mici.matrices.PositiveScaledIdentityMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.eigvec" href="#mici.matrices.PositiveScaledIdentityMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.diagonal" href="#mici.matrices.PositiveScaledIdentityMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.log_abs_det" href="#mici.matrices.PositiveScaledIdentityMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.grad_log_abs_det" href="#mici.matrices.PositiveScaledIdentityMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.T" href="#mici.matrices.PositiveScaledIdentityMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.shape" href="#mici.matrices.PositiveScaledIdentityMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.PositiveScaledIdentityMatrix.array" href="#mici.matrices.PositiveScaledIdentityMatrix.array">array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.DiagonalMatrix" href="#mici.matrices.DiagonalMatrix">DiagonalMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.DiagonalMatrix.grad_quadratic_form_inv" href="#mici.matrices.DiagonalMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.diagonal" href="#mici.matrices.DiagonalMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.eigvec" href="#mici.matrices.DiagonalMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.eigval" href="#mici.matrices.DiagonalMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.inv" href="#mici.matrices.DiagonalMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.grad_log_abs_det" href="#mici.matrices.DiagonalMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.T" href="#mici.matrices.DiagonalMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.log_abs_det" href="#mici.matrices.DiagonalMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.shape" href="#mici.matrices.DiagonalMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.DiagonalMatrix.array" href="#mici.matrices.DiagonalMatrix.array">array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.PositiveDiagonalMatrix" href="#mici.matrices.PositiveDiagonalMatrix">PositiveDiagonalMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.grad_quadratic_form_inv" href="#mici.matrices.PositiveDiagonalMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.inv" href="#mici.matrices.PositiveDiagonalMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.sqrt" href="#mici.matrices.PositiveDiagonalMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.diagonal" href="#mici.matrices.PositiveDiagonalMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.eigvec" href="#mici.matrices.PositiveDiagonalMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.eigval" href="#mici.matrices.PositiveDiagonalMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.grad_log_abs_det" href="#mici.matrices.PositiveDiagonalMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.T" href="#mici.matrices.PositiveDiagonalMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.log_abs_det" href="#mici.matrices.PositiveDiagonalMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.shape" href="#mici.matrices.PositiveDiagonalMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.PositiveDiagonalMatrix.array" href="#mici.matrices.PositiveDiagonalMatrix.array">array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix">TriangularMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.TriangularMatrix.lower" href="#mici.matrices.TriangularMatrix.lower">lower</a></code></li>
<li><code><a title="mici.matrices.TriangularMatrix.inv" href="#mici.matrices.TriangularMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.TriangularMatrix.T" href="#mici.matrices.TriangularMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.TriangularMatrix.log_abs_det" href="#mici.matrices.TriangularMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.TriangularMatrix.shape" href="#mici.matrices.TriangularMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.TriangularMatrix.array" href="#mici.matrices.TriangularMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.TriangularMatrix.diagonal" href="#mici.matrices.TriangularMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix">InverseTriangularMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.InverseTriangularMatrix.lower" href="#mici.matrices.InverseTriangularMatrix.lower">lower</a></code></li>
<li><code><a title="mici.matrices.InverseTriangularMatrix.inv" href="#mici.matrices.InverseTriangularMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.InverseTriangularMatrix.T" href="#mici.matrices.InverseTriangularMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.InverseTriangularMatrix.diagonal" href="#mici.matrices.InverseTriangularMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.InverseTriangularMatrix.log_abs_det" href="#mici.matrices.InverseTriangularMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.InverseTriangularMatrix.shape" href="#mici.matrices.InverseTriangularMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.InverseTriangularMatrix.array" href="#mici.matrices.InverseTriangularMatrix.array">array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix" href="#mici.matrices.TriangularFactoredDefiniteMatrix">TriangularFactoredDefiniteMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.grad_quadratic_form_inv" href="#mici.matrices.TriangularFactoredDefiniteMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.grad_log_abs_det" href="#mici.matrices.TriangularFactoredDefiniteMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.eigval" href="#mici.matrices.TriangularFactoredDefiniteMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.eigvec" href="#mici.matrices.TriangularFactoredDefiniteMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.T" href="#mici.matrices.TriangularFactoredDefiniteMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.log_abs_det" href="#mici.matrices.TriangularFactoredDefiniteMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.shape" href="#mici.matrices.TriangularFactoredDefiniteMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.array" href="#mici.matrices.TriangularFactoredDefiniteMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.diagonal" href="#mici.matrices.TriangularFactoredDefiniteMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredDefiniteMatrix.inv" href="#mici.matrices.TriangularFactoredDefiniteMatrix.inv">inv</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix">TriangularFactoredPositiveDefiniteMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.grad_quadratic_form_inv" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.inv" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.sqrt" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.grad_log_abs_det" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.eigval" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.eigvec" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.T" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.log_abs_det" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.shape" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.array" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.diagonal" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.DenseDefiniteMatrix" href="#mici.matrices.DenseDefiniteMatrix">DenseDefiniteMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.DenseDefiniteMatrix.grad_quadratic_form_inv" href="#mici.matrices.DenseDefiniteMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.factor" href="#mici.matrices.DenseDefiniteMatrix.factor">factor</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.grad_log_abs_det" href="#mici.matrices.DenseDefiniteMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.eigval" href="#mici.matrices.DenseDefiniteMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.eigvec" href="#mici.matrices.DenseDefiniteMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.T" href="#mici.matrices.DenseDefiniteMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.log_abs_det" href="#mici.matrices.DenseDefiniteMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.shape" href="#mici.matrices.DenseDefiniteMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.array" href="#mici.matrices.DenseDefiniteMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.diagonal" href="#mici.matrices.DenseDefiniteMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.DenseDefiniteMatrix.inv" href="#mici.matrices.DenseDefiniteMatrix.inv">inv</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.DensePositiveDefiniteMatrix" href="#mici.matrices.DensePositiveDefiniteMatrix">DensePositiveDefiniteMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.grad_quadratic_form_inv" href="#mici.matrices.DensePositiveDefiniteMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.inv" href="#mici.matrices.DensePositiveDefiniteMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.sqrt" href="#mici.matrices.DensePositiveDefiniteMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.factor" href="#mici.matrices.DensePositiveDefiniteMatrix.factor">factor</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.grad_log_abs_det" href="#mici.matrices.DensePositiveDefiniteMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.eigval" href="#mici.matrices.DensePositiveDefiniteMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.eigvec" href="#mici.matrices.DensePositiveDefiniteMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.T" href="#mici.matrices.DensePositiveDefiniteMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.log_abs_det" href="#mici.matrices.DensePositiveDefiniteMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.shape" href="#mici.matrices.DensePositiveDefiniteMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.array" href="#mici.matrices.DensePositiveDefiniteMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteMatrix.diagonal" href="#mici.matrices.DensePositiveDefiniteMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix" href="#mici.matrices.DensePositiveDefiniteProductMatrix">DensePositiveDefiniteProductMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.grad_quadratic_form_inv" href="#mici.matrices.DensePositiveDefiniteProductMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.grad_log_abs_det" href="#mici.matrices.DensePositiveDefiniteProductMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.inv" href="#mici.matrices.DensePositiveDefiniteProductMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.sqrt" href="#mici.matrices.DensePositiveDefiniteProductMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.factor" href="#mici.matrices.DensePositiveDefiniteProductMatrix.factor">factor</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.eigval" href="#mici.matrices.DensePositiveDefiniteProductMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.eigvec" href="#mici.matrices.DensePositiveDefiniteProductMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.T" href="#mici.matrices.DensePositiveDefiniteProductMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.log_abs_det" href="#mici.matrices.DensePositiveDefiniteProductMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.shape" href="#mici.matrices.DensePositiveDefiniteProductMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.array" href="#mici.matrices.DensePositiveDefiniteProductMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.DensePositiveDefiniteProductMatrix.diagonal" href="#mici.matrices.DensePositiveDefiniteProductMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.DenseSquareMatrix" href="#mici.matrices.DenseSquareMatrix">DenseSquareMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.DenseSquareMatrix.lu_and_piv" href="#mici.matrices.DenseSquareMatrix.lu_and_piv">lu_and_piv</a></code></li>
<li><code><a title="mici.matrices.DenseSquareMatrix.log_abs_det" href="#mici.matrices.DenseSquareMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DenseSquareMatrix.T" href="#mici.matrices.DenseSquareMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.DenseSquareMatrix.inv" href="#mici.matrices.DenseSquareMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.DenseSquareMatrix.shape" href="#mici.matrices.DenseSquareMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.DenseSquareMatrix.array" href="#mici.matrices.DenseSquareMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.DenseSquareMatrix.diagonal" href="#mici.matrices.DenseSquareMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.InverseLUFactoredSquareMatrix" href="#mici.matrices.InverseLUFactoredSquareMatrix">InverseLUFactoredSquareMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.InverseLUFactoredSquareMatrix.log_abs_det" href="#mici.matrices.InverseLUFactoredSquareMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.InverseLUFactoredSquareMatrix.inv" href="#mici.matrices.InverseLUFactoredSquareMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.InverseLUFactoredSquareMatrix.T" href="#mici.matrices.InverseLUFactoredSquareMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.InverseLUFactoredSquareMatrix.shape" href="#mici.matrices.InverseLUFactoredSquareMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.InverseLUFactoredSquareMatrix.array" href="#mici.matrices.InverseLUFactoredSquareMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.InverseLUFactoredSquareMatrix.diagonal" href="#mici.matrices.InverseLUFactoredSquareMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.DenseSymmetricMatrix" href="#mici.matrices.DenseSymmetricMatrix">DenseSymmetricMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.DenseSymmetricMatrix.inv" href="#mici.matrices.DenseSymmetricMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.DenseSymmetricMatrix.eigval" href="#mici.matrices.DenseSymmetricMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.DenseSymmetricMatrix.eigvec" href="#mici.matrices.DenseSymmetricMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.DenseSymmetricMatrix.T" href="#mici.matrices.DenseSymmetricMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.DenseSymmetricMatrix.log_abs_det" href="#mici.matrices.DenseSymmetricMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.DenseSymmetricMatrix.shape" href="#mici.matrices.DenseSymmetricMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.DenseSymmetricMatrix.array" href="#mici.matrices.DenseSymmetricMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.DenseSymmetricMatrix.diagonal" href="#mici.matrices.DenseSymmetricMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix">OrthogonalMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.OrthogonalMatrix.log_abs_det" href="#mici.matrices.OrthogonalMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.OrthogonalMatrix.T" href="#mici.matrices.OrthogonalMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.OrthogonalMatrix.inv" href="#mici.matrices.OrthogonalMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.OrthogonalMatrix.shape" href="#mici.matrices.OrthogonalMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.OrthogonalMatrix.array" href="#mici.matrices.OrthogonalMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.OrthogonalMatrix.diagonal" href="#mici.matrices.OrthogonalMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.ScaledOrthogonalMatrix" href="#mici.matrices.ScaledOrthogonalMatrix">ScaledOrthogonalMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.ScaledOrthogonalMatrix.diagonal" href="#mici.matrices.ScaledOrthogonalMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.ScaledOrthogonalMatrix.log_abs_det" href="#mici.matrices.ScaledOrthogonalMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.ScaledOrthogonalMatrix.T" href="#mici.matrices.ScaledOrthogonalMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.ScaledOrthogonalMatrix.inv" href="#mici.matrices.ScaledOrthogonalMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.ScaledOrthogonalMatrix.shape" href="#mici.matrices.ScaledOrthogonalMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.ScaledOrthogonalMatrix.array" href="#mici.matrices.ScaledOrthogonalMatrix.array">array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.EigendecomposedSymmetricMatrix" href="#mici.matrices.EigendecomposedSymmetricMatrix">EigendecomposedSymmetricMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.EigendecomposedSymmetricMatrix.inv" href="#mici.matrices.EigendecomposedSymmetricMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedSymmetricMatrix.eigval" href="#mici.matrices.EigendecomposedSymmetricMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedSymmetricMatrix.eigvec" href="#mici.matrices.EigendecomposedSymmetricMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedSymmetricMatrix.T" href="#mici.matrices.EigendecomposedSymmetricMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedSymmetricMatrix.log_abs_det" href="#mici.matrices.EigendecomposedSymmetricMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedSymmetricMatrix.shape" href="#mici.matrices.EigendecomposedSymmetricMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedSymmetricMatrix.array" href="#mici.matrices.EigendecomposedSymmetricMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedSymmetricMatrix.diagonal" href="#mici.matrices.EigendecomposedSymmetricMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix">EigendecomposedPositiveDefiniteMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.inv" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.sqrt" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.eigval" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.eigvec" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.T" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.log_abs_det" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.shape" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.array" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix.diagonal" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix">SoftAbsRegularisedPositiveDefiniteMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.softabs" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.softabs">softabs</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_softabs" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_softabs">grad_softabs</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_quadratic_form_inv" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_log_abs_det" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.inv" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.sqrt" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.eigval" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.eigvec" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.T" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.log_abs_det" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.shape" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.array" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.diagonal" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.BlockMatrix" href="#mici.matrices.BlockMatrix">BlockMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.BlockMatrix.blocks" href="#mici.matrices.BlockMatrix.blocks">blocks</a></code></li>
<li><code><a title="mici.matrices.BlockMatrix.array" href="#mici.matrices.BlockMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.BlockMatrix.shape" href="#mici.matrices.BlockMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.BlockMatrix.T" href="#mici.matrices.BlockMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.BlockMatrix.diagonal" href="#mici.matrices.BlockMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.SquareBlockDiagonalMatrix" href="#mici.matrices.SquareBlockDiagonalMatrix">SquareBlockDiagonalMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.blocks" href="#mici.matrices.SquareBlockDiagonalMatrix.blocks">blocks</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.T" href="#mici.matrices.SquareBlockDiagonalMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.sqrt" href="#mici.matrices.SquareBlockDiagonalMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.diag" href="#mici.matrices.SquareBlockDiagonalMatrix.diag">diag</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.inv" href="#mici.matrices.SquareBlockDiagonalMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.eigval" href="#mici.matrices.SquareBlockDiagonalMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.eigvec" href="#mici.matrices.SquareBlockDiagonalMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.log_abs_det" href="#mici.matrices.SquareBlockDiagonalMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.shape" href="#mici.matrices.SquareBlockDiagonalMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.array" href="#mici.matrices.SquareBlockDiagonalMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.SquareBlockDiagonalMatrix.diagonal" href="#mici.matrices.SquareBlockDiagonalMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.SymmetricBlockDiagonalMatrix" href="#mici.matrices.SymmetricBlockDiagonalMatrix">SymmetricBlockDiagonalMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.SymmetricBlockDiagonalMatrix.T" href="#mici.matrices.SymmetricBlockDiagonalMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.SymmetricBlockDiagonalMatrix.blocks" href="#mici.matrices.SymmetricBlockDiagonalMatrix.blocks">blocks</a></code></li>
<li><code><a title="mici.matrices.SymmetricBlockDiagonalMatrix.inv" href="#mici.matrices.SymmetricBlockDiagonalMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.SymmetricBlockDiagonalMatrix.log_abs_det" href="#mici.matrices.SymmetricBlockDiagonalMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SymmetricBlockDiagonalMatrix.shape" href="#mici.matrices.SymmetricBlockDiagonalMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.SymmetricBlockDiagonalMatrix.array" href="#mici.matrices.SymmetricBlockDiagonalMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.SymmetricBlockDiagonalMatrix.diagonal" href="#mici.matrices.SymmetricBlockDiagonalMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix">PositiveDefiniteBlockDiagonalMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.grad_quadratic_form_inv" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.sqrt" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.grad_log_abs_det" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.T" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.blocks" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.blocks">blocks</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.inv" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.log_abs_det" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.shape" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.array" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.diagonal" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.eigval" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.eigvec" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix.eigvec">eigvec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.DenseRectangularMatrix" href="#mici.matrices.DenseRectangularMatrix">DenseRectangularMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.DenseRectangularMatrix.T" href="#mici.matrices.DenseRectangularMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.DenseRectangularMatrix.array" href="#mici.matrices.DenseRectangularMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.DenseRectangularMatrix.shape" href="#mici.matrices.DenseRectangularMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.DenseRectangularMatrix.diagonal" href="#mici.matrices.DenseRectangularMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.BlockRowMatrix" href="#mici.matrices.BlockRowMatrix">BlockRowMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.BlockRowMatrix.blocks" href="#mici.matrices.BlockRowMatrix.blocks">blocks</a></code></li>
<li><code><a title="mici.matrices.BlockRowMatrix.T" href="#mici.matrices.BlockRowMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.BlockRowMatrix.array" href="#mici.matrices.BlockRowMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.BlockRowMatrix.shape" href="#mici.matrices.BlockRowMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.BlockRowMatrix.diagonal" href="#mici.matrices.BlockRowMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.BlockColumnMatrix" href="#mici.matrices.BlockColumnMatrix">BlockColumnMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.BlockColumnMatrix.blocks" href="#mici.matrices.BlockColumnMatrix.blocks">blocks</a></code></li>
<li><code><a title="mici.matrices.BlockColumnMatrix.T" href="#mici.matrices.BlockColumnMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.BlockColumnMatrix.array" href="#mici.matrices.BlockColumnMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.BlockColumnMatrix.shape" href="#mici.matrices.BlockColumnMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.BlockColumnMatrix.diagonal" href="#mici.matrices.BlockColumnMatrix.diagonal">diagonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.SquareLowRankUpdateMatrix" href="#mici.matrices.SquareLowRankUpdateMatrix">SquareLowRankUpdateMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.SquareLowRankUpdateMatrix.capacitance_matrix" href="#mici.matrices.SquareLowRankUpdateMatrix.capacitance_matrix">capacitance_matrix</a></code></li>
<li><code><a title="mici.matrices.SquareLowRankUpdateMatrix.diagonal" href="#mici.matrices.SquareLowRankUpdateMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.SquareLowRankUpdateMatrix.T" href="#mici.matrices.SquareLowRankUpdateMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.SquareLowRankUpdateMatrix.inv" href="#mici.matrices.SquareLowRankUpdateMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.SquareLowRankUpdateMatrix.log_abs_det" href="#mici.matrices.SquareLowRankUpdateMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SquareLowRankUpdateMatrix.shape" href="#mici.matrices.SquareLowRankUpdateMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.SquareLowRankUpdateMatrix.array" href="#mici.matrices.SquareLowRankUpdateMatrix.array">array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix" href="#mici.matrices.SymmetricLowRankUpdateMatrix">SymmetricLowRankUpdateMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.capacitance_matrix" href="#mici.matrices.SymmetricLowRankUpdateMatrix.capacitance_matrix">capacitance_matrix</a></code></li>
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.inv" href="#mici.matrices.SymmetricLowRankUpdateMatrix.inv">inv</a></code></li>
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.T" href="#mici.matrices.SymmetricLowRankUpdateMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.diagonal" href="#mici.matrices.SymmetricLowRankUpdateMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.log_abs_det" href="#mici.matrices.SymmetricLowRankUpdateMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.shape" href="#mici.matrices.SymmetricLowRankUpdateMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.array" href="#mici.matrices.SymmetricLowRankUpdateMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.eigval" href="#mici.matrices.SymmetricLowRankUpdateMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.SymmetricLowRankUpdateMatrix.eigvec" href="#mici.matrices.SymmetricLowRankUpdateMatrix.eigvec">eigvec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix">PositiveDefiniteLowRankUpdateMatrix</a></code></h4>
<ul class="">
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.grad_quadratic_form_inv" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.grad_quadratic_form_inv">grad_quadratic_form_inv</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.capacitance_matrix" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.capacitance_matrix">capacitance_matrix</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.sqrt" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.sqrt">sqrt</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.grad_log_abs_det" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.grad_log_abs_det">grad_log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.eigval" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.eigval">eigval</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.eigvec" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.eigvec">eigvec</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.T" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.T">T</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.log_abs_det" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.log_abs_det">log_abs_det</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.shape" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.shape">shape</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.array" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.array">array</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.diagonal" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.inv" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix.inv">inv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Package <code>mici.matrices</code></h1>
</header>
<section id="section-intro">
<p>Structured matrix classes implementing basic linear algebra operations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L0-L2194" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Structured matrix classes implementing basic linear algebra operations.&#34;&#34;&#34;

import numpy as np
from mici.errors import LinAlgError
import numpy.linalg as nla
import scipy.linalg as sla
import abc
from mici.utils import hash_array


def _choose_matrix_product_class(matrix_l, matrix_r):
    if (matrix_l.shape[0] == matrix_l.shape[1] and
            matrix_r.shape == matrix_l.shape):
        if (isinstance(matrix_l, InvertibleMatrix) and
                isinstance(matrix_r, InvertibleMatrix)):
            return InvertibleMatrixProduct
        else:
            return SquareMatrixProduct
    else:
        return MatrixProduct


class Matrix(abc.ABC):
    &#34;&#34;&#34;Base class for matrix-like objects.

    Implements overloads of the matrix multiplication operator `@`, as well as
    the standard multiplication and division operators `*` and `/` when the
    second argument is a scalar quantity.
    &#34;&#34;&#34;

    __array_priority__ = 1

    &#34;&#34;&#34;Set of attributes required for class to be considered a subclass&#34;&#34;&#34;
    _required_subclass_attrs = {
        &#39;array&#39;, &#39;shape&#39;, &#39;T&#39;, &#39;diagonal&#39;, &#39;__array__&#39;, &#39;__mul__&#39;, &#39;__rmul__&#39;,
        &#39;__truediv__&#39;, &#39;__neg__&#39;, &#39;__matmul__&#39;, &#39;__rmatmul__&#39;
    }

    def __init__(self, shape, **kwargs):
        &#34;&#34;&#34;
        Args:
           shape (Tuple[int, int]): Shape of matrix `(num_rows, num_columns)`.
        &#34;&#34;&#34;
        self._shape = shape
        self._hash = None
        for k, v in kwargs.items():
            if isinstance(v, np.ndarray):
                v.flags.writeable = False
            self.__dict__[k] = v

    def __array__(self):
        return self.array

    def __mul__(self, other):
        if np.isscalar(other) or np.ndim(other) == 0:
            if other == 0:
                raise NotImplementedError(
                    &#39;Scalar multiplication by zero not implemented.&#39;)
            return self._scalar_multiply(other)
        else:
            return NotImplemented

    def __rmul__(self, other):
        return self.__mul__(other)

    def __truediv__(self, other):
        if np.isscalar(other) or np.ndim(other) == 0:
            if other == 0:
                raise NotImplementedError(
                    &#39;Scalar division by zero not implemented.&#39;)
            return self._scalar_multiply(1 / other)
        else:
            return NotImplemented

    def __neg__(self):
        return self._scalar_multiply(-1)

    def __matmul__(self, other):
        if self.shape[1] is not None and other.shape[0] != self.shape[1]:
            raise ValueError(
                f&#39;Inconsistent dimensions for matrix multiplication: &#39;
                f&#39;{self.shape} and {other.shape}.&#39;)
        if isinstance(other, Matrix):
            matrix_product_class = _choose_matrix_product_class(self, other)
            return matrix_product_class((self, other), check_shapes=False)
        else:
            return self._left_matrix_multiply(other)

    def __rmatmul__(self, other):
        if self.shape[0] is not None and other.shape[-1] != self.shape[0]:
            raise ValueError(
                f&#39;Inconsistent dimensions for matrix multiplication: &#39;
                f&#39;{other.shape} and {self.shape}.&#39;)
        if isinstance(other, Matrix):
            matrix_product_class = _choose_matrix_product_class(self, other)
            return matrix_product_class((other, self), check_shapes=False)
        else:
            return self._right_matrix_multiply(other)

    @property
    def shape(self):
        &#34;&#34;&#34;Shape of matrix as a tuple `(num_rows, num_columns)`.&#34;&#34;&#34;
        return self._shape

    @property
    @abc.abstractmethod
    def array(self):
        &#34;&#34;&#34;Full dense representation of matrix as a 2D array.&#34;&#34;&#34;

    @abc.abstractmethod
    def _left_matrix_multiply(self, other):
        &#34;&#34;&#34;Left multiply argument by the represented matrix.

        Args:
            other (array): Argument to left-multiply.

        Returns:
            result (array): Result of left-multiplying `other` by the
                represented matrix.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def _right_matrix_multiply(self, other):
        &#34;&#34;&#34;Right multiply argument by the represented matrix.

        Args:
            other (array): Argument to right-multiply.

        Returns:
            result (array): Result of right-multiplying `other` by the
                represented matrix.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def _scalar_multiply(self, scalar):
        &#34;&#34;&#34;Calculate result of multiplying represented matrix by a scalar.

        Args:
            scalar (float): Scalar argument to multiply by.

        Returns:
            result (Matrix): Result of multiplying represented matrix by
                `scalar` as another `Matrix` object.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def T(self):
        &#34;&#34;&#34;Transpose of matrix.&#34;&#34;&#34;

    @property
    def diagonal(self):
        &#34;&#34;&#34;Diagonal of matrix as a 1D array.&#34;&#34;&#34;
        return self.array.diagonal()

    def __str__(self):
        return f&#39;(shape={self.shape})&#39;

    def __repr__(self):
        return type(self).__name__ + str(self)

    @classmethod
    def _get_required_subclass_attrs(cls):
        &#34;&#34;&#34;Compute set of required subclass attributes.&#34;&#34;&#34;
        req = set()
        for C in cls.__mro__:
            if hasattr(C, &#39;_required_subclass_attrs&#39;):
                req |= C._required_subclass_attrs
        return req

    @classmethod
    def __subclasshook__(cls, C):
        # Customise isinstance / issubclass behaviour to also return True for
        # classes / objects with classes which have all required attributes
        # without being direct subclasses
        if hasattr(cls, &#39;_get_required_subclass_attrs&#39;):
            if all(any(attr in B.__dict__ for B in C.__mro__)
                   for attr in cls._get_required_subclass_attrs()):
                return True
        return NotImplemented

    @abc.abstractmethod
    def _compute_hash(self):
        &#34;&#34;&#34;Compute hash value for matrix object.&#34;&#34;&#34;

    def __hash__(self):
        if self._hash is None:
            self._hash = self._compute_hash()
        return self._hash

    @abc.abstractmethod
    def _check_equality(self, other):
        &#34;&#34;&#34;Check for equality with another instance of the same class.&#34;&#34;&#34;

    def __eq__(self, other):
        return other is self or (
            other.__class__ == self.__class__ and self._check_equality(other))


class ExplicitArrayMatrix(Matrix):
    &#34;&#34;&#34;Matrix with an explicit array representation.&#34;&#34;&#34;

    def __init__(self, shape, **kwargs):
        if &#39;_array&#39; not in kwargs:
            raise ValueError(&#39;_array must be specified in kwargs&#39;)
        super().__init__(shape, **kwargs)

    @property
    def array(self):
        return self._array

    def _left_matrix_multiply(self, other):
        return self._array @ other

    def _right_matrix_multiply(self, other):
        return other @ self._array

    def _compute_hash(self):
        return hash_array(self._array)

    def _check_equality(self, other):
        return np.array_equal(self.array, other.array)


class ImplicitArrayMatrix(Matrix):
    &#34;&#34;&#34;Matrix with an implicit array representation.&#34;&#34;&#34;

    def __init__(self, shape, **kwargs):
        &#34;&#34;&#34;
        Args:
           shape (Tuple[int, int]): Shape of matrix `(num_rows, num_columns)`.
        &#34;&#34;&#34;
        super().__init__(shape, **kwargs)
        self._array = None

    @property
    def array(self):
        &#34;&#34;&#34;Full dense representation of matrix as a 2D array.

        Generally accessing this property should be avoided wherever possible
        as the resulting array object may use a lot of memory and operations
        with it will not be able to exploit any structure in the matrix.
        &#34;&#34;&#34;
        if self._array is None:
            self._array = self._construct_array()
        return self._array

    @abc.abstractmethod
    def _construct_array(self):
        &#34;&#34;&#34;Construct full dense representation of matrix as a 2D array.

        Generally calling this method should be avoided wherever possible as
        the returned array object may use a lot of memory and operations with
        it will not be able to exploit any structure in the matrix.
        &#34;&#34;&#34;


class MatrixProduct(ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix implicitly defined as a product of a sequence of matrices.

    Each adjacent pair of matrices in the sequence must have compatible shapes.
    &#34;&#34;&#34;

    def __init__(self, matrices, check_shapes=True):
        &#34;&#34;&#34;
        Args:
            matrices(Iterable[Matrix]): Sequence of matrices forming product in
                left-to-right order.
            check_shapes (boolean): Whether to check if all successive pairs of
                the matrix sequence have compatible shapes, i.e. equal inner
                dimensions.
        &#34;&#34;&#34;
        self._matrices = tuple(matrices)
        if check_shapes:
            for matrix_l, matrix_r in zip(matrices[:-1], matrices[1:]):
                if matrix_l.shape[1] != matrix_r.shape[0]:
                    raise ValueError(
                        f&#39;Matrices {matrix_l} and {matrix_r} have inconsistent&#39;
                        f&#39; inner dimensions for forming a matrix product.&#39;)
        super().__init__((self._matrices[0].shape[0],
                          self._matrices[-1].shape[1]))

    @property
    def matrices(self):
        return self._matrices

    def _scalar_multiply(self, scalar):
        return type(self)((
            ScaledIdentityMatrix(scalar, self.shape[0]), *self.matrices))

    def _left_matrix_multiply(self, other):
        for matrix in reversed(self.matrices):
            other = matrix @ other
        return other

    def _right_matrix_multiply(self, other):
        for matrix in self.matrices:
            other = other @ matrix
        return other

    @property
    def T(self):
        return type(self)(
            tuple(matrix.T for matrix in reversed(self.matrices)))

    def _construct_array(self):
        return self.matrices[0].array @ MatrixProduct(self.matrices[1:])

    def _compute_hash(self):
        return hash(tuple(matrix for matrix in self.matrices))

    def _check_equality(self, other):
        return (
            len(other.matrices) == len(self.matrices) and
            all(matrix_s == matrix_o for matrix_s, matrix_o
                in zip(self.matrices, other.matrices))
        )


class SquareMatrix(Matrix):
    &#34;&#34;&#34;Base class for matrices with equal numbers of rows and columns.&#34;&#34;&#34;

    _required_subclass_attrs = {&#39;log_abs_det&#39;}

    def __init__(self, shape, **kwargs):
        if shape[0] != shape[1]:
            raise ValueError(
                f&#39;{shape} is not a valid shape for a square matrix.&#39;)
        super().__init__(shape, **kwargs)

    @property
    @abc.abstractmethod
    def log_abs_det(self):
        &#34;&#34;&#34;Logarithm of absolute value of determinant of matrix.

        For matrix representations of metrics it is proportional to the
        logarithm of the density of then Riemannian measure associated with
        metric with respect to the Lebesgue measure.
        &#34;&#34;&#34;


class SquareMatrixProduct(MatrixProduct, SquareMatrix):
    &#34;&#34;&#34;Matrix implicitly defined as a product of a sequence of square matrices.

    All the matrices must have the same shape.
    &#34;&#34;&#34;

    def __init__(self, matrices, check_shapes=True):
        matrices = tuple(matrices)
        if check_shapes:
            if matrices[0].shape[0] != matrices[0].shape[1]:
                raise ValueError(f&#39;{matrix} is not square.&#39;)
            for matrix in matrices[1:]:
                if matrix.shape != matrices[0].shape:
                    raise ValueError(
                        f&#39;{matrices[0]} and {matrix} have different shapes.&#39;)
        super().__init__(matrices, check_shapes=False)

    @property
    def log_abs_det(self):
        return sum(matrix.log_abs_det for matrix in self.matrices)


class InvertibleMatrix(SquareMatrix):
    &#34;&#34;&#34;Base class for non-singular square matrices.&#34;&#34;&#34;

    _required_subclass_attrs = {&#39;inv&#39;}

    @property
    @abc.abstractmethod
    def inv(self):
        &#34;&#34;&#34;Inverse of matrix as a `Matrix` object.

        This will not necessarily form an explicit representation of the
        inverse matrix but may instead return a `Matrix` object that implements
        the matrix multiplication operators by solving the linear system
        defined by the original matrix object.
        &#34;&#34;&#34;


class InvertibleMatrixProduct(SquareMatrixProduct, InvertibleMatrix):
    &#34;&#34;&#34;Matrix defined as a product of a sequence of invertible matrices.

    All the matrices must have the same shape.
    &#34;&#34;&#34;

    def __init__(self, matrices, check_shapes=True):
        matrices = tuple(matrices)
        for matrix in matrices:
            if not isinstance(matrix, InvertibleMatrix):
                raise ValueError(f&#39;matrix {matrix} is not invertible.&#39;)
        super().__init__(matrices, check_shapes)

    @property
    def inv(self):
        return InvertibleMatrixProduct(
            tuple(matrix.inv for matrix in reversed(self.matrices)))


class SymmetricMatrix(SquareMatrix):
    &#34;&#34;&#34;Base class for square matrices which are equal to their transpose.&#34;&#34;&#34;

    _required_subclass_attrs = {&#39;eigval&#39;, &#39;eigvec&#39;}

    def __init__(self, shape, **kwargs):
        self._eigval = None
        self._eigvec = None
        super().__init__(shape, **kwargs)

    def _compute_eigendecomposition(self):
        self._eigval, eigvec = nla.eigh(self.array)
        self._eigvec = OrthogonalMatrix(eigvec)

    @property
    def eigval(self):
        &#34;&#34;&#34;Eigenvalues of matrix as a 1D array.&#34;&#34;&#34;
        if self._eigval is None or self._eigvec is None:
            self._compute_eigendecomposition()
        return self._eigval

    @property
    def eigvec(self):
        &#34;&#34;&#34;Eigenvectors of matrix stacked as columns of a `Matrix` object.&#34;&#34;&#34;
        if self._eigval is None or self._eigvec is None:
            self._compute_eigendecomposition()
        return self._eigvec

    @property
    def T(self):
        return self

    @property
    def log_abs_det(self):
        return np.log(np.abs(self.eigval)).sum()


class PositiveDefiniteMatrix(SymmetricMatrix, InvertibleMatrix):
    &#34;&#34;&#34;Base class for positive definite matrices.&#34;&#34;&#34;

    _required_subclass_attrs = {&#39;sqrt&#39;}

    @property
    @abc.abstractmethod
    def sqrt(self):
        &#34;&#34;&#34;Square-root of matrix satisfying `matrix == sqrt @ sqrt.T`.

        This will in general not correspond to the unique, if defined,
        symmetric square root of a symmetric matrix but instead may return any
        matrix satisfying the above property.
        &#34;&#34;&#34;


class IdentityMatrix(PositiveDefiniteMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix representing identity operator on a vector space.

    Array representation has ones on diagonal elements and zeros elsewhere.
    May be defined with an implicit shape represented by `(None, None)` which
    will allow use for subset of operations where shape is not required to be
    known.
    &#34;&#34;&#34;

    def __init__(self, size=None):
        &#34;&#34;&#34;
        Args:
            size (int or None): Number of rows / columns in matrix or `None` if
                matrix is to be implicitly shaped.
        &#34;&#34;&#34;
        super().__init__((size, size))

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveScaledIdentityMatrix(
                scalar, self.shape[0])
        else:
            return ScaledIdentityMatrix(scalar, self.shape[0])

    def _left_matrix_multiply(self, other):
        return other

    def _right_matrix_multiply(self, other):
        return other

    @property
    def eigval(self):
        return self.diagonal

    @property
    def sqrt(self):
        return self

    @property
    def eigvec(self):
        return self

    @property
    def inv(self):
        return self

    @property
    def diagonal(self):
        return np.ones(self.shape[0])

    def _construct_array(self):
        if self.shape[0] is None:
            raise RuntimeError(
                &#39;Cannot get array representation for identity matrix with &#39;
                &#39;implicit size.&#39;)
        return np.identity(self.shape[0])

    @property
    def log_abs_det(self):
        return 0.

    def _compute_hash(self):
        return hash(self.shape)

    def _check_equality(self, other):
        return self.shape == other.shape


class DifferentiableMatrix(InvertibleMatrix):
    &#34;&#34;&#34;Parameterically defined matrix defining gradient of scalar operations.

    Parameterically-defined here means the matrix is constructed as a function
    of one or more parameters, with the convention that the parameters
    correspond to **the first parameter in the `__init__` method of the
    `DifferentiableMatrix` subclass**, with multiple parameters wrapped in to
    for example a tuple, dict or list.

    The gradient is defined for the scalar functions of the matrix parameters
    implemented by the method `log_abs_det`, corresponding to

        f(params) = log(abs(det(matrix(params))))

    and by the quadratic form `vector @ matrix(params).inv @ vector`.

    In both cases the gradients are with respect to the parameter(s). The
    returned gradients will have the same structure as the first parameter of
    the `__init__` method of the relevant `DifferentiableMatrix` subclass,
    for example if the first parameter is a tuple or dict of arrays then the
    returned gradients will be respectively a tuple or dict of arrays of the
    same shapes and with the same indices / keys.
    &#34;&#34;&#34;

    _required_subclass_attrs = {&#39;grad_log_abs_det&#39;, &#39;grad_quadratic_form_inv&#39;}

    @property
    @abc.abstractmethod
    def grad_log_abs_det(self):
        &#34;&#34;&#34;Gradient of logarithm of absolute value of determinant of matrix.&#34;&#34;&#34;

    @abc.abstractmethod
    def grad_quadratic_form_inv(self, vector):
        &#34;&#34;&#34;Gradient of quadratic form `vector @ matrix.inv @ vector`.

        Args:
            vector (array): 1D array representing vector to evaluate quadratic
                form at.
        &#34;&#34;&#34;


class ScaledIdentityMatrix(
        SymmetricMatrix, DifferentiableMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix representing scalar multiplication operation on a vector space.

    Array representation has common scalar on diagonal elements and zeros
    elsewhere. May be defined with an implicit shape reprsented by
    `(None, None)` which will allow use for subset of operations where shape
    is not required to be known.
    &#34;&#34;&#34;

    def __init__(self, scalar, size=None):
        &#34;&#34;&#34;
        Args:
            scalar (float): Scalar multiplier for identity matrix.
            size (int): Number of rows / columns in matrix. If `None` the
                matrix will be implicitly-shaped and only the subset of
                operations which do not rely on an explicit shape will be
                available.
        &#34;&#34;&#34;
        if scalar == 0:
            raise ValueError(&#39;scalar must be non-zero&#39;)
        self._scalar = scalar
        super().__init__((size, size))

    @property
    def scalar(self):
        &#34;&#34;&#34;Scalar multiplier.&#34;&#34;&#34;
        return self._scalar

    def _scalar_multiply(self, scalar):
        return ScaledIdentityMatrix(scalar * self._scalar, self.shape[0])

    def _left_matrix_multiply(self, other):
        return self._scalar * other

    def _right_matrix_multiply(self, other):
        return self._scalar * other

    @property
    def eigval(self):
        return self.diagonal

    @property
    def eigvec(self):
        return IdentityMatrix(self.shape[0])

    @property
    def inv(self):
        return ScaledIdentityMatrix(1 / self._scalar, self.shape[0])

    @property
    def diagonal(self):
        return self._scalar * np.ones(self.shape[0])

    def _construct_array(self):
        if self.shape[0] is None:
            raise RuntimeError(
                &#39;Cannot get array representation for scaled identity matrix &#39;
                &#39;with implicit size.&#39;)
        return self._scalar * np.identity(self.shape[0])

    @property
    def log_abs_det(self):
        if self.shape[0] is None:
            raise RuntimeError(
                &#39;Cannot get log determinant for scaled identity matrix with &#39;
                &#39;implicit size.&#39;)
        return self.shape[0] * np.log(abs(self._scalar))

    @property
    def grad_log_abs_det(self):
        return self.shape[0] / self._scalar

    def grad_quadratic_form_inv(self, vector):
        return -np.sum(vector**2) / self._scalar**2

    def __str__(self):
        return f&#39;(shape={self.shape}, scalar={self._scalar})&#39;

    def _compute_hash(self):
        return hash((self.shape, self.scalar))

    def _check_equality(self, other):
        return self.shape == other.shape and self.scalar == other.scalar


class PositiveScaledIdentityMatrix(
        ScaledIdentityMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Specialisation of `ScaledIdentityMatrix` with positive scalar parameter.

    Restricts the `scalar` parameter to be strictly positive.
    &#34;&#34;&#34;

    def __init__(self, scalar, size=None):
        if scalar &lt;= 0:
            raise ValueError(&#39;Scalar multiplier must be positive.&#39;)
        super().__init__(scalar, size)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveScaledIdentityMatrix(
                scalar * self._scalar, self.shape[0])
        else:
            return super()._scalar_multiply(scalar)

    @property
    def inv(self):
        return PositiveScaledIdentityMatrix(1 / self._scalar, self.shape[0])

    @property
    def sqrt(self):
        return PositiveScaledIdentityMatrix(self._scalar**0.5, self.shape[0])


class DiagonalMatrix(
        SymmetricMatrix, DifferentiableMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix with non-zero elements only along its diagonal.&#34;&#34;&#34;

    def __init__(self, diagonal):
        &#34;&#34;&#34;
        Args:
            diagonal (array): 1D array specifying diagonal elements of matrix.
        &#34;&#34;&#34;
        if diagonal.ndim != 1:
            raise ValueError(&#39;Specified diagonal must be a 1D array.&#39;)
        super().__init__((diagonal.size, diagonal.size), _diagonal=diagonal)

    @property
    def diagonal(self):
        return self._diagonal

    def _scalar_multiply(self, scalar):
        return DiagonalMatrix(self.diagonal * scalar)

    def _left_matrix_multiply(self, other):
        if other.ndim == 2:
            return self.diagonal[:, None] * other
        elif other.ndim == 1:
            return self.diagonal * other
        else:
            raise ValueError(
                &#39;Left matrix multiplication only defined for one or two &#39;
                &#39;dimensional right hand sides.&#39;)

    def _right_matrix_multiply(self, other):
        return self.diagonal * other

    @property
    def eigvec(self):
        return IdentityMatrix(self.shape[0])

    @property
    def eigval(self):
        return self.diagonal

    @property
    def inv(self):
        return DiagonalMatrix(1. / self.diagonal)

    def _construct_array(self):
        return np.diag(self.diagonal)

    @property
    def grad_log_abs_det(self):
        return 1. / self.diagonal

    def grad_quadratic_form_inv(self, vector):
        return -(self.inv @ vector)**2

    def _compute_hash(self):
        return hash_array(self.diagonal)

    def _check_equality(self, other):
        return np.array_equal(self.diagonal, other.diagonal)


class PositiveDiagonalMatrix(DiagonalMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Specialisation of `DiagonalMatrix` with positive diagonal parameter.

    Restricts all values in `diagonal` array parameter to be strictly positive.
    &#34;&#34;&#34;

    def __init__(self, diagonal):
        if not np.all(diagonal &gt; 0):
            raise ValueError(&#39;Diagonal values must all be positive.&#39;)
        super().__init__(diagonal)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveDiagonalMatrix(self.diagonal * scalar)
        else:
            return super()._scalar_multiply(scalar)

    @property
    def inv(self):
        return PositiveDiagonalMatrix(1. / self.diagonal)

    @property
    def sqrt(self):
        return PositiveDiagonalMatrix(self.diagonal**0.5)


def _make_array_triangular(array, lower):
    &#34;&#34;&#34;Make array lower/upper triangular by zeroing above/below diagonal.&#34;&#34;&#34;
    return np.tril(array) if lower else np.triu(array)


class TriangularMatrix(InvertibleMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Matrix with non-zero values only in lower or upper triangle elements.&#34;&#34;&#34;

    def __init__(self, array, lower=True):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array containing lower / upper triangular element
                values of matrix. Any values above (below) diagonal are
                ignored for lower (upper) triangular matrices i.e. when
                `lower == True` (`lower == False`).
            lower (bool): Whether the matrix is lower-triangular (`True`) or
                upper-triangular (`False`).
        &#34;&#34;&#34;
        super().__init__(
            array.shape, _array=_make_array_triangular(array, lower))
        self._lower = lower

    def _scalar_multiply(self, scalar):
        return TriangularMatrix(self.array * scalar, self.lower)

    @property
    def lower(self):
        return self._lower

    @property
    def inv(self):
        return InverseTriangularMatrix(self.array, lower=self.lower)

    @property
    def T(self):
        return TriangularMatrix(self.array.T, lower=not self.lower)

    @property
    def log_abs_det(self):
        return np.log(np.abs(self.diagonal)).sum()

    def __str__(self):
        return f&#39;(shape={self.shape}, lower={self.lower})&#39;


class InverseTriangularMatrix(InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Triangular matrix implicitly specified by its inverse.&#34;&#34;&#34;

    def __init__(self, inverse_array, lower=True):
        &#34;&#34;&#34;
        Args:
            inverse_array (array): 2D containing values of *inverse* of this
                matrix, with the inverse of a lower (upper) triangular matrix
                being itself lower (upper) triangular. Any values above (below)
                diagonal are ignored for lower (upper) triangular matrices i.e.
                when `lower == True` (`lower == False`).
            lower (bool): Whether the matrix is lower-triangular (`True`) or
                upper-triangular (`False`).
        &#34;&#34;&#34;
        super().__init__(
            inverse_array.shape,
            _inverse_array=_make_array_triangular(inverse_array, lower))
        self._lower = lower

    def _scalar_multiply(self, scalar):
        return InverseTriangularMatrix(
            self._inverse_array / scalar, self.lower)

    def _left_matrix_multiply(self, other):
        return sla.solve_triangular(
            self._inverse_array, other, lower=self.lower)

    def _right_matrix_multiply(self, other):
        return sla.solve_triangular(
            self._inverse_array, other.T, lower=self.lower, trans=1).T

    @property
    def lower(self):
        return self._lower

    @property
    def inv(self):
        return TriangularMatrix(self._inverse_array, lower=self.lower)

    @property
    def T(self):
        return InverseTriangularMatrix(
            self._inverse_array.T, lower=not self.lower)

    def _construct_array(self):
        return self @ np.identity(self.shape[0])

    @property
    def diagonal(self):
        return 1. / self._inverse_array.diagonal()

    @property
    def log_abs_det(self):
        return -self.inv.log_abs_det

    def __str__(self):
        return f&#39;(shape={self.shape}, lower={self.lower})&#39;

    def _compute_hash(self):
        return hash_array(self._inverse_array)

    def _check_equality(self, other):
        return np.array_equal(self._inverse_array, other._inverse_array)


class _BaseTriangularFactoredDefiniteMatrix(SymmetricMatrix, InvertibleMatrix):

    def __init__(self, size, sign=1, **kwargs):
        super().__init__((size, size), **kwargs)
        if not (sign == 1 or sign == -1):
            raise ValueError(&#39;sign must be equal to +1 or -1&#39;)
        self._sign = sign

    @property
    def factor(self):
        &#34;&#34;&#34;Triangular matrix with `matrix = sign * factor @ factor.T`&#34;&#34;&#34;
        return self._factor

    @property
    def sign(self):
        &#34;&#34;&#34;Signed binary valueith `matrix = sign * factor @ factor.T`&#34;&#34;&#34;
        return self._sign

    @property
    def inv(self):
        return TriangularFactoredDefiniteMatrix(
            factor=self.factor.inv.T, sign=self._sign)

    @property
    def log_abs_det(self):
        return 2 * self.factor.log_abs_det

    def __str__(self):
        return f&#39;(shape={self.shape}, sign={self._sign})&#39;


class TriangularFactoredDefiniteMatrix(
        _BaseTriangularFactoredDefiniteMatrix, DifferentiableMatrix,
        ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix specified as a signed self-product of a triangular factor.

    The matrix is assumed to have the form

        matrix = sign * factor @ factor.T

    for and upper- or lower-trinagular matrix `factor` and signed binary value
    `sign` (i.e. `sign == +1 or sign == -1`), with the matrix being positive
    definite if `sign == +1` and negative definite if `sign == -1` under the
    assumption that `factor` is non-singular.
    &#34;&#34;&#34;

    def __init__(self, factor, sign=1, factor_is_lower=None):
        &#34;&#34;&#34;
        Args:
            factor (array or TriangularMatrix or InverseTriangularMatrix): The
                triangular factor parameterising the matrix. Defined either a
                2D array, in which case only the lower- or upper-triangular
                elements are used depending on the value of the
                `factor_is_lower` boolean keyword argument, or as a
                `TriangularMatrix` / `InverseTriangularMatrix` instance in
                which case `factor_is_lower` is ignored, with `factor.lower`
                instead determining if the factor is lower- or
                upper-triangular.
            sign (int): +/-1 multiplier of factor product, corresponding
                respectively to a strictly positive- or negative-definite
                matrix.
            factor_is_lower (boolean): Whether the array `factor` is lower-
                or upper-triangular.
        &#34;&#34;&#34;
        if not isinstance(factor, (TriangularMatrix, InverseTriangularMatrix)):
            if factor_is_lower not in (True, False):
                raise ValueError(
                    &#39;For array `factor` parameter `factor_is_lower` must be &#39;
                    &#39;specified as a boolean value.&#39;)
            factor = TriangularMatrix(factor, factor_is_lower)
        self._factor = factor
        super().__init__(factor.shape[0], sign=sign)

    def _scalar_multiply(self, scalar):
        return TriangularFactoredDefiniteMatrix(
            factor=abs(scalar)**0.5 * self.factor,
            sign=self.sign * np.sign(scalar))

    def _left_matrix_multiply(self, other):
        return self.sign * (self.factor @ (self.factor.T @ other))

    def _right_matrix_multiply(self, other):
        return self.sign * ((other @ self.factor) @ self.factor.T)

    @property
    def grad_log_abs_det(self):
        return np.diag(2 / self.factor.diagonal)

    def grad_quadratic_form_inv(self, vector):
        inv_factor_vector = self.factor.inv @ vector
        inv_vector = self.inv @ vector
        return _make_array_triangular(
            -2 * self.sign * np.outer(inv_vector, inv_factor_vector),
            self.factor.lower)

    def _construct_array(self):
        return self.sign * (self.factor @ self.factor.array.T)

    def _compute_hash(self):
        return hash((self.factor, self.sign))

    def _check_equality(self, other):
        return self.sign == other.sign and self.factor == other.factor


class TriangularFactoredPositiveDefiniteMatrix(
        TriangularFactoredDefiniteMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Positive definite matrix parameterised a triangular matrix product.

    The matrix is assumed to have the parameterisation

        matrix = factor @ factor.T

    where `factor` is an upper- or lower-triangular matrix. Note for the case
    `factor` is lower-triangular this corresponds to the standard Cholesky
    factorisation of a positive definite matrix.
    &#34;&#34;&#34;

    def __init__(self, factor, factor_is_lower=True):
        &#34;&#34;&#34;
        Args:
            factor (array or TriangularMatrix or InverseTriangularMatrix): The
                triangular factor parameterising the matrix. Defined either a
                2D array, in which case only the lower- or upper-triangular
                elements are used depending on the value of the
                `factor_is_lower` boolean keyword argument, or as a
                `TriangularMatrix` / `InverseTriangularMatrix` instance in
                which case `factor_is_lower` is ignored, with `factor.lower`
                instead determining if the factor is lower- or
                upper-triangular.
            factor_is_lower (boolean): Whether the array `factor` is lower-
                or upper-triangular.
        &#34;&#34;&#34;
        super().__init__(factor, sign=1, factor_is_lower=factor_is_lower)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return TriangularFactoredPositiveDefiniteMatrix(
                factor=scalar**0.5 * self.factor)
        else:
            return super()._scalar_multiply(scalar)

    @property
    def inv(self):
        return TriangularFactoredPositiveDefiniteMatrix(
            factor=self.factor.inv.T)

    @property
    def sqrt(self):
        return self.factor


class DenseDefiniteMatrix(_BaseTriangularFactoredDefiniteMatrix,
                          DifferentiableMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Definite matrix specified by a dense 2D array.&#34;&#34;&#34;

    def __init__(self, array, factor=None, is_posdef=True):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array specifying matrix entries.
            factor (None or TriangularMatrix or InverseTriangularMatrix):
                Optional argument giving the triangular factorisation of the
                matrix such that `matrix = factor @ factor.T` if
                `is_posdef=True` or `matrix = -factor @ factor.T` otherwise.
                If not pre-computed and specified at initialisation a
                factorisation will only be computed when first required by
                an operation which depends on the factor.
            is_posdef (boolean): Whether matrix (and so corresponding array
                representation) is positive definite, with the matrix assumed
                to be negative-definite if not. This is **not** checked on
                initialisation, and so if `array` is positive (negative)
                definite and `is_posdef` is `False` (`True`) then a
                `LinAlgError` exception will be if a later attempt is made to
                factorise the matrix.
        &#34;&#34;&#34;
        super().__init__(
            array.shape[0], sign=1 if is_posdef else -1, _array=array)
        self._factor = factor

    def _scalar_multiply(self, scalar):
        if (scalar &gt; 0) == (self._sign == 1):
            return DensePositiveDefiniteMatrix(
                scalar * self.array,
                None if self._factor is None else
                abs(scalar)**0.5 * self._factor)
        else:
            return DenseDefiniteMatrix(
                scalar * self.array,
                None if self._factor is None else
                abs(scalar)**0.5 * self._factor, is_posdef=False)

    @property
    def factor(self):
        if self._factor is None:
            try:
                self._factor = TriangularMatrix(
                    nla.cholesky(self._sign * self._array), lower=True)
            except nla.LinAlgError as e:
                raise LinAlgError(&#39;Cholesky factorisation failed.&#39;) from e
        return self._factor

    @property
    def grad_log_abs_det(self):
        return self.inv.array

    def grad_quadratic_form_inv(self, vector):
        inv_matrix_vector = self.inv @ vector
        return -np.outer(inv_matrix_vector, inv_matrix_vector)


class DensePositiveDefiniteMatrix(DenseDefiniteMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Positive-definite matrix specified by a dense 2D array.&#34;&#34;&#34;

    def __init__(self, array, factor=None):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array specifying matrix entries.
            factor (None or TriangularMatrix or InverseTriangularMatrix):
                Optional argument giving the triangular factorisation of the
                matrix such that `matrix = factor @ factor.T`. If not
                pre-computed and specified at initialisation a factorisation
                will only be computed when first required by an operation which
                depends on the factor.
        &#34;&#34;&#34;
        super().__init__(array=array, factor=factor, is_posdef=True)

    @property
    def inv(self):
        return TriangularFactoredPositiveDefiniteMatrix(
            factor=self.factor.inv.T)

    @property
    def sqrt(self):
        return self.factor


class DensePositiveDefiniteProductMatrix(DensePositiveDefiniteMatrix):
    &#34;&#34;&#34;Positive-definite matrix specified as a signed symmetric product.

    The matrix is assumed to have the form

        matrix = rect_matrix @ pos_def_matrix @ rect_matrix.T

    for a dense rectangular matrix `rect_matrix` with shape `(dim_0, dim_1)`
    (`dim_1 &gt; dim_0`) positive definite matrix `pos_def_matrix` with shape
    `(dim_1, dim_1)`, with the resulting matrix being positive definite under
    the assumption that `rect_matrix` has full row rank.
    &#34;&#34;&#34;

    def __init__(self, rect_matrix, pos_def_matrix=None):
        &#34;&#34;&#34;
        Args:
            rect_matrix (array or Matrix): Rectangular matrix of shape
                `(dim_0, dim_1)` with it and its transpose forming the leftmost
                and righmost term respectively in the symmetric matrix product
                defining the matrix.
            pos_def_matrix (None or PositiveDefiniteMatrix): Optional positive
                positive definite matrix with shape `(dim_inner, dim_inner)`
                specifying inner term in symmetric matrix product defining
                matrix. If `None` an identity matrix is used.
        &#34;&#34;&#34;
        if not rect_matrix.shape[0] &lt; rect_matrix.shape[1]:
            raise ValueError(&#39;rect_matrix must have more columns than rows&#39;)
        if not isinstance(rect_matrix, Matrix):
            rect_matrix = DenseRectangularMatrix(rect_matrix)
        self._rect_matrix = rect_matrix
        if pos_def_matrix is None:
            pos_def_matrix = IdentityMatrix(rect_matrix.shape[1])
        self._pos_def_matrix = pos_def_matrix
        _array = rect_matrix @ (pos_def_matrix @ rect_matrix.T.array)
        super().__init__(_array)

    @property
    def grad_log_abs_det(self):
        return 2 * (self.inv @ (
            self._rect_matrix.array @ self._pos_def_matrix))

    def grad_quadratic_form_inv(self, vector):
        inv_matrix_vector = self.inv @ vector
        return -2 * np.outer(
            inv_matrix_vector,
            self._pos_def_matrix @ (self._rect_matrix.T @ inv_matrix_vector))


class DenseSquareMatrix(InvertibleMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Dense non-singular square matrix.&#34;&#34;&#34;

    def __init__(self, array, lu_and_piv=None, lu_transposed=None):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array specifying matrix entries.
            lu_and_piv (Tuple[array, array]): Pivoted LU factorisation
                represented as a tuple with first element a 2D array containing
                the lower and upper triangular factors (with the unit diagonal
                of the lower triangular factor not stored) and the second
                element a 1D array containing the pivot indices. Corresponds
                to the output of `scipy.linalg.lu_factor` and input to
                `scipy.linalg.lu_solve`.
            lu_transposed (bool): Whether LU factorisation is of original array
                or its transpose.
        &#34;&#34;&#34;
        super().__init__(array.shape, _array=array)
        self._lu_and_piv = lu_and_piv
        self._lu_transposed = lu_transposed

    def _scalar_multiply(self, scalar):
        if self._lu_and_piv is None or self._lu_transposed is None:
            return DenseSquareMatrix(scalar * self._array)
        else:
            old_lu, piv = self._lu_and_piv
            # Multiply upper-triangle by scalar
            new_lu = old_lu + (scalar - 1) * np.triu(old_lu)
            return DenseSquareMatrix(
                scalar * self._array, (new_lu, piv), self._lu_transposed)

    @property
    def lu_and_piv(self):
        &#34;&#34;&#34;Pivoted LU factorisation of matrix.&#34;&#34;&#34;
        if self._lu_and_piv is None:
            self._lu_and_piv = sla.lu_factor(self._array)
            self._lu_transposed = False
        return self._lu_and_piv

    @property
    def log_abs_det(self):
        lu, piv = self.lu_and_piv
        return np.log(np.abs(lu.diagonal())).sum()

    @property
    def T(self):
        lu_and_piv = self.lu_and_piv
        return DenseSquareMatrix(
            self._array.T, lu_and_piv, not self._lu_transposed)

    @property
    def inv(self):
        lu_and_piv = self.lu_and_piv
        return InverseLUFactoredSquareMatrix(
            self._array, lu_and_piv, self._lu_transposed)


class InverseLUFactoredSquareMatrix(InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Square matrix implicitly defined by LU factorisation of inverse.&#34;&#34;&#34;

    def __init__(self, inv_array, inv_lu_and_piv, inv_lu_transposed):
        &#34;&#34;&#34;
        Args:
            inv_array (array): 2D array specifying inverse matrix entries.
            inv_lu_and_piv (Tuple[array, array]): Pivoted LU factorisation
                represented as a tuple with first element a 2D array containing
                the lower and upper triangular factors (with the unit diagonal
                of the lower triangular factor not stored) and the second
                element a 1D array containing the pivot indices. Corresponds
                to the output of `scipy.linalg.lu_factor` and input to
                `scipy.linalg.lu_solve`.
            inv_lu_transposed (bool): Whether LU factorisation is of inverse of
                array or transpose of inverse of array.
        &#34;&#34;&#34;
        super().__init__(inv_array.shape)
        self._inv_array = inv_array
        self._inv_lu_and_piv = inv_lu_and_piv
        self._inv_lu_transposed = inv_lu_transposed

    def _scalar_multiply(self, scalar):
        old_inv_lu, piv = self._inv_lu_and_piv
        # Divide upper-triangle by scalar
        new_inv_lu = old_inv_lu - (scalar - 1) / scalar * np.triu(old_inv_lu)
        return InverseLUFactoredSquareMatrix(
            self._inv_array / scalar, (new_inv_lu, piv),
            self._inv_lu_transposed)

    def _left_matrix_multiply(self, other):
        return sla.lu_solve(
            self._inv_lu_and_piv, other, self._inv_lu_transposed)

    def _right_matrix_multiply(self, other):
        return sla.lu_solve(
            self._inv_lu_and_piv, other.T, not self._inv_lu_transposed).T

    @property
    def log_abs_det(self):
        return -np.log(np.abs(self._inv_lu_and_piv[0].diagonal())).sum()

    def _construct_array(self):
        return self @ np.identity(self.shape[0])

    @property
    def inv(self):
        return DenseSquareMatrix(
            self._inv_array, self._inv_lu_and_piv, self._inv_lu_transposed)

    @property
    def T(self):
        return InverseLUFactoredSquareMatrix(
            self._inv_array.T, self._inv_lu_and_piv,
            not self._inv_lu_transposed)

    def _compute_hash(self):
        return hash_array(self._inv_array)

    def _check_equality(self, other):
        return np.array_equal(self._inv_array, other._inv_array)


class DenseSymmetricMatrix(
        SymmetricMatrix, InvertibleMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Dense non-singular symmetric matrix.&#34;&#34;&#34;

    def __init__(self, array, eigvec=None, eigval=None):
        &#34;&#34;&#34;
        Args:
            array (array): Explicit 2D array representation of matrix.
            eigvec (None or array or OrthogonalMatrix): Optional. If specified
                either a 2D array or an `OrthogonalMatrix` instance, in both
                cases the columns of the matrix corresponding to the
                orthonormal set of eigenvectors of the matrix being
                constructed.
            eigval (None or array): Optional. If specified a 1D array
                containing the eigenvalues of the matrix being constructed,
                with `eigval[i]` the eigenvalue associated with column `i` of
                `eigvec`.
        &#34;&#34;&#34;
        super().__init__(array.shape, _array=array)
        if isinstance(eigvec, np.ndarray):
            eigvec = OrthogonalMatrix(eigvec)
        self._eigvec = eigvec
        self._eigval = eigval

    def _scalar_multiply(self, scalar):
        return DenseSymmetricMatrix(
            self.array * scalar, self._eigvec,
            None if self._eigval is None else self._eigval * scalar)

    @property
    def inv(self):
        return EigendecomposedSymmetricMatrix(self.eigvec, 1 / self.eigval)


class OrthogonalMatrix(InvertibleMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Square matrix with columns and rows that are orthogonal unit vectors.&#34;&#34;&#34;

    def __init__(self, array):
        &#34;&#34;&#34;
        Args:
            array (array): Explicit 2D array representation of matrix.
        &#34;&#34;&#34;
        super().__init__(array.shape, _array=array)

    def _scalar_multiply(self, scalar):
        return ScaledOrthogonalMatrix(scalar, self.array)

    @property
    def log_abs_det(self):
        return 0

    @property
    def T(self):
        return OrthogonalMatrix(self.array.T)

    @property
    def inv(self):
        return self.T


class ScaledOrthogonalMatrix(InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix corresponding to orthogonal matrix multiplied by a scalar.

    Matrix is assumed to have the paramterisation

        matrix = scalar * orth_array

    where `scalar` is a real-valued scalar and `orth_array` is an orthogonal
    matrix represented as a square 2D array.
    &#34;&#34;&#34;

    def __init__(self, scalar, orth_array):
        &#34;&#34;&#34;
        Args:
            scalar (float): Scalar multiplier as a floating point value.
            orth_array (array): 2D array representation of orthogonal matrix.
        &#34;&#34;&#34;
        super().__init__(orth_array.shape, _orth_array=orth_array)
        self._scalar = scalar

    def _left_matrix_multiply(self, other):
        return self._scalar * (self._orth_array @ other)

    def _right_matrix_multiply(self, other):
        return self._scalar * (other @ self._orth_array)

    def _scalar_multiply(self, scalar):
        return ScaledOrthogonalMatrix(scalar * self._scalar, self._orth_array)

    def _construct_array(self):
        return self._scalar * self._orth_array

    @property
    def diagonal(self):
        return self._scalar * self._orth_array.diagonal()

    @property
    def log_abs_det(self):
        return self.shape[0] * np.log(abs(self._scalar))

    @property
    def T(self):
        return ScaledOrthogonalMatrix(self._scalar, self._orth_array.T)

    @property
    def inv(self):
        return ScaledOrthogonalMatrix(1 / self._scalar, self._orth_array.T)

    def _compute_hash(self):
        return hash((self._scalar, hash_array(self._orth_array)))

    def _check_equality(self, other):
        return self._scalar == other._scalar and (
            np.array_equal(self._orth_array, other._orth_array))


class EigendecomposedSymmetricMatrix(
        SymmetricMatrix, InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Symmetric matrix parameterised by its eigendecomposition.

    The matrix is assumed to have the parameterisation

        matrix = eigvec @ diag(eigval) @ eigvec.T

    where `eigvec` is an orthogonal matrix, with columns corresponding to
    the eigenvectors of `matrix` and `eigval` is 1D array of the corresponding
    eigenvalues of `matrix`.
    &#34;&#34;&#34;

    def __init__(self, eigvec, eigval):
        &#34;&#34;&#34;
        Args:
            eigvec (array or OrthogonalMatrix): Either a 2D array or an
                `OrthogonalMatrix` instance, in both cases the columns of the
                matrix corresponding to the orthonormal set of eigenvectors of
                the matrix being constructed.
            eigval (array): A 1D array containing the eigenvalues of the matrix
                being constructed, with `eigval[i]` the eigenvalue associated
                with column `i` of `eigvec`.
        &#34;&#34;&#34;
        if isinstance(eigvec, np.ndarray):
            eigvec = OrthogonalMatrix(eigvec)
        super().__init__(eigvec.shape)
        self._eigvec = eigvec
        self._eigval = eigval
        if not isinstance(eigval, np.ndarray) or eigval.size == 1:
            self.diag_eigval = ScaledIdentityMatrix(eigval)
        else:
            self.diag_eigval = DiagonalMatrix(eigval)

    def _scalar_multiply(self, scalar):
        return EigendecomposedSymmetricMatrix(
            self.eigvec, self.eigval * scalar)

    def _left_matrix_multiply(self, other):
        return self.eigvec @ (self.diag_eigval @ (self.eigvec.T @ other))

    def _right_matrix_multiply(self, other):
        return ((other @ self.eigvec) @ self.diag_eigval) @ self.eigvec.T

    @property
    def inv(self):
        return EigendecomposedSymmetricMatrix(self.eigvec, 1 / self.eigval)

    def _construct_array(self):
        if self.shape[0] is None:
            raise RuntimeError(
                &#39;Cannot get array representation for symmetric &#39;
                &#39;eigendecomposed matrix with implicit size.&#39;)
        return self @ np.identity(self.shape[0])

    def _compute_hash(self):
        return hash((hash_array(self.eigval), self.eigvec))

    def _check_equality(self, other):
        return np.array_equal(self.eigval, other.eigval) and (
            self.eigvec == other.eigvec)


class EigendecomposedPositiveDefiniteMatrix(
        EigendecomposedSymmetricMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Positive definite matrix parameterised by its eigendecomposition.

    The matrix is assumed to have the parameterisation

        matrix = eigvec @ diag(eigval) @ eigvec.T

    where `eigvec` is an orthogonal matrix, with columns corresponding to
    the eigenvectors of `matrix` and `eigval` is 1D array of the corresponding
    strictly positive eigenvalues of `matrix`.
    &#34;&#34;&#34;

    def __init__(self, eigvec, eigval):
        if not np.all(eigval &gt; 0):
            raise ValueError(&#39;Eigenvalues must all be positive.&#39;)
        super().__init__(eigvec, eigval)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return EigendecomposedPositiveDefiniteMatrix(
                self.eigvec, self.eigval * scalar)
        else:
            return super()._scalar_multiply(scalar)

    @property
    def inv(self):
        return EigendecomposedPositiveDefiniteMatrix(
            self.eigvec, 1 / self.eigval)

    @property
    def sqrt(self):
        return EigendecomposedSymmetricMatrix(self.eigvec, self.eigval**0.5)


class SoftAbsRegularisedPositiveDefiniteMatrix(
        EigendecomposedPositiveDefiniteMatrix, DifferentiableMatrix):
    &#34;&#34;&#34;Matrix transformed to be positive definite by regularising eigenvalues.

    Matrix is parameterised by a symmetric array `symmetric_array`, of which an
    eigendecomposition is formed `eigvec, eigval = eigh(symmetric_array)`, with
    the output matrix then `matrix = eigvec @ softabs(eigval) @ eigvec.T`
    where `softabs` is a smooth approximation to the absolute function.
    &#34;&#34;&#34;

    def __init__(self, symmetric_array, softabs_coeff):
        &#34;&#34;&#34;
        Args:
            symmetric_array (array): 2D square array with symmetric values,
                i.e. `symmetric_array[i, j] == symmetric_array[j, i]` for all
                indices `i` and `j` which represents symmetric matrix to
                form eigenvalue-regularised transformation of.
            softabs_coeff (float): Positive regularisation coefficient for
                smooth approximation to absolute value. As the value tends to
                infinity the approximation becomes increasingly close to the
                absolute function.
        &#34;&#34;&#34;
        if softabs_coeff &lt;= 0:
            raise ValueError(&#39;softabs_coeff must be positive.&#39;)
        self._softabs_coeff = softabs_coeff
        self.unreg_eigval, eigvec = nla.eigh(symmetric_array)
        eigval = self.softabs(self.unreg_eigval)
        super().__init__(eigvec, eigval)

    def softabs(self, x):
        &#34;&#34;&#34;Smooth approximation to absolute function.&#34;&#34;&#34;
        return x / np.tanh(x * self._softabs_coeff)

    def grad_softabs(self, x):
        &#34;&#34;&#34;Derivative of smooth approximation to absolute function.&#34;&#34;&#34;
        return (
            1. / np.tanh(self._softabs_coeff * x) -
            self._softabs_coeff * x / np.sinh(self._softabs_coeff * x)**2)

    @property
    def grad_log_abs_det(self):
        grad_eigval = self.grad_softabs(self.unreg_eigval) / self.eigval
        return EigendecomposedSymmetricMatrix(self.eigvec, grad_eigval).array

    def grad_quadratic_form_inv(self, vector):
        num_j_mtx = self.eigval[:, None] - self.eigval[None, :]
        num_j_mtx += np.diag(self.grad_softabs(self.unreg_eigval))
        den_j_mtx = self.unreg_eigval[:, None] - self.unreg_eigval[None, :]
        np.fill_diagonal(den_j_mtx, 1)
        j_mtx = num_j_mtx / den_j_mtx
        e_vct = (self.eigvec.T @ vector) / self.eigval
        return -(
            (self.eigvec @ (np.outer(e_vct, e_vct) * j_mtx)) @ self.eigvec.T)


class BlockMatrix(ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix with non-zero entries defined by a series of submatrix blocks.&#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def blocks(self):
        &#34;&#34;&#34;Non-zero blocks of matrix as a tuple of Matrix instances&#34;&#34;&#34;

    def _compute_hash(self):
        return hash(tuple(block for block in self.blocks))

    def _check_equality(self, other):
        return (
            len(other.blocks) == len(self.blocks) and
            all(block_s == block_o for block_s, block_o
                in zip(self.blocks, other.blocks))
        )


class SquareBlockDiagonalMatrix(InvertibleMatrix, BlockMatrix):
    &#34;&#34;&#34;Square matrix with non-zero values only in blocks along diagonal.&#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[SquareMatrix]): Sequence of square matrices
                defining non-zero blocks along diagonal of matrix in order
                left-to-right.
        &#34;&#34;&#34;
        self._blocks = tuple(blocks)
        if not all(isinstance(block, SquareMatrix) for block in self._blocks):
            raise ValueError(&#39;All blocks must be square&#39;)
        sizes = tuple(block.shape[0] for block in self._blocks)
        total_size = sum(sizes)
        super().__init__((total_size, total_size))
        self._sizes = sizes
        self._splits = np.cumsum(sizes[:-1])

    @property
    def blocks(self):
        &#34;&#34;&#34;Blocks containing non-zero values left-to-right along diagonal.&#34;&#34;&#34;
        return self._blocks

    def _split(self, other, axis=0):
        assert other.shape[axis] == self.shape[0]
        return np.split(other, self._splits, axis=axis)

    def _left_matrix_multiply(self, other):
        return np.concatenate(
            [block @ part for block, part in
             zip(self._blocks, self._split(other, axis=0))], axis=0)

    def _right_matrix_multiply(self, other):
        return np.concatenate(
            [part @ block for block, part in
             zip(self._blocks, self._split(other, axis=-1))], axis=-1)

    def _scalar_multiply(self, scalar):
        return SquareBlockDiagonalMatrix(
            tuple(scalar * block for block in self._blocks))

    def _construct_array(self):
        return sla.block_diag(*(block.array for block in self._blocks))

    @property
    def T(self):
        return SquareBlockDiagonalMatrix(
            tuple(block.T for block in self._blocks))

    @property
    def sqrt(self):
        return SquareBlockDiagonalMatrix(
            tuple(block.sqrt for block in self._blocks))

    @property
    def diag(self):
        return np.concatenate([block.diagonal() for block in self._blocks])

    @property
    def inv(self):
        return type(self)(tuple(block.inv for block in self._blocks))

    @property
    def eigval(self):
        return np.concatenate([block.eigval for block in self._blocks])

    @property
    def eigvec(self):
        return SquareBlockDiagonalMatrix(
            tuple(block.eigvec for block in self._blocks))

    @property
    def log_abs_det(self):
        return sum(block.log_abs_det for block in self._blocks)


class SymmetricBlockDiagonalMatrix(SquareBlockDiagonalMatrix):
    &#34;&#34;&#34;Symmetric specialisation of `SquareBlockDiagonalMatrix`.

    All matrix blocks in diagonal are restricted to be symmetric, i.e.
    `block.T == block`.
    &#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[SymmetricMatrix]): Sequence of symmetric matrices
                defining non-zero blocks along diagonal of matrix in order
                left-to-right.
        &#34;&#34;&#34;
        blocks = tuple(blocks)
        if not all(isinstance(block, SymmetricMatrix) for block in blocks):
            raise ValueError(&#39;All blocks must be symmetric&#39;)
        super().__init__(blocks)

    def _scalar_multiply(self, scalar):
        return SymmetricBlockDiagonalMatrix(
            tuple(scalar * block for block in self._blocks))

    @property
    def T(self):
        return self


class PositiveDefiniteBlockDiagonalMatrix(
        SymmetricBlockDiagonalMatrix, PositiveDefiniteMatrix,
        DifferentiableMatrix):
    &#34;&#34;&#34;Positive definite specialisation of `SymmetricBlockDiagonalMatrix`.

    All matrix blocks in diagonal are restricted to be positive definite.
    &#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[PositiveDefinite]): Sequence of positive-definite
                matrices defining non-zero blocks along diagonal of matrix in
                order left-to-right.
        &#34;&#34;&#34;
        blocks = tuple(blocks)
        if not all(isinstance(block, PositiveDefiniteMatrix)
                   for block in blocks):
            raise ValueError(&#39;All blocks must be positive definite&#39;)
        self.is_differentiable = all(
            [isinstance(block, DifferentiableMatrix) for block in blocks])
        super().__init__(blocks)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveDefiniteBlockDiagonalMatrix(
                tuple(scalar * block for block in self._blocks))
        else:
            return super()._scalar_multiply(scalar)

    @property
    def sqrt(self):
        return SquareBlockDiagonalMatrix(
            tuple(block.sqrt for block in self._blocks))

    @property
    def grad_log_abs_det(self):
        if self.is_differentiable:
            return tuple(
                block.grad_log_abs_det for block in self._blocks)
        else:
            raise RuntimeError(&#39;Not all blocks are differentiable&#39;)

    def grad_quadratic_form_inv(self, vector):
        if self.is_differentiable:
            return tuple(
                block.grad_quadratic_form_inv(vector_part)
                for block, vector_part in
                zip(self._blocks, self._split(vector, axis=0)))
        else:
            raise RuntimeError(&#39;Not all blocks are differentiable&#39;)


class DenseRectangularMatrix(ExplicitArrayMatrix):
    &#34;&#34;&#34;Dense rectangular matrix.&#34;&#34;&#34;

    def __init__(self, array):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array specifying matrix entries.
        &#34;&#34;&#34;
        super().__init__(array.shape, _array=array)

    def _scalar_multiply(self, scalar):
        return DenseRectangularMatrix(scalar * self.array)

    @property
    def T(self):
        return DenseRectangularMatrix(self.array.T)


class BlockRowMatrix(BlockMatrix):
    &#34;&#34;&#34;Matrix composed of horizontal concatenation of a series of blocks.&#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[Matrix]): Sequence of matrices defining a row of
                blocks in order left-to-right which when horizontally
                concatenated give the overall matrix.
        &#34;&#34;&#34;
        self._blocks = tuple(blocks)
        if not all(isinstance(block, Matrix) for block in self._blocks):
            raise ValueError(&#39;All blocks must be matrices&#39;)
        if len(set([block.shape[0] for block in self._blocks])) &gt; 1:
            raise ValueError(&#39;All blocks must have same row-dimension.&#39;)
        col_dims = tuple(block.shape[1] for block in self._blocks)
        super().__init__(shape=(self._blocks[0].shape[0], sum(col_dims)))
        self._splits = np.cumsum(col_dims[:-1])

    @property
    def blocks(self):
        &#34;&#34;&#34;Blocks of matrix in left-to-right order.&#34;&#34;&#34;
        return self._blocks

    def _left_matrix_multiply(self, other):
        assert other.shape[0] == self.shape[1]
        return sum(
            [block @ part for block, part in
             zip(self._blocks, np.split(other, self._splits, axis=0))])

    def _right_matrix_multiply(self, other):
        return np.concatenate(
            [other @ block for block in self._blocks], axis=-1)

    def _scalar_multiply(self, scalar):
        return BlockRowMatrix(
            tuple(scalar * block for block in self._blocks))

    def _construct_array(self):
        return np.concatenate([block.array for block in self._blocks], axis=1)

    @property
    def T(self):
        return BlockColumnMatrix(
            tuple(block.T for block in self._blocks))


class BlockColumnMatrix(BlockMatrix):
    &#34;&#34;&#34;Matrix composed of vertical concatenation of a series of blocks.&#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[Matrix]): Sequence of matrices defining a column
                of blocks in order top-to-bottom which when vertically
                concatenated give the overall matrix.
        &#34;&#34;&#34;
        self._blocks = tuple(blocks)
        if not all(isinstance(block, Matrix) for block in self._blocks):
            raise ValueError(&#39;All blocks must be matrices&#39;)
        if len(set([block.shape[1] for block in self._blocks])) &gt; 1:
            raise ValueError(&#39;All blocks must have same column-dimension.&#39;)
        row_dims = tuple(block.shape[0] for block in self._blocks)
        super().__init__(shape=(sum(row_dims), self._blocks[0].shape[1]))
        self._splits = np.cumsum(row_dims[:-1])

    @property
    def blocks(self):
        &#34;&#34;&#34;Blocks of matrix in top-to-bottom order.&#34;&#34;&#34;
        return self._blocks

    def _left_matrix_multiply(self, other):
        return np.concatenate(
            [block @ other for block in self._blocks], axis=0)

    def _right_matrix_multiply(self, other):
        assert other.shape[-1] == self.shape[0]
        return sum(
            [part @ block for block, part in
             zip(self._blocks, np.split(other, self._splits, axis=-1))])

    def _scalar_multiply(self, scalar):
        return BlockColumnMatrix(
            tuple(scalar * block for block in self._blocks))

    def _construct_array(self):
        return np.concatenate([block.array for block in self._blocks], axis=0)

    @property
    def T(self):
        return BlockRowMatrix(
            tuple(block.T for block in self._blocks))


class SquareLowRankUpdateMatrix(InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Square matrix equal to a low-rank update to a square matrix.

    The matrix is assumed to have the parametrisation

        matrix = (
            square_matrix + sign *
            left_factor_matrix @ inner_square_matrix @ right_factor_matrix)

    where `left_factor_matrix` and `right_factor_matrix` are rectangular
    with shapes `(dim_outer, dim_inner)` and `(dim_inner, dim_outer)`
    resp., `square_matrix` is square with shape `(dim_outer, dim_outer)`,
    `inner_square_matrix` is square with shape `(dim_inner, dim_inner)` and
    `sign` is one of {-1, +1} and determines whether a low-rank update
    (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.

    By exploiting the Woodbury matrix identity and matrix determinant lemma the
    inverse and determinant of the matrix can be computed at a cost of
    `O(dim_inner**3 + dim_inner**2 * dim_outer)` plus the cost of inverting /
    evaluating the determinant of `square_matrix`, which for `square_matrix`
    instances with special structure such as diagonality or with an existing
    factorisation, will typically be cheaper than the `O(dim_outer**3)` cost
    of evaluating the inverse or determinant directly.
    &#34;&#34;&#34;

    def __init__(self, left_factor_matrix, right_factor_matrix, square_matrix,
                 inner_square_matrix=None, capacitance_matrix=None, sign=1):
        &#34;&#34;&#34;
        Args:
            left_factor_matrix (Matrix): Rectangular matrix with shape
                `(dim_outer, dim_inner)` forming leftmost term in matrix
                product defining low-rank update.
            right_factor_matrix (Matrix): Rectangular matrix with shape
                `(dim_inner, dim_outer)` forming rightmost term in matrix
                product defining low-rank update.
            square_matrix (SquareMatrix): Square matrix to perform low-rank
                update (or downdate) to.
            inner_square_matrix (None or SquareMatrix): Optional square matrix
                with shape `(dim_inner, dim_inner)` specifying inner term in
                matrix product defining low-rank update. If `None` an identity
                matrix is used.
            capacitance_matrix (None or SquareMatrix): Square matrix equal to
                `inner_square_matrix.inv + right_factor_matrix @
                square_matrix.inv @ left_factor_matrix` and with shape
                `(dim_inner, dim_inner)` which is used in constructing inverse
                and computation of determinant of the low-rank updated matrix,
                with this argument optional and typically only passed when
                this matrix has already been computed in a previous
                computation.
            sign (int): One of {-1, +1}, determining whether a low-rank update
                (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.
        &#34;&#34;&#34;
        dim_outer, dim_inner = left_factor_matrix.shape
        if square_matrix.shape[0] != dim_outer:
            raise ValueError(f&#39;Inconsistent factor and square matrix shapes: &#39;
                             f&#39;outer dimensions {dim_outer} and &#39;
                             f&#39;{square_matrix.shape[0]}.&#39;)
        if square_matrix.shape[0] != square_matrix.shape[1]:
            raise ValueError(&#39;square_matrix argument must be square&#39;)
        if right_factor_matrix.shape != (dim_inner, dim_outer):
            raise ValueError(f&#39;Inconsistent factor matrix shapes: &#39;
                             f&#39;{left_factor_matrix.shape} and &#39;
                             f&#39;{right_factor_matrix.shape}.&#39;)
        if inner_square_matrix is None:
            inner_square_matrix = IdentityMatrix(dim_inner)
        elif inner_square_matrix.shape != (dim_inner, dim_inner):
            raise ValueError(f&#39;inner_square matrix must be square and of shape&#39;
                             f&#39; {(dim_inner, dim_inner)}.&#39;)
        self.left_factor_matrix = left_factor_matrix
        self.right_factor_matrix = right_factor_matrix
        self.square_matrix = square_matrix
        self.inner_square_matrix = inner_square_matrix
        self._capacitance_matrix = capacitance_matrix
        self._sign = sign
        super().__init__((dim_outer, dim_outer))

    def _left_matrix_multiply(self, other):
        return self.square_matrix @ other + (
            self._sign * self.left_factor_matrix @ (
                self.inner_square_matrix @ (self.right_factor_matrix @ other)))

    def _right_matrix_multiply(self, other):
        return other @ self.square_matrix + (
            self._sign * (
                other @ self.left_factor_matrix) @ self.inner_square_matrix
            ) @ self.right_factor_matrix

    def _scalar_multiply(self, scalar):
        return type(self)(
            self.left_factor_matrix, self.right_factor_matrix,
            scalar * self.square_matrix, scalar * self.inner_square_matrix,
            self._capacitance_matrix / scalar
            if self._capacitance_matrix is not None else None, self._sign)

    def _construct_array(self):
        return self.square_matrix.array + (
            self._sign * self.left_factor_matrix @ (
                self.inner_square_matrix @ self.right_factor_matrix.array))

    @property
    def capacitance_matrix(self):
        if self._capacitance_matrix is None:
            self._capacitance_matrix = DenseSquareMatrix(
                self.inner_square_matrix.inv.array +
                self.right_factor_matrix @ (
                    self.square_matrix.inv @ self.left_factor_matrix.array))
        return self._capacitance_matrix

    @property
    def diagonal(self):
        return self.square_matrix.diagonal + self._sign * (
            (self.left_factor_matrix.array @ self.inner_square_matrix) *
            self.right_factor_matrix.T.array).sum(1)

    @property
    def T(self):
        return type(self)(
            self.right_factor_matrix.T, self.left_factor_matrix.T,
            self.square_matrix.T, self.inner_square_matrix.T,
            self._capacitance_matrix.T
            if self._capacitance_matrix is not None else None,
            self._sign)

    @property
    def inv(self):
        return type(self)(
            self.square_matrix.inv @ self.left_factor_matrix,
            self.right_factor_matrix @ self.square_matrix.inv,
            self.square_matrix.inv, self.capacitance_matrix.inv,
            self.inner_square_matrix.inv, -self._sign)

    @property
    def log_abs_det(self):
        return (
            self.square_matrix.log_abs_det +
            self.inner_square_matrix.log_abs_det +
            self.capacitance_matrix.log_abs_det)

    def _compute_hash(self):
        return hash((self.left_factor_matrix, self.right_factor_matrix,
                     self.square_matrix, self.inner_square_matrix))

    def _check_equality(self, other):
        return (
            self.left_factor_matrix == other.left_factor_matrix and
            self.right_factor_matrix == other.right_factor_matrix and
            self.square_matrix == other.square_matrix and
            self.inner_square_matrix == other.inner_square_matrix)


class SymmetricLowRankUpdateMatrix(
        SquareLowRankUpdateMatrix, SymmetricMatrix, InvertibleMatrix):
    &#34;&#34;&#34;Symmetric matrix equal to a low-rank update to a symmetric matrix.

    The matrix is assumed to have the parametrisation

        matrix = (
            symmetric_matrix +
            sign * factor_matrix @ inner_symmetric_matrix @ factor_matrix.T)

    where `factor_matrix` is rectangular with shape `(dim_outer, dim_inner)`,
    `symmetric_matrix` is symmetric with shape `(dim_outer, dim_outer)`,
    `inner_symmetric_matrix` is symmetric with shape `(dim_inner, dim_inner)`
    and `sign` is one of {-1, +1} and determines whether a low-rank update
    (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.

    By exploiting the Woodbury matrix identity and matrix determinant lemma the
    inverse and determinant of the matrix can be computed at a cost of
    `O(dim_inner**3 + dim_inner**2 * dim_outer)` plus the cost of inverting /
    evaluating the determinant of `square_matrix`, which for `square_matrix`
    instances with special structure such as diagonality or with an existing
    factorisation, will typically be cheaper than the `O(dim_outer**3)` cost
    of evaluating the inverse or determinant directly.
    &#34;&#34;&#34;

    def __init__(self, factor_matrix, symmetric_matrix,
                 inner_symmetric_matrix=None, capacitance_matrix=None, sign=1):
        &#34;&#34;&#34;
        Args:
            factor_matrix (Matrix): Rectangular matrix with shape
                `(dim_outer, dim_inner)` with it and its transpose forming the
                leftmost and righmost term respectively in the matrix product
                defining the low-rank update.
            symmetric_matrix (SymmetricMatrix): Symmetric matrix to perform
                low-rank update (or downdate) to.
            inner_symmetric_matrix (None or SymmetricMatrix): Optional
                symmetric matrix with shape `(dim_inner, dim_inner)` specifying
                inner term in matrix product defining low-rank update. If
                `None` an identity matrix is used.
            capacitance_matrix (None or SymmetricMatrix): Symmetric matrix
                equal to `inner_symmetric_matrix.inv + factor_matrix.T @
                symmetric_matrix.inv @ factor_matrix` and with shape
                `(dim_inner, dim_inner)` which is used in constructing inverse
                and computation of determinant of the low-rank updated matrix,
                with this argument optional and typically only passed when
                this matrix has already been computed in a previous
                computation.
            sign (int): One of {-1, +1}, determining whether a low-rank update
                (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.
        &#34;&#34;&#34;
        if symmetric_matrix.T is not symmetric_matrix:
            raise ValueError(&#39;symmetric_matrix must be symmetric&#39;)
        if inner_symmetric_matrix.T is not inner_symmetric_matrix:
            raise ValueError(&#39;inner_symmetric_matrix must be symmetric&#39;)
        self.factor_matrix = factor_matrix
        self.symmetric_matrix = symmetric_matrix
        self.inner_symmetric_matrix = inner_symmetric_matrix
        super().__init__(
            factor_matrix, factor_matrix.T, symmetric_matrix,
            inner_symmetric_matrix, capacitance_matrix, sign)

    def _scalar_multiply(self, scalar):
        return type(self)(
            self.factor_matrix, scalar * self.symmetric_matrix,
            scalar * self.inner_symmetric_matrix,
            self._capacitance_matrix / scalar
            if self._capacitance_matrix is not None else None, self._sign)

    @property
    def capacitance_matrix(self):
        if self._capacitance_matrix is None:
            self._capacitance_matrix = DenseSymmetricMatrix(
                self.inner_symmetric_matrix.inv.array +
                self.factor_matrix.T @ (
                    self.symmetric_matrix.inv @ self.factor_matrix.array))
        return self._capacitance_matrix

    @property
    def inv(self):
        return type(self)(
            self.symmetric_matrix.inv @ self.factor_matrix,
            self.symmetric_matrix.inv, self.capacitance_matrix.inv,
            self.inner_symmetric_matrix.inv, -self._sign)

    @property
    def T(self):
        return self

    def _compute_hash(self):
        return hash((
            self.factor_matrix, self.square_matrix, self.inner_square_matrix))

    def _check_equality(self, other):
        return (
            self.factor_matrix == other.factor_matrix and
            self.square_matrix == other.square_matrix and
            self.inner_square_matrix == other.inner_square_matrix)


class PositiveDefiniteLowRankUpdateMatrix(
        PositiveDefiniteMatrix, DifferentiableMatrix,
        SymmetricLowRankUpdateMatrix):
    &#34;&#34;&#34;Positive-definite matrix equal to low-rank update to a square matrix.

    The matrix is assumed to have the parametrisation

        matrix = (
            pos_def_matrix +
            sign * factor_matrix @ inner_pos_def_matrix @ factor_matrix.T)

    where `factor_matrix` is rectangular with shape `(dim_outer, dim_inner)`,
    `pos_def_matrix` is positive-definite with shape `(dim_outer, dim_outer)`,
    `inner_pos_def_matrix` is positive-definite with shape
    `(dim_inner, dim_inner)` and `sign` is one of {-1, +1} and determines
    whether a low-rank update (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is
    peformed.

    By exploiting the Woodbury matrix identity and matrix determinant lemma the
    inverse, determinant and square-root of the matrix can all be computed at a
    cost of `O(dim_inner**3 + dim_inner**2 * dim_outer)` plus the cost of
    inverting / evaluating the determinant / square_root of `pos_def_matrix`,
    which for `pos_def_matrix` instances with special structure such as
    diagonality or with an existing factorisation, will typically be cheaper
    than the `O(dim_outer**3)` cost of evaluating the inverse, determinant or
    square-root directly.
    &#34;&#34;&#34;

    def __init__(self, factor_matrix, pos_def_matrix,
                 inner_pos_def_matrix=None, capacitance_matrix=None, sign=1):
        &#34;&#34;&#34;
        Args:
            factor_matrix (Matrix): Rectangular matrix with shape
                `(dim_outer, dim_inner)` with it and its transpose forming the
                leftmost and righmost term respectively in the matrix product
                defining the low-rank update.
            pos_def_matrix (PositiveDefiniteMatrix): Positive-definite matrix
                to perform low-rank update (or downdate) to.
            inner_pos_def_matrix (None or PositiveDefiniteMatrix): Optional
                positive definite matrix with shape `(dim_inner, dim_inner)`
                specifying inner term in matrix product defining low-rank
                update. If `None` an identity matrix is used.
            capacitance_matrix (None or PositiveDefiniteMatrix): Positive-
                definite matrix equal to `inner_pos_def_matrix.inv +
                factor_matrix.T @ pos_def_matrix.inv @ factor_matrix` and with
                shape `(dim_inner, dim_inner)` which is used in constructing
                inverse and computation of determinant of the low-rank updated
                matrix, with this argument optional and typically only passed
                when this matrix has already been computed in a previous
                computation.
            sign (int): One of {-1, +1}, determining whether a low-rank update
                (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.
        &#34;&#34;&#34;
        self.factor_matrix = factor_matrix
        self.pos_def_matrix = pos_def_matrix
        self.inner_pos_def_matrix = inner_pos_def_matrix
        super().__init__(
            factor_matrix, pos_def_matrix, inner_pos_def_matrix,
            capacitance_matrix, sign)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveDefiniteLowRankUpdateMatrix(
                self.factor_matrix, scalar * self.pos_def_matrix,
                scalar * self.inner_pos_def_matrix,
                self._capacitance_matrix / scalar
                if self._capacitance_matrix is not None else None, self._sign)
        else:
            return SymmetricLowRankUpdateMatrix(
                self.factor_matrix, scalar * self.pos_def_matrix,
                scalar * self.inner_pos_def_matrix,
                self._capacitance_matrix / scalar
                if self._capacitance_matrix is not None else None, self._sign)

    @property
    def capacitance_matrix(self):
        if self._capacitance_matrix is None:
            self._capacitance_matrix = DensePositiveDefiniteMatrix(
                self.inner_pos_def_matrix.inv.array +
                self.factor_matrix.T @ (
                    self.pos_def_matrix.inv @
                    self.factor_matrix.array))
        return self._capacitance_matrix

    @property
    def sqrt(self):
        # Uses O(dim_inner**3 + dim_inner**2 * dim_outer) cost implementation
        # proposed in
        #   Ambikasaran, O&#39;Neill &amp; Singh (2016). Fast symmetric factorization
        #   of hierarchical matrices with applications. arxiv:1405.0223.
        # Variable naming below follows notation in Algorithm 1 in paper
        W = self.pos_def_matrix.sqrt
        K = self.inner_pos_def_matrix
        U = W.inv @ self.factor_matrix
        L = TriangularMatrix(nla.cholesky(U.T @ U.array))
        I_outer, I_inner = IdentityMatrix(U.shape[0]), np.identity(U.shape[1])
        M = sla.sqrtm(I_inner + L.T @ (K @ L.array))
        X = DenseSymmetricMatrix(L.inv.T @ ((M - I_inner) @ L.inv))
        return W @ SymmetricLowRankUpdateMatrix(U, I_outer, X)

    @property
    def grad_log_abs_det(self):
        return 2 * (self.inv @ (
            self.factor_matrix.array @ self.inner_pos_def_matrix))

    def grad_quadratic_form_inv(self, vector):
        inv_matrix_vector = self.inv @ vector
        return -2 * np.outer(
            inv_matrix_vector,
            self.inner_pos_def_matrix @ (
                self.factor_matrix.T @ inv_matrix_vector))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.matrices.Matrix"><code class="flex name class">
<span>class <span class="ident">Matrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for matrix-like objects.</p>
<p>Implements overloads of the matrix multiplication operator <code>@</code>, as well as
the standard multiplication and division operators <code>*</code> and <code>/</code> when the
second argument is a scalar quantity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L23-L197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Matrix(abc.ABC):
    &#34;&#34;&#34;Base class for matrix-like objects.

    Implements overloads of the matrix multiplication operator `@`, as well as
    the standard multiplication and division operators `*` and `/` when the
    second argument is a scalar quantity.
    &#34;&#34;&#34;

    __array_priority__ = 1

    &#34;&#34;&#34;Set of attributes required for class to be considered a subclass&#34;&#34;&#34;
    _required_subclass_attrs = {
        &#39;array&#39;, &#39;shape&#39;, &#39;T&#39;, &#39;diagonal&#39;, &#39;__array__&#39;, &#39;__mul__&#39;, &#39;__rmul__&#39;,
        &#39;__truediv__&#39;, &#39;__neg__&#39;, &#39;__matmul__&#39;, &#39;__rmatmul__&#39;
    }

    def __init__(self, shape, **kwargs):
        &#34;&#34;&#34;
        Args:
           shape (Tuple[int, int]): Shape of matrix `(num_rows, num_columns)`.
        &#34;&#34;&#34;
        self._shape = shape
        self._hash = None
        for k, v in kwargs.items():
            if isinstance(v, np.ndarray):
                v.flags.writeable = False
            self.__dict__[k] = v

    def __array__(self):
        return self.array

    def __mul__(self, other):
        if np.isscalar(other) or np.ndim(other) == 0:
            if other == 0:
                raise NotImplementedError(
                    &#39;Scalar multiplication by zero not implemented.&#39;)
            return self._scalar_multiply(other)
        else:
            return NotImplemented

    def __rmul__(self, other):
        return self.__mul__(other)

    def __truediv__(self, other):
        if np.isscalar(other) or np.ndim(other) == 0:
            if other == 0:
                raise NotImplementedError(
                    &#39;Scalar division by zero not implemented.&#39;)
            return self._scalar_multiply(1 / other)
        else:
            return NotImplemented

    def __neg__(self):
        return self._scalar_multiply(-1)

    def __matmul__(self, other):
        if self.shape[1] is not None and other.shape[0] != self.shape[1]:
            raise ValueError(
                f&#39;Inconsistent dimensions for matrix multiplication: &#39;
                f&#39;{self.shape} and {other.shape}.&#39;)
        if isinstance(other, Matrix):
            matrix_product_class = _choose_matrix_product_class(self, other)
            return matrix_product_class((self, other), check_shapes=False)
        else:
            return self._left_matrix_multiply(other)

    def __rmatmul__(self, other):
        if self.shape[0] is not None and other.shape[-1] != self.shape[0]:
            raise ValueError(
                f&#39;Inconsistent dimensions for matrix multiplication: &#39;
                f&#39;{other.shape} and {self.shape}.&#39;)
        if isinstance(other, Matrix):
            matrix_product_class = _choose_matrix_product_class(self, other)
            return matrix_product_class((other, self), check_shapes=False)
        else:
            return self._right_matrix_multiply(other)

    @property
    def shape(self):
        &#34;&#34;&#34;Shape of matrix as a tuple `(num_rows, num_columns)`.&#34;&#34;&#34;
        return self._shape

    @property
    @abc.abstractmethod
    def array(self):
        &#34;&#34;&#34;Full dense representation of matrix as a 2D array.&#34;&#34;&#34;

    @abc.abstractmethod
    def _left_matrix_multiply(self, other):
        &#34;&#34;&#34;Left multiply argument by the represented matrix.

        Args:
            other (array): Argument to left-multiply.

        Returns:
            result (array): Result of left-multiplying `other` by the
                represented matrix.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def _right_matrix_multiply(self, other):
        &#34;&#34;&#34;Right multiply argument by the represented matrix.

        Args:
            other (array): Argument to right-multiply.

        Returns:
            result (array): Result of right-multiplying `other` by the
                represented matrix.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def _scalar_multiply(self, scalar):
        &#34;&#34;&#34;Calculate result of multiplying represented matrix by a scalar.

        Args:
            scalar (float): Scalar argument to multiply by.

        Returns:
            result (Matrix): Result of multiplying represented matrix by
                `scalar` as another `Matrix` object.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def T(self):
        &#34;&#34;&#34;Transpose of matrix.&#34;&#34;&#34;

    @property
    def diagonal(self):
        &#34;&#34;&#34;Diagonal of matrix as a 1D array.&#34;&#34;&#34;
        return self.array.diagonal()

    def __str__(self):
        return f&#39;(shape={self.shape})&#39;

    def __repr__(self):
        return type(self).__name__ + str(self)

    @classmethod
    def _get_required_subclass_attrs(cls):
        &#34;&#34;&#34;Compute set of required subclass attributes.&#34;&#34;&#34;
        req = set()
        for C in cls.__mro__:
            if hasattr(C, &#39;_required_subclass_attrs&#39;):
                req |= C._required_subclass_attrs
        return req

    @classmethod
    def __subclasshook__(cls, C):
        # Customise isinstance / issubclass behaviour to also return True for
        # classes / objects with classes which have all required attributes
        # without being direct subclasses
        if hasattr(cls, &#39;_get_required_subclass_attrs&#39;):
            if all(any(attr in B.__dict__ for B in C.__mro__)
                   for attr in cls._get_required_subclass_attrs()):
                return True
        return NotImplemented

    @abc.abstractmethod
    def _compute_hash(self):
        &#34;&#34;&#34;Compute hash value for matrix object.&#34;&#34;&#34;

    def __hash__(self):
        if self._hash is None:
            self._hash = self._compute_hash()
        return self._hash

    @abc.abstractmethod
    def _check_equality(self, other):
        &#34;&#34;&#34;Check for equality with another instance of the same class.&#34;&#34;&#34;

    def __eq__(self, other):
        return other is self or (
            other.__class__ == self.__class__ and self._check_equality(other))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.Matrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L100-L103" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def shape(self):
    &#34;&#34;&#34;Shape of matrix as a tuple `(num_rows, num_columns)`.&#34;&#34;&#34;
    return self._shape</code></pre>
</details>
</dd>
<dt id="mici.matrices.Matrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L105-L108" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def array(self):
    &#34;&#34;&#34;Full dense representation of matrix as a 2D array.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.matrices.Matrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L146-L149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def T(self):
    &#34;&#34;&#34;Transpose of matrix.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.matrices.Matrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L151-L154" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def diagonal(self):
    &#34;&#34;&#34;Diagonal of matrix as a 1D array.&#34;&#34;&#34;
    return self.array.diagonal()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.ExplicitArrayMatrix"><code class="flex name class">
<span>class <span class="ident">ExplicitArrayMatrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix with an explicit array representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L200-L222" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ExplicitArrayMatrix(Matrix):
    &#34;&#34;&#34;Matrix with an explicit array representation.&#34;&#34;&#34;

    def __init__(self, shape, **kwargs):
        if &#39;_array&#39; not in kwargs:
            raise ValueError(&#39;_array must be specified in kwargs&#39;)
        super().__init__(shape, **kwargs)

    @property
    def array(self):
        return self._array

    def _left_matrix_multiply(self, other):
        return self._array @ other

    def _right_matrix_multiply(self, other):
        return other @ self._array

    def _compute_hash(self):
        return hash_array(self._array)

    def _check_equality(self, other):
        return np.array_equal(self.array, other.array)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix">TriangularMatrix</a></li>
<li><a title="mici.matrices.DenseDefiniteMatrix" href="#mici.matrices.DenseDefiniteMatrix">DenseDefiniteMatrix</a></li>
<li><a title="mici.matrices.DenseSquareMatrix" href="#mici.matrices.DenseSquareMatrix">DenseSquareMatrix</a></li>
<li><a title="mici.matrices.DenseSymmetricMatrix" href="#mici.matrices.DenseSymmetricMatrix">DenseSymmetricMatrix</a></li>
<li><a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix">OrthogonalMatrix</a></li>
<li><a title="mici.matrices.DenseRectangularMatrix" href="#mici.matrices.DenseRectangularMatrix">DenseRectangularMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.ExplicitArrayMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L208-L210" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def array(self):
    return self._array</code></pre>
</details>
</dd>
<dt id="mici.matrices.ExplicitArrayMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.ExplicitArrayMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.ExplicitArrayMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.ImplicitArrayMatrix"><code class="flex name class">
<span>class <span class="ident">ImplicitArrayMatrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix with an implicit array representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L225-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ImplicitArrayMatrix(Matrix):
    &#34;&#34;&#34;Matrix with an implicit array representation.&#34;&#34;&#34;

    def __init__(self, shape, **kwargs):
        &#34;&#34;&#34;
        Args:
           shape (Tuple[int, int]): Shape of matrix `(num_rows, num_columns)`.
        &#34;&#34;&#34;
        super().__init__(shape, **kwargs)
        self._array = None

    @property
    def array(self):
        &#34;&#34;&#34;Full dense representation of matrix as a 2D array.

        Generally accessing this property should be avoided wherever possible
        as the resulting array object may use a lot of memory and operations
        with it will not be able to exploit any structure in the matrix.
        &#34;&#34;&#34;
        if self._array is None:
            self._array = self._construct_array()
        return self._array

    @abc.abstractmethod
    def _construct_array(self):
        &#34;&#34;&#34;Construct full dense representation of matrix as a 2D array.

        Generally calling this method should be avoided wherever possible as
        the returned array object may use a lot of memory and operations with
        it will not be able to exploit any structure in the matrix.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.MatrixProduct" href="#mici.matrices.MatrixProduct">MatrixProduct</a></li>
<li><a title="mici.matrices.IdentityMatrix" href="#mici.matrices.IdentityMatrix">IdentityMatrix</a></li>
<li><a title="mici.matrices.ScaledIdentityMatrix" href="#mici.matrices.ScaledIdentityMatrix">ScaledIdentityMatrix</a></li>
<li><a title="mici.matrices.DiagonalMatrix" href="#mici.matrices.DiagonalMatrix">DiagonalMatrix</a></li>
<li><a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix">InverseTriangularMatrix</a></li>
<li><a title="mici.matrices.TriangularFactoredDefiniteMatrix" href="#mici.matrices.TriangularFactoredDefiniteMatrix">TriangularFactoredDefiniteMatrix</a></li>
<li><a title="mici.matrices.InverseLUFactoredSquareMatrix" href="#mici.matrices.InverseLUFactoredSquareMatrix">InverseLUFactoredSquareMatrix</a></li>
<li><a title="mici.matrices.ScaledOrthogonalMatrix" href="#mici.matrices.ScaledOrthogonalMatrix">ScaledOrthogonalMatrix</a></li>
<li><a title="mici.matrices.EigendecomposedSymmetricMatrix" href="#mici.matrices.EigendecomposedSymmetricMatrix">EigendecomposedSymmetricMatrix</a></li>
<li><a title="mici.matrices.BlockMatrix" href="#mici.matrices.BlockMatrix">BlockMatrix</a></li>
<li><a title="mici.matrices.SquareLowRankUpdateMatrix" href="#mici.matrices.SquareLowRankUpdateMatrix">SquareLowRankUpdateMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.ImplicitArrayMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p>
<p>Generally accessing this property should be avoided wherever possible
as the resulting array object may use a lot of memory and operations
with it will not be able to exploit any structure in the matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L236-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def array(self):
    &#34;&#34;&#34;Full dense representation of matrix as a 2D array.

    Generally accessing this property should be avoided wherever possible
    as the resulting array object may use a lot of memory and operations
    with it will not be able to exploit any structure in the matrix.
    &#34;&#34;&#34;
    if self._array is None:
        self._array = self._construct_array()
    return self._array</code></pre>
</details>
</dd>
<dt id="mici.matrices.ImplicitArrayMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.ImplicitArrayMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.ImplicitArrayMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.MatrixProduct"><code class="flex name class">
<span>class <span class="ident">MatrixProduct</span></span>
<span>(</span><span>matrices, check_shapes=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix implicitly defined as a product of a sequence of matrices.</p>
<p>Each adjacent pair of matrices in the sequence must have compatible shapes.</p>
<h2 id="args">Args</h2>
<dl>
<dt>matrices(Iterable[Matrix]): Sequence of matrices forming product in</dt>
<dt>left-to-right order.</dt>
<dt><strong><code>check_shapes</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to check if all successive pairs of
the matrix sequence have compatible shapes, i.e. equal inner
dimensions.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L258-L317" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MatrixProduct(ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix implicitly defined as a product of a sequence of matrices.

    Each adjacent pair of matrices in the sequence must have compatible shapes.
    &#34;&#34;&#34;

    def __init__(self, matrices, check_shapes=True):
        &#34;&#34;&#34;
        Args:
            matrices(Iterable[Matrix]): Sequence of matrices forming product in
                left-to-right order.
            check_shapes (boolean): Whether to check if all successive pairs of
                the matrix sequence have compatible shapes, i.e. equal inner
                dimensions.
        &#34;&#34;&#34;
        self._matrices = tuple(matrices)
        if check_shapes:
            for matrix_l, matrix_r in zip(matrices[:-1], matrices[1:]):
                if matrix_l.shape[1] != matrix_r.shape[0]:
                    raise ValueError(
                        f&#39;Matrices {matrix_l} and {matrix_r} have inconsistent&#39;
                        f&#39; inner dimensions for forming a matrix product.&#39;)
        super().__init__((self._matrices[0].shape[0],
                          self._matrices[-1].shape[1]))

    @property
    def matrices(self):
        return self._matrices

    def _scalar_multiply(self, scalar):
        return type(self)((
            ScaledIdentityMatrix(scalar, self.shape[0]), *self.matrices))

    def _left_matrix_multiply(self, other):
        for matrix in reversed(self.matrices):
            other = matrix @ other
        return other

    def _right_matrix_multiply(self, other):
        for matrix in self.matrices:
            other = other @ matrix
        return other

    @property
    def T(self):
        return type(self)(
            tuple(matrix.T for matrix in reversed(self.matrices)))

    def _construct_array(self):
        return self.matrices[0].array @ MatrixProduct(self.matrices[1:])

    def _compute_hash(self):
        return hash(tuple(matrix for matrix in self.matrices))

    def _check_equality(self, other):
        return (
            len(other.matrices) == len(self.matrices) and
            all(matrix_s == matrix_o for matrix_s, matrix_o
                in zip(self.matrices, other.matrices))
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.SquareMatrixProduct" href="#mici.matrices.SquareMatrixProduct">SquareMatrixProduct</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.MatrixProduct.matrices"><code class="name">var <span class="ident">matrices</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L283-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def matrices(self):
    return self._matrices</code></pre>
</details>
</dd>
<dt id="mici.matrices.MatrixProduct.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L301-L304" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return type(self)(
        tuple(matrix.T for matrix in reversed(self.matrices)))</code></pre>
</details>
</dd>
<dt id="mici.matrices.MatrixProduct.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p>
<p>Generally accessing this property should be avoided wherever possible
as the resulting array object may use a lot of memory and operations
with it will not be able to exploit any structure in the matrix.</p></section>
</dd>
<dt id="mici.matrices.MatrixProduct.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.MatrixProduct.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.SquareMatrix"><code class="flex name class">
<span>class <span class="ident">SquareMatrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for matrices with equal numbers of rows and columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L320-L339" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SquareMatrix(Matrix):
    &#34;&#34;&#34;Base class for matrices with equal numbers of rows and columns.&#34;&#34;&#34;

    _required_subclass_attrs = {&#39;log_abs_det&#39;}

    def __init__(self, shape, **kwargs):
        if shape[0] != shape[1]:
            raise ValueError(
                f&#39;{shape} is not a valid shape for a square matrix.&#39;)
        super().__init__(shape, **kwargs)

    @property
    @abc.abstractmethod
    def log_abs_det(self):
        &#34;&#34;&#34;Logarithm of absolute value of determinant of matrix.

        For matrix representations of metrics it is proportional to the
        logarithm of the density of then Riemannian measure associated with
        metric with respect to the Lebesgue measure.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.SquareMatrixProduct" href="#mici.matrices.SquareMatrixProduct">SquareMatrixProduct</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.SquareMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L331-L339" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def log_abs_det(self):
    &#34;&#34;&#34;Logarithm of absolute value of determinant of matrix.

    For matrix representations of metrics it is proportional to the
    logarithm of the density of then Riemannian measure associated with
    metric with respect to the Lebesgue measure.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.SquareMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.SquareMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.SquareMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.SquareMatrixProduct"><code class="flex name class">
<span>class <span class="ident">SquareMatrixProduct</span></span>
<span>(</span><span>matrices, check_shapes=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix implicitly defined as a product of a sequence of square matrices.</p>
<p>All the matrices must have the same shape.</p>
<h2 id="args">Args</h2>
<dl>
<dt>matrices(Iterable[Matrix]): Sequence of matrices forming product in</dt>
<dt>left-to-right order.</dt>
<dt><strong><code>check_shapes</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to check if all successive pairs of
the matrix sequence have compatible shapes, i.e. equal inner
dimensions.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L342-L361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SquareMatrixProduct(MatrixProduct, SquareMatrix):
    &#34;&#34;&#34;Matrix implicitly defined as a product of a sequence of square matrices.

    All the matrices must have the same shape.
    &#34;&#34;&#34;

    def __init__(self, matrices, check_shapes=True):
        matrices = tuple(matrices)
        if check_shapes:
            if matrices[0].shape[0] != matrices[0].shape[1]:
                raise ValueError(f&#39;{matrix} is not square.&#39;)
            for matrix in matrices[1:]:
                if matrix.shape != matrices[0].shape:
                    raise ValueError(
                        f&#39;{matrices[0]} and {matrix} have different shapes.&#39;)
        super().__init__(matrices, check_shapes=False)

    @property
    def log_abs_det(self):
        return sum(matrix.log_abs_det for matrix in self.matrices)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.MatrixProduct" href="#mici.matrices.MatrixProduct">MatrixProduct</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrixProduct" href="#mici.matrices.InvertibleMatrixProduct">InvertibleMatrixProduct</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.SquareMatrixProduct.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L359-L361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return sum(matrix.log_abs_det for matrix in self.matrices)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareMatrixProduct.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.SquareMatrixProduct.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p>
<p>Generally accessing this property should be avoided wherever possible
as the resulting array object may use a lot of memory and operations
with it will not be able to exploit any structure in the matrix.</p></section>
</dd>
<dt id="mici.matrices.SquareMatrixProduct.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.SquareMatrixProduct.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.InvertibleMatrix"><code class="flex name class">
<span>class <span class="ident">InvertibleMatrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for non-singular square matrices.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L364-L378" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InvertibleMatrix(SquareMatrix):
    &#34;&#34;&#34;Base class for non-singular square matrices.&#34;&#34;&#34;

    _required_subclass_attrs = {&#39;inv&#39;}

    @property
    @abc.abstractmethod
    def inv(self):
        &#34;&#34;&#34;Inverse of matrix as a `Matrix` object.

        This will not necessarily form an explicit representation of the
        inverse matrix but may instead return a `Matrix` object that implements
        the matrix multiplication operators by solving the linear system
        defined by the original matrix object.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrixProduct" href="#mici.matrices.InvertibleMatrixProduct">InvertibleMatrixProduct</a></li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix">TriangularMatrix</a></li>
<li><a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix">InverseTriangularMatrix</a></li>
<li>mici.matrices._BaseTriangularFactoredDefiniteMatrix</li>
<li><a title="mici.matrices.DenseSquareMatrix" href="#mici.matrices.DenseSquareMatrix">DenseSquareMatrix</a></li>
<li><a title="mici.matrices.InverseLUFactoredSquareMatrix" href="#mici.matrices.InverseLUFactoredSquareMatrix">InverseLUFactoredSquareMatrix</a></li>
<li><a title="mici.matrices.DenseSymmetricMatrix" href="#mici.matrices.DenseSymmetricMatrix">DenseSymmetricMatrix</a></li>
<li><a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix">OrthogonalMatrix</a></li>
<li><a title="mici.matrices.ScaledOrthogonalMatrix" href="#mici.matrices.ScaledOrthogonalMatrix">ScaledOrthogonalMatrix</a></li>
<li><a title="mici.matrices.EigendecomposedSymmetricMatrix" href="#mici.matrices.EigendecomposedSymmetricMatrix">EigendecomposedSymmetricMatrix</a></li>
<li><a title="mici.matrices.SquareBlockDiagonalMatrix" href="#mici.matrices.SquareBlockDiagonalMatrix">SquareBlockDiagonalMatrix</a></li>
<li><a title="mici.matrices.SquareLowRankUpdateMatrix" href="#mici.matrices.SquareLowRankUpdateMatrix">SquareLowRankUpdateMatrix</a></li>
<li><a title="mici.matrices.SymmetricLowRankUpdateMatrix" href="#mici.matrices.SymmetricLowRankUpdateMatrix">SymmetricLowRankUpdateMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.InvertibleMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L369-L378" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def inv(self):
    &#34;&#34;&#34;Inverse of matrix as a `Matrix` object.

    This will not necessarily form an explicit representation of the
    inverse matrix but may instead return a `Matrix` object that implements
    the matrix multiplication operators by solving the linear system
    defined by the original matrix object.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.matrices.InvertibleMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.InvertibleMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.InvertibleMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.InvertibleMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.InvertibleMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.InvertibleMatrixProduct"><code class="flex name class">
<span>class <span class="ident">InvertibleMatrixProduct</span></span>
<span>(</span><span>matrices, check_shapes=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix defined as a product of a sequence of invertible matrices.</p>
<p>All the matrices must have the same shape.</p>
<h2 id="args">Args</h2>
<dl>
<dt>matrices(Iterable[Matrix]): Sequence of matrices forming product in</dt>
<dt>left-to-right order.</dt>
<dt><strong><code>check_shapes</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to check if all successive pairs of
the matrix sequence have compatible shapes, i.e. equal inner
dimensions.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L381-L397" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InvertibleMatrixProduct(SquareMatrixProduct, InvertibleMatrix):
    &#34;&#34;&#34;Matrix defined as a product of a sequence of invertible matrices.

    All the matrices must have the same shape.
    &#34;&#34;&#34;

    def __init__(self, matrices, check_shapes=True):
        matrices = tuple(matrices)
        for matrix in matrices:
            if not isinstance(matrix, InvertibleMatrix):
                raise ValueError(f&#39;matrix {matrix} is not invertible.&#39;)
        super().__init__(matrices, check_shapes)

    @property
    def inv(self):
        return InvertibleMatrixProduct(
            tuple(matrix.inv for matrix in reversed(self.matrices)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SquareMatrixProduct" href="#mici.matrices.SquareMatrixProduct">SquareMatrixProduct</a></li>
<li><a title="mici.matrices.MatrixProduct" href="#mici.matrices.MatrixProduct">MatrixProduct</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.InvertibleMatrixProduct.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L394-L397" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return InvertibleMatrixProduct(
        tuple(matrix.inv for matrix in reversed(self.matrices)))</code></pre>
</details>
</dd>
<dt id="mici.matrices.InvertibleMatrixProduct.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.InvertibleMatrixProduct.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.InvertibleMatrixProduct.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p>
<p>Generally accessing this property should be avoided wherever possible
as the resulting array object may use a lot of memory and operations
with it will not be able to exploit any structure in the matrix.</p></section>
</dd>
<dt id="mici.matrices.InvertibleMatrixProduct.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.InvertibleMatrixProduct.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.SymmetricMatrix"><code class="flex name class">
<span>class <span class="ident">SymmetricMatrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for square matrices which are equal to their transpose.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L400-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SymmetricMatrix(SquareMatrix):
    &#34;&#34;&#34;Base class for square matrices which are equal to their transpose.&#34;&#34;&#34;

    _required_subclass_attrs = {&#39;eigval&#39;, &#39;eigvec&#39;}

    def __init__(self, shape, **kwargs):
        self._eigval = None
        self._eigvec = None
        super().__init__(shape, **kwargs)

    def _compute_eigendecomposition(self):
        self._eigval, eigvec = nla.eigh(self.array)
        self._eigvec = OrthogonalMatrix(eigvec)

    @property
    def eigval(self):
        &#34;&#34;&#34;Eigenvalues of matrix as a 1D array.&#34;&#34;&#34;
        if self._eigval is None or self._eigvec is None:
            self._compute_eigendecomposition()
        return self._eigval

    @property
    def eigvec(self):
        &#34;&#34;&#34;Eigenvectors of matrix stacked as columns of a `Matrix` object.&#34;&#34;&#34;
        if self._eigval is None or self._eigvec is None:
            self._compute_eigendecomposition()
        return self._eigvec

    @property
    def T(self):
        return self

    @property
    def log_abs_det(self):
        return np.log(np.abs(self.eigval)).sum()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.ScaledIdentityMatrix" href="#mici.matrices.ScaledIdentityMatrix">ScaledIdentityMatrix</a></li>
<li><a title="mici.matrices.DiagonalMatrix" href="#mici.matrices.DiagonalMatrix">DiagonalMatrix</a></li>
<li>mici.matrices._BaseTriangularFactoredDefiniteMatrix</li>
<li><a title="mici.matrices.DenseSymmetricMatrix" href="#mici.matrices.DenseSymmetricMatrix">DenseSymmetricMatrix</a></li>
<li><a title="mici.matrices.EigendecomposedSymmetricMatrix" href="#mici.matrices.EigendecomposedSymmetricMatrix">EigendecomposedSymmetricMatrix</a></li>
<li><a title="mici.matrices.SymmetricLowRankUpdateMatrix" href="#mici.matrices.SymmetricLowRankUpdateMatrix">SymmetricLowRankUpdateMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.SymmetricMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L414-L419" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigval(self):
    &#34;&#34;&#34;Eigenvalues of matrix as a 1D array.&#34;&#34;&#34;
    if self._eigval is None or self._eigvec is None:
        self._compute_eigendecomposition()
    return self._eigval</code></pre>
</details>
</dd>
<dt id="mici.matrices.SymmetricMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L421-L426" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigvec(self):
    &#34;&#34;&#34;Eigenvectors of matrix stacked as columns of a `Matrix` object.&#34;&#34;&#34;
    if self._eigval is None or self._eigvec is None:
        self._compute_eigendecomposition()
    return self._eigvec</code></pre>
</details>
</dd>
<dt id="mici.matrices.SymmetricMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L428-L430" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return self</code></pre>
</details>
</dd>
<dt id="mici.matrices.SymmetricMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L432-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return np.log(np.abs(self.eigval)).sum()</code></pre>
</details>
</dd>
<dt id="mici.matrices.SymmetricMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.SymmetricMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.SymmetricMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix"><code class="flex name class">
<span>class <span class="ident">PositiveDefiniteMatrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for positive definite matrices.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L437-L450" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PositiveDefiniteMatrix(SymmetricMatrix, InvertibleMatrix):
    &#34;&#34;&#34;Base class for positive definite matrices.&#34;&#34;&#34;

    _required_subclass_attrs = {&#39;sqrt&#39;}

    @property
    @abc.abstractmethod
    def sqrt(self):
        &#34;&#34;&#34;Square-root of matrix satisfying `matrix == sqrt @ sqrt.T`.

        This will in general not correspond to the unique, if defined,
        symmetric square root of a symmetric matrix but instead may return any
        matrix satisfying the above property.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.IdentityMatrix" href="#mici.matrices.IdentityMatrix">IdentityMatrix</a></li>
<li><a title="mici.matrices.PositiveScaledIdentityMatrix" href="#mici.matrices.PositiveScaledIdentityMatrix">PositiveScaledIdentityMatrix</a></li>
<li><a title="mici.matrices.PositiveDiagonalMatrix" href="#mici.matrices.PositiveDiagonalMatrix">PositiveDiagonalMatrix</a></li>
<li><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix">TriangularFactoredPositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.DensePositiveDefiniteMatrix" href="#mici.matrices.DensePositiveDefiniteMatrix">DensePositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix">EigendecomposedPositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix">PositiveDefiniteBlockDiagonalMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix">PositiveDefiniteLowRankUpdateMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.PositiveDefiniteMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L442-L450" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def sqrt(self):
    &#34;&#34;&#34;Square-root of matrix satisfying `matrix == sqrt @ sqrt.T`.

    This will in general not correspond to the unique, if defined,
    symmetric square root of a symmetric matrix but instead may return any
    matrix satisfying the above property.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.IdentityMatrix"><code class="flex name class">
<span>class <span class="ident">IdentityMatrix</span></span>
<span>(</span><span>size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix representing identity operator on a vector space.</p>
<p>Array representation has ones on diagonal elements and zeros elsewhere.
May be defined with an implicit shape represented by <code>(None, None)</code> which
will allow use for subset of operations where shape is not required to be
known.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Number of rows / columns in matrix or <code>None</code> if
matrix is to be implicitly shaped.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L453-L518" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IdentityMatrix(PositiveDefiniteMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix representing identity operator on a vector space.

    Array representation has ones on diagonal elements and zeros elsewhere.
    May be defined with an implicit shape represented by `(None, None)` which
    will allow use for subset of operations where shape is not required to be
    known.
    &#34;&#34;&#34;

    def __init__(self, size=None):
        &#34;&#34;&#34;
        Args:
            size (int or None): Number of rows / columns in matrix or `None` if
                matrix is to be implicitly shaped.
        &#34;&#34;&#34;
        super().__init__((size, size))

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveScaledIdentityMatrix(
                scalar, self.shape[0])
        else:
            return ScaledIdentityMatrix(scalar, self.shape[0])

    def _left_matrix_multiply(self, other):
        return other

    def _right_matrix_multiply(self, other):
        return other

    @property
    def eigval(self):
        return self.diagonal

    @property
    def sqrt(self):
        return self

    @property
    def eigvec(self):
        return self

    @property
    def inv(self):
        return self

    @property
    def diagonal(self):
        return np.ones(self.shape[0])

    def _construct_array(self):
        if self.shape[0] is None:
            raise RuntimeError(
                &#39;Cannot get array representation for identity matrix with &#39;
                &#39;implicit size.&#39;)
        return np.identity(self.shape[0])

    @property
    def log_abs_det(self):
        return 0.

    def _compute_hash(self):
        return hash(self.shape)

    def _check_equality(self, other):
        return self.shape == other.shape</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.IdentityMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L483-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigval(self):
    return self.diagonal</code></pre>
</details>
</dd>
<dt id="mici.matrices.IdentityMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L487-L489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    return self</code></pre>
</details>
</dd>
<dt id="mici.matrices.IdentityMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L491-L493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigvec(self):
    return self</code></pre>
</details>
</dd>
<dt id="mici.matrices.IdentityMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L495-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return self</code></pre>
</details>
</dd>
<dt id="mici.matrices.IdentityMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L499-L501" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def diagonal(self):
    return np.ones(self.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.matrices.IdentityMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L510-L512" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return 0.</code></pre>
</details>
</dd>
<dt id="mici.matrices.IdentityMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.IdentityMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.IdentityMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.DifferentiableMatrix"><code class="flex name class">
<span>class <span class="ident">DifferentiableMatrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Parameterically defined matrix defining gradient of scalar operations.</p>
<p>Parameterically-defined here means the matrix is constructed as a function
of one or more parameters, with the convention that the parameters
correspond to <strong>the first parameter in the <code>__init__</code> method of the
<a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix"><code>DifferentiableMatrix</code></a> subclass</strong>, with multiple parameters wrapped in to
for example a tuple, dict or list.</p>
<p>The gradient is defined for the scalar functions of the matrix parameters
implemented by the method <code>log_abs_det</code>, corresponding to</p>
<pre><code>f(params) = log(abs(det(matrix(params))))
</code></pre>
<p>and by the quadratic form <code>vector @ matrix(params).inv @ vector</code>.</p>
<p>In both cases the gradients are with respect to the parameter(s). The
returned gradients will have the same structure as the first parameter of
the <code>__init__</code> method of the relevant <a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix"><code>DifferentiableMatrix</code></a> subclass,
for example if the first parameter is a tuple or dict of arrays then the
returned gradients will be respectively a tuple or dict of arrays of the
same shapes and with the same indices / keys.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L521-L559" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DifferentiableMatrix(InvertibleMatrix):
    &#34;&#34;&#34;Parameterically defined matrix defining gradient of scalar operations.

    Parameterically-defined here means the matrix is constructed as a function
    of one or more parameters, with the convention that the parameters
    correspond to **the first parameter in the `__init__` method of the
    `DifferentiableMatrix` subclass**, with multiple parameters wrapped in to
    for example a tuple, dict or list.

    The gradient is defined for the scalar functions of the matrix parameters
    implemented by the method `log_abs_det`, corresponding to

        f(params) = log(abs(det(matrix(params))))

    and by the quadratic form `vector @ matrix(params).inv @ vector`.

    In both cases the gradients are with respect to the parameter(s). The
    returned gradients will have the same structure as the first parameter of
    the `__init__` method of the relevant `DifferentiableMatrix` subclass,
    for example if the first parameter is a tuple or dict of arrays then the
    returned gradients will be respectively a tuple or dict of arrays of the
    same shapes and with the same indices / keys.
    &#34;&#34;&#34;

    _required_subclass_attrs = {&#39;grad_log_abs_det&#39;, &#39;grad_quadratic_form_inv&#39;}

    @property
    @abc.abstractmethod
    def grad_log_abs_det(self):
        &#34;&#34;&#34;Gradient of logarithm of absolute value of determinant of matrix.&#34;&#34;&#34;

    @abc.abstractmethod
    def grad_quadratic_form_inv(self, vector):
        &#34;&#34;&#34;Gradient of quadratic form `vector @ matrix.inv @ vector`.

        Args:
            vector (array): 1D array representing vector to evaluate quadratic
                form at.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.ScaledIdentityMatrix" href="#mici.matrices.ScaledIdentityMatrix">ScaledIdentityMatrix</a></li>
<li><a title="mici.matrices.DiagonalMatrix" href="#mici.matrices.DiagonalMatrix">DiagonalMatrix</a></li>
<li><a title="mici.matrices.TriangularFactoredDefiniteMatrix" href="#mici.matrices.TriangularFactoredDefiniteMatrix">TriangularFactoredDefiniteMatrix</a></li>
<li><a title="mici.matrices.DenseDefiniteMatrix" href="#mici.matrices.DenseDefiniteMatrix">DenseDefiniteMatrix</a></li>
<li><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix">SoftAbsRegularisedPositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix">PositiveDefiniteBlockDiagonalMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix">PositiveDefiniteLowRankUpdateMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.DifferentiableMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L547-L550" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def grad_log_abs_det(self):
    &#34;&#34;&#34;Gradient of logarithm of absolute value of determinant of matrix.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.matrices.DifferentiableMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
<dt id="mici.matrices.DifferentiableMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.DifferentiableMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.DifferentiableMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.DifferentiableMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.DifferentiableMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.DifferentiableMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L552-L559" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def grad_quadratic_form_inv(self, vector):
    &#34;&#34;&#34;Gradient of quadratic form `vector @ matrix.inv @ vector`.

    Args:
        vector (array): 1D array representing vector to evaluate quadratic
            form at.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix"><code class="flex name class">
<span>class <span class="ident">ScaledIdentityMatrix</span></span>
<span>(</span><span>scalar, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix representing scalar multiplication operation on a vector space.</p>
<p>Array representation has common scalar on diagonal elements and zeros
elsewhere. May be defined with an implicit shape reprsented by
<code>(None, None)</code> which will allow use for subset of operations where shape
is not required to be known.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scalar</code></strong> :&ensp;<code>float</code></dt>
<dd>Scalar multiplier for identity matrix.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of rows / columns in matrix. If <code>None</code> the
matrix will be implicitly-shaped and only the subset of
operations which do not rely on an explicit shape will be
available.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L562-L645" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ScaledIdentityMatrix(
        SymmetricMatrix, DifferentiableMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix representing scalar multiplication operation on a vector space.

    Array representation has common scalar on diagonal elements and zeros
    elsewhere. May be defined with an implicit shape reprsented by
    `(None, None)` which will allow use for subset of operations where shape
    is not required to be known.
    &#34;&#34;&#34;

    def __init__(self, scalar, size=None):
        &#34;&#34;&#34;
        Args:
            scalar (float): Scalar multiplier for identity matrix.
            size (int): Number of rows / columns in matrix. If `None` the
                matrix will be implicitly-shaped and only the subset of
                operations which do not rely on an explicit shape will be
                available.
        &#34;&#34;&#34;
        if scalar == 0:
            raise ValueError(&#39;scalar must be non-zero&#39;)
        self._scalar = scalar
        super().__init__((size, size))

    @property
    def scalar(self):
        &#34;&#34;&#34;Scalar multiplier.&#34;&#34;&#34;
        return self._scalar

    def _scalar_multiply(self, scalar):
        return ScaledIdentityMatrix(scalar * self._scalar, self.shape[0])

    def _left_matrix_multiply(self, other):
        return self._scalar * other

    def _right_matrix_multiply(self, other):
        return self._scalar * other

    @property
    def eigval(self):
        return self.diagonal

    @property
    def eigvec(self):
        return IdentityMatrix(self.shape[0])

    @property
    def inv(self):
        return ScaledIdentityMatrix(1 / self._scalar, self.shape[0])

    @property
    def diagonal(self):
        return self._scalar * np.ones(self.shape[0])

    def _construct_array(self):
        if self.shape[0] is None:
            raise RuntimeError(
                &#39;Cannot get array representation for scaled identity matrix &#39;
                &#39;with implicit size.&#39;)
        return self._scalar * np.identity(self.shape[0])

    @property
    def log_abs_det(self):
        if self.shape[0] is None:
            raise RuntimeError(
                &#39;Cannot get log determinant for scaled identity matrix with &#39;
                &#39;implicit size.&#39;)
        return self.shape[0] * np.log(abs(self._scalar))

    @property
    def grad_log_abs_det(self):
        return self.shape[0] / self._scalar

    def grad_quadratic_form_inv(self, vector):
        return -np.sum(vector**2) / self._scalar**2

    def __str__(self):
        return f&#39;(shape={self.shape}, scalar={self._scalar})&#39;

    def _compute_hash(self):
        return hash((self.shape, self.scalar))

    def _check_equality(self, other):
        return self.shape == other.shape and self.scalar == other.scalar</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.PositiveScaledIdentityMatrix" href="#mici.matrices.PositiveScaledIdentityMatrix">PositiveScaledIdentityMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.ScaledIdentityMatrix.scalar"><code class="name">var <span class="ident">scalar</span></code></dt>
<dd>
<section class="desc"><p>Scalar multiplier.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L586-L589" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def scalar(self):
    &#34;&#34;&#34;Scalar multiplier.&#34;&#34;&#34;
    return self._scalar</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L600-L602" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigval(self):
    return self.diagonal</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L604-L606" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigvec(self):
    return IdentityMatrix(self.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L608-L610" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return ScaledIdentityMatrix(1 / self._scalar, self.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L612-L614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def diagonal(self):
    return self._scalar * np.ones(self.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L623-L629" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    if self.shape[0] is None:
        raise RuntimeError(
            &#39;Cannot get log determinant for scaled identity matrix with &#39;
            &#39;implicit size.&#39;)
    return self.shape[0] * np.log(abs(self._scalar))</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L631-L633" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def grad_log_abs_det(self):
    return self.shape[0] / self._scalar</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.ScaledIdentityMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.ScaledIdentityMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L635-L636" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_quadratic_form_inv(self, vector):
    return -np.sum(vector**2) / self._scalar**2</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix"><code class="flex name class">
<span>class <span class="ident">PositiveScaledIdentityMatrix</span></span>
<span>(</span><span>scalar, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Specialisation of <a title="mici.matrices.ScaledIdentityMatrix" href="#mici.matrices.ScaledIdentityMatrix"><code>ScaledIdentityMatrix</code></a> with positive scalar parameter.</p>
<p>Restricts the <code>scalar</code> parameter to be strictly positive.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scalar</code></strong> :&ensp;<code>float</code></dt>
<dd>Scalar multiplier for identity matrix.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of rows / columns in matrix. If <code>None</code> the
matrix will be implicitly-shaped and only the subset of
operations which do not rely on an explicit shape will be
available.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L648-L673" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PositiveScaledIdentityMatrix(
        ScaledIdentityMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Specialisation of `ScaledIdentityMatrix` with positive scalar parameter.

    Restricts the `scalar` parameter to be strictly positive.
    &#34;&#34;&#34;

    def __init__(self, scalar, size=None):
        if scalar &lt;= 0:
            raise ValueError(&#39;Scalar multiplier must be positive.&#39;)
        super().__init__(scalar, size)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveScaledIdentityMatrix(
                scalar * self._scalar, self.shape[0])
        else:
            return super()._scalar_multiply(scalar)

    @property
    def inv(self):
        return PositiveScaledIdentityMatrix(1 / self._scalar, self.shape[0])

    @property
    def sqrt(self):
        return PositiveScaledIdentityMatrix(self._scalar**0.5, self.shape[0])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.ScaledIdentityMatrix" href="#mici.matrices.ScaledIdentityMatrix">ScaledIdentityMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L667-L669" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return PositiveScaledIdentityMatrix(1 / self._scalar, self.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L671-L673" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    return PositiveScaledIdentityMatrix(self._scalar**0.5, self.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.scalar"><code class="name">var <span class="ident">scalar</span></code></dt>
<dd>
<section class="desc"><p>Scalar multiplier.</p></section>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.PositiveScaledIdentityMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.DiagonalMatrix"><code class="flex name class">
<span>class <span class="ident">DiagonalMatrix</span></span>
<span>(</span><span>diagonal)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix with non-zero elements only along its diagonal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>diagonal</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array specifying diagonal elements of matrix.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L676-L735" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DiagonalMatrix(
        SymmetricMatrix, DifferentiableMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix with non-zero elements only along its diagonal.&#34;&#34;&#34;

    def __init__(self, diagonal):
        &#34;&#34;&#34;
        Args:
            diagonal (array): 1D array specifying diagonal elements of matrix.
        &#34;&#34;&#34;
        if diagonal.ndim != 1:
            raise ValueError(&#39;Specified diagonal must be a 1D array.&#39;)
        super().__init__((diagonal.size, diagonal.size), _diagonal=diagonal)

    @property
    def diagonal(self):
        return self._diagonal

    def _scalar_multiply(self, scalar):
        return DiagonalMatrix(self.diagonal * scalar)

    def _left_matrix_multiply(self, other):
        if other.ndim == 2:
            return self.diagonal[:, None] * other
        elif other.ndim == 1:
            return self.diagonal * other
        else:
            raise ValueError(
                &#39;Left matrix multiplication only defined for one or two &#39;
                &#39;dimensional right hand sides.&#39;)

    def _right_matrix_multiply(self, other):
        return self.diagonal * other

    @property
    def eigvec(self):
        return IdentityMatrix(self.shape[0])

    @property
    def eigval(self):
        return self.diagonal

    @property
    def inv(self):
        return DiagonalMatrix(1. / self.diagonal)

    def _construct_array(self):
        return np.diag(self.diagonal)

    @property
    def grad_log_abs_det(self):
        return 1. / self.diagonal

    def grad_quadratic_form_inv(self, vector):
        return -(self.inv @ vector)**2

    def _compute_hash(self):
        return hash_array(self.diagonal)

    def _check_equality(self, other):
        return np.array_equal(self.diagonal, other.diagonal)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.PositiveDiagonalMatrix" href="#mici.matrices.PositiveDiagonalMatrix">PositiveDiagonalMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.DiagonalMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L689-L691" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def diagonal(self):
    return self._diagonal</code></pre>
</details>
</dd>
<dt id="mici.matrices.DiagonalMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L709-L711" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigvec(self):
    return IdentityMatrix(self.shape[0])</code></pre>
</details>
</dd>
<dt id="mici.matrices.DiagonalMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L713-L715" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigval(self):
    return self.diagonal</code></pre>
</details>
</dd>
<dt id="mici.matrices.DiagonalMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L717-L719" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return DiagonalMatrix(1. / self.diagonal)</code></pre>
</details>
</dd>
<dt id="mici.matrices.DiagonalMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L724-L726" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def grad_log_abs_det(self):
    return 1. / self.diagonal</code></pre>
</details>
</dd>
<dt id="mici.matrices.DiagonalMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.DiagonalMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.DiagonalMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.DiagonalMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.DiagonalMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L728-L729" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_quadratic_form_inv(self, vector):
    return -(self.inv @ vector)**2</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix"><code class="flex name class">
<span>class <span class="ident">PositiveDiagonalMatrix</span></span>
<span>(</span><span>diagonal)</span>
</code></dt>
<dd>
<section class="desc"><p>Specialisation of <a title="mici.matrices.DiagonalMatrix" href="#mici.matrices.DiagonalMatrix"><code>DiagonalMatrix</code></a> with positive diagonal parameter.</p>
<p>Restricts all values in <code>diagonal</code> array parameter to be strictly positive.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>diagonal</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array specifying diagonal elements of matrix.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L738-L761" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PositiveDiagonalMatrix(DiagonalMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Specialisation of `DiagonalMatrix` with positive diagonal parameter.

    Restricts all values in `diagonal` array parameter to be strictly positive.
    &#34;&#34;&#34;

    def __init__(self, diagonal):
        if not np.all(diagonal &gt; 0):
            raise ValueError(&#39;Diagonal values must all be positive.&#39;)
        super().__init__(diagonal)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveDiagonalMatrix(self.diagonal * scalar)
        else:
            return super()._scalar_multiply(scalar)

    @property
    def inv(self):
        return PositiveDiagonalMatrix(1. / self.diagonal)

    @property
    def sqrt(self):
        return PositiveDiagonalMatrix(self.diagonal**0.5)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.DiagonalMatrix" href="#mici.matrices.DiagonalMatrix">DiagonalMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.PositiveDiagonalMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L755-L757" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return PositiveDiagonalMatrix(1. / self.diagonal)</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L759-L761" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    return PositiveDiagonalMatrix(self.diagonal**0.5)</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.PositiveDiagonalMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.PositiveDiagonalMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.TriangularMatrix"><code class="flex name class">
<span>class <span class="ident">TriangularMatrix</span></span>
<span>(</span><span>array, lower=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix with non-zero values only in lower or upper triangle elements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D array containing lower / upper triangular element
values of matrix. Any values above (below) diagonal are
ignored for lower (upper) triangular matrices i.e. when
<code>lower == True</code> (<code>lower == False</code>).</dd>
<dt><strong><code>lower</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the matrix is lower-triangular (<code>True</code>) or
upper-triangular (<code>False</code>).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L769-L806" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TriangularMatrix(InvertibleMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Matrix with non-zero values only in lower or upper triangle elements.&#34;&#34;&#34;

    def __init__(self, array, lower=True):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array containing lower / upper triangular element
                values of matrix. Any values above (below) diagonal are
                ignored for lower (upper) triangular matrices i.e. when
                `lower == True` (`lower == False`).
            lower (bool): Whether the matrix is lower-triangular (`True`) or
                upper-triangular (`False`).
        &#34;&#34;&#34;
        super().__init__(
            array.shape, _array=_make_array_triangular(array, lower))
        self._lower = lower

    def _scalar_multiply(self, scalar):
        return TriangularMatrix(self.array * scalar, self.lower)

    @property
    def lower(self):
        return self._lower

    @property
    def inv(self):
        return InverseTriangularMatrix(self.array, lower=self.lower)

    @property
    def T(self):
        return TriangularMatrix(self.array.T, lower=not self.lower)

    @property
    def log_abs_det(self):
        return np.log(np.abs(self.diagonal)).sum()

    def __str__(self):
        return f&#39;(shape={self.shape}, lower={self.lower})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.TriangularMatrix.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L789-L791" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def lower(self):
    return self._lower</code></pre>
</details>
</dd>
<dt id="mici.matrices.TriangularMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L793-L795" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return InverseTriangularMatrix(self.array, lower=self.lower)</code></pre>
</details>
</dd>
<dt id="mici.matrices.TriangularMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L797-L799" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return TriangularMatrix(self.array.T, lower=not self.lower)</code></pre>
</details>
</dd>
<dt id="mici.matrices.TriangularMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L801-L803" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return np.log(np.abs(self.diagonal)).sum()</code></pre>
</details>
</dd>
<dt id="mici.matrices.TriangularMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.TriangularMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.TriangularMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.InverseTriangularMatrix"><code class="flex name class">
<span>class <span class="ident">InverseTriangularMatrix</span></span>
<span>(</span><span>inverse_array, lower=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Triangular matrix implicitly specified by its inverse.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inverse_array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D containing values of <em>inverse</em> of this
matrix, with the inverse of a lower (upper) triangular matrix
being itself lower (upper) triangular. Any values above (below)
diagonal are ignored for lower (upper) triangular matrices i.e.
when <code>lower == True</code> (<code>lower == False</code>).</dd>
<dt><strong><code>lower</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the matrix is lower-triangular (<code>True</code>) or
upper-triangular (<code>False</code>).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L809-L871" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InverseTriangularMatrix(InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Triangular matrix implicitly specified by its inverse.&#34;&#34;&#34;

    def __init__(self, inverse_array, lower=True):
        &#34;&#34;&#34;
        Args:
            inverse_array (array): 2D containing values of *inverse* of this
                matrix, with the inverse of a lower (upper) triangular matrix
                being itself lower (upper) triangular. Any values above (below)
                diagonal are ignored for lower (upper) triangular matrices i.e.
                when `lower == True` (`lower == False`).
            lower (bool): Whether the matrix is lower-triangular (`True`) or
                upper-triangular (`False`).
        &#34;&#34;&#34;
        super().__init__(
            inverse_array.shape,
            _inverse_array=_make_array_triangular(inverse_array, lower))
        self._lower = lower

    def _scalar_multiply(self, scalar):
        return InverseTriangularMatrix(
            self._inverse_array / scalar, self.lower)

    def _left_matrix_multiply(self, other):
        return sla.solve_triangular(
            self._inverse_array, other, lower=self.lower)

    def _right_matrix_multiply(self, other):
        return sla.solve_triangular(
            self._inverse_array, other.T, lower=self.lower, trans=1).T

    @property
    def lower(self):
        return self._lower

    @property
    def inv(self):
        return TriangularMatrix(self._inverse_array, lower=self.lower)

    @property
    def T(self):
        return InverseTriangularMatrix(
            self._inverse_array.T, lower=not self.lower)

    def _construct_array(self):
        return self @ np.identity(self.shape[0])

    @property
    def diagonal(self):
        return 1. / self._inverse_array.diagonal()

    @property
    def log_abs_det(self):
        return -self.inv.log_abs_det

    def __str__(self):
        return f&#39;(shape={self.shape}, lower={self.lower})&#39;

    def _compute_hash(self):
        return hash_array(self._inverse_array)

    def _check_equality(self, other):
        return np.array_equal(self._inverse_array, other._inverse_array)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.InverseTriangularMatrix.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L840-L842" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def lower(self):
    return self._lower</code></pre>
</details>
</dd>
<dt id="mici.matrices.InverseTriangularMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L844-L846" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return TriangularMatrix(self._inverse_array, lower=self.lower)</code></pre>
</details>
</dd>
<dt id="mici.matrices.InverseTriangularMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L848-L851" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return InverseTriangularMatrix(
        self._inverse_array.T, lower=not self.lower)</code></pre>
</details>
</dd>
<dt id="mici.matrices.InverseTriangularMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L856-L858" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def diagonal(self):
    return 1. / self._inverse_array.diagonal()</code></pre>
</details>
</dd>
<dt id="mici.matrices.InverseTriangularMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L860-L862" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return -self.inv.log_abs_det</code></pre>
</details>
</dd>
<dt id="mici.matrices.InverseTriangularMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.InverseTriangularMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix"><code class="flex name class">
<span>class <span class="ident">TriangularFactoredDefiniteMatrix</span></span>
<span>(</span><span>factor, sign=1, factor_is_lower=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix specified as a signed self-product of a triangular factor.</p>
<p>The matrix is assumed to have the form</p>
<pre><code>matrix = sign * factor @ factor.T
</code></pre>
<p>for and upper- or lower-trinagular matrix <code>factor</code> and signed binary value
<code>sign</code> (i.e. <code>sign == +1 or sign == -1</code>), with the matrix being positive
definite if <code>sign == +1</code> and negative definite if <code>sign == -1</code> under the
assumption that <code>factor</code> is non-singular.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>array</code> or <a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix"><code>TriangularMatrix</code></a> or <a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix"><code>InverseTriangularMatrix</code></a></dt>
<dd>The
triangular factor parameterising the matrix. Defined either a
2D array, in which case only the lower- or upper-triangular
elements are used depending on the value of the
<code>factor_is_lower</code> boolean keyword argument, or as a
<a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix"><code>TriangularMatrix</code></a> / <a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix"><code>InverseTriangularMatrix</code></a> instance in
which case <code>factor_is_lower</code> is ignored, with <code>factor.lower</code>
instead determining if the factor is lower- or
upper-triangular.</dd>
<dt><strong><code>sign</code></strong> :&ensp;<code>int</code></dt>
<dd>+/-1 multiplier of factor product, corresponding
respectively to a strictly positive- or negative-definite
matrix.</dd>
<dt><strong><code>factor_is_lower</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the array <code>factor</code> is lower-
or upper-triangular.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L905-L976" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TriangularFactoredDefiniteMatrix(
        _BaseTriangularFactoredDefiniteMatrix, DifferentiableMatrix,
        ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix specified as a signed self-product of a triangular factor.

    The matrix is assumed to have the form

        matrix = sign * factor @ factor.T

    for and upper- or lower-trinagular matrix `factor` and signed binary value
    `sign` (i.e. `sign == +1 or sign == -1`), with the matrix being positive
    definite if `sign == +1` and negative definite if `sign == -1` under the
    assumption that `factor` is non-singular.
    &#34;&#34;&#34;

    def __init__(self, factor, sign=1, factor_is_lower=None):
        &#34;&#34;&#34;
        Args:
            factor (array or TriangularMatrix or InverseTriangularMatrix): The
                triangular factor parameterising the matrix. Defined either a
                2D array, in which case only the lower- or upper-triangular
                elements are used depending on the value of the
                `factor_is_lower` boolean keyword argument, or as a
                `TriangularMatrix` / `InverseTriangularMatrix` instance in
                which case `factor_is_lower` is ignored, with `factor.lower`
                instead determining if the factor is lower- or
                upper-triangular.
            sign (int): +/-1 multiplier of factor product, corresponding
                respectively to a strictly positive- or negative-definite
                matrix.
            factor_is_lower (boolean): Whether the array `factor` is lower-
                or upper-triangular.
        &#34;&#34;&#34;
        if not isinstance(factor, (TriangularMatrix, InverseTriangularMatrix)):
            if factor_is_lower not in (True, False):
                raise ValueError(
                    &#39;For array `factor` parameter `factor_is_lower` must be &#39;
                    &#39;specified as a boolean value.&#39;)
            factor = TriangularMatrix(factor, factor_is_lower)
        self._factor = factor
        super().__init__(factor.shape[0], sign=sign)

    def _scalar_multiply(self, scalar):
        return TriangularFactoredDefiniteMatrix(
            factor=abs(scalar)**0.5 * self.factor,
            sign=self.sign * np.sign(scalar))

    def _left_matrix_multiply(self, other):
        return self.sign * (self.factor @ (self.factor.T @ other))

    def _right_matrix_multiply(self, other):
        return self.sign * ((other @ self.factor) @ self.factor.T)

    @property
    def grad_log_abs_det(self):
        return np.diag(2 / self.factor.diagonal)

    def grad_quadratic_form_inv(self, vector):
        inv_factor_vector = self.factor.inv @ vector
        inv_vector = self.inv @ vector
        return _make_array_triangular(
            -2 * self.sign * np.outer(inv_vector, inv_factor_vector),
            self.factor.lower)

    def _construct_array(self):
        return self.sign * (self.factor @ self.factor.array.T)

    def _compute_hash(self):
        return hash((self.factor, self.sign))

    def _check_equality(self, other):
        return self.sign == other.sign and self.factor == other.factor</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mici.matrices._BaseTriangularFactoredDefiniteMatrix</li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.TriangularFactoredPositiveDefiniteMatrix" href="#mici.matrices.TriangularFactoredPositiveDefiniteMatrix">TriangularFactoredPositiveDefiniteMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L958-L960" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def grad_log_abs_det(self):
    return np.diag(2 / self.factor.diagonal)</code></pre>
</details>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.TriangularFactoredDefiniteMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L962-L967" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_quadratic_form_inv(self, vector):
    inv_factor_vector = self.factor.inv @ vector
    inv_vector = self.inv @ vector
    return _make_array_triangular(
        -2 * self.sign * np.outer(inv_vector, inv_factor_vector),
        self.factor.lower)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix"><code class="flex name class">
<span>class <span class="ident">TriangularFactoredPositiveDefiniteMatrix</span></span>
<span>(</span><span>factor, factor_is_lower=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Positive definite matrix parameterised a triangular matrix product.</p>
<p>The matrix is assumed to have the parameterisation</p>
<pre><code>matrix = factor @ factor.T
</code></pre>
<p>where <code>factor</code> is an upper- or lower-triangular matrix. Note for the case
<code>factor</code> is lower-triangular this corresponds to the standard Cholesky
factorisation of a positive definite matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>array</code> or <a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix"><code>TriangularMatrix</code></a> or <a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix"><code>InverseTriangularMatrix</code></a></dt>
<dd>The
triangular factor parameterising the matrix. Defined either a
2D array, in which case only the lower- or upper-triangular
elements are used depending on the value of the
<code>factor_is_lower</code> boolean keyword argument, or as a
<a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix"><code>TriangularMatrix</code></a> / <a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix"><code>InverseTriangularMatrix</code></a> instance in
which case <code>factor_is_lower</code> is ignored, with <code>factor.lower</code>
instead determining if the factor is lower- or
upper-triangular.</dd>
<dt><strong><code>factor_is_lower</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the array <code>factor</code> is lower-
or upper-triangular.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L979-L1023" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TriangularFactoredPositiveDefiniteMatrix(
        TriangularFactoredDefiniteMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Positive definite matrix parameterised a triangular matrix product.

    The matrix is assumed to have the parameterisation

        matrix = factor @ factor.T

    where `factor` is an upper- or lower-triangular matrix. Note for the case
    `factor` is lower-triangular this corresponds to the standard Cholesky
    factorisation of a positive definite matrix.
    &#34;&#34;&#34;

    def __init__(self, factor, factor_is_lower=True):
        &#34;&#34;&#34;
        Args:
            factor (array or TriangularMatrix or InverseTriangularMatrix): The
                triangular factor parameterising the matrix. Defined either a
                2D array, in which case only the lower- or upper-triangular
                elements are used depending on the value of the
                `factor_is_lower` boolean keyword argument, or as a
                `TriangularMatrix` / `InverseTriangularMatrix` instance in
                which case `factor_is_lower` is ignored, with `factor.lower`
                instead determining if the factor is lower- or
                upper-triangular.
            factor_is_lower (boolean): Whether the array `factor` is lower-
                or upper-triangular.
        &#34;&#34;&#34;
        super().__init__(factor, sign=1, factor_is_lower=factor_is_lower)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return TriangularFactoredPositiveDefiniteMatrix(
                factor=scalar**0.5 * self.factor)
        else:
            return super()._scalar_multiply(scalar)

    @property
    def inv(self):
        return TriangularFactoredPositiveDefiniteMatrix(
            factor=self.factor.inv.T)

    @property
    def sqrt(self):
        return self.factor</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.TriangularFactoredDefiniteMatrix" href="#mici.matrices.TriangularFactoredDefiniteMatrix">TriangularFactoredDefiniteMatrix</a></li>
<li>mici.matrices._BaseTriangularFactoredDefiniteMatrix</li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1016-L1019" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return TriangularFactoredPositiveDefiniteMatrix(
        factor=self.factor.inv.T)</code></pre>
</details>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1021-L1023" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    return self.factor</code></pre>
</details>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.TriangularFactoredPositiveDefiniteMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix"><code class="flex name class">
<span>class <span class="ident">DenseDefiniteMatrix</span></span>
<span>(</span><span>array, factor=None, is_posdef=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Definite matrix specified by a dense 2D array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D array specifying matrix entries.</dd>
<dt><strong><code>factor</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix"><code>TriangularMatrix</code></a> or <a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix"><code>InverseTriangularMatrix</code></a></dt>
<dd>
<p>Optional argument giving the triangular factorisation of the
matrix such that <code>matrix = factor @ factor.T</code> if
<code>is_posdef=True</code> or <code>matrix = -factor @ factor.T</code> otherwise.
If not pre-computed and specified at initialisation a
factorisation will only be computed when first required by
an operation which depends on the factor.</p>
</dd>
<dt><strong><code>is_posdef</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether matrix (and so corresponding array
representation) is positive definite, with the matrix assumed
to be negative-definite if not. This is <strong>not</strong> checked on
initialisation, and so if <code>array</code> is positive (negative)
definite and <code>is_posdef</code> is <code>False</code> (<code>True</code>) then a
<code>LinAlgError</code> exception will be if a later attempt is made to
factorise the matrix.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1026-L1081" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DenseDefiniteMatrix(_BaseTriangularFactoredDefiniteMatrix,
                          DifferentiableMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Definite matrix specified by a dense 2D array.&#34;&#34;&#34;

    def __init__(self, array, factor=None, is_posdef=True):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array specifying matrix entries.
            factor (None or TriangularMatrix or InverseTriangularMatrix):
                Optional argument giving the triangular factorisation of the
                matrix such that `matrix = factor @ factor.T` if
                `is_posdef=True` or `matrix = -factor @ factor.T` otherwise.
                If not pre-computed and specified at initialisation a
                factorisation will only be computed when first required by
                an operation which depends on the factor.
            is_posdef (boolean): Whether matrix (and so corresponding array
                representation) is positive definite, with the matrix assumed
                to be negative-definite if not. This is **not** checked on
                initialisation, and so if `array` is positive (negative)
                definite and `is_posdef` is `False` (`True`) then a
                `LinAlgError` exception will be if a later attempt is made to
                factorise the matrix.
        &#34;&#34;&#34;
        super().__init__(
            array.shape[0], sign=1 if is_posdef else -1, _array=array)
        self._factor = factor

    def _scalar_multiply(self, scalar):
        if (scalar &gt; 0) == (self._sign == 1):
            return DensePositiveDefiniteMatrix(
                scalar * self.array,
                None if self._factor is None else
                abs(scalar)**0.5 * self._factor)
        else:
            return DenseDefiniteMatrix(
                scalar * self.array,
                None if self._factor is None else
                abs(scalar)**0.5 * self._factor, is_posdef=False)

    @property
    def factor(self):
        if self._factor is None:
            try:
                self._factor = TriangularMatrix(
                    nla.cholesky(self._sign * self._array), lower=True)
            except nla.LinAlgError as e:
                raise LinAlgError(&#39;Cholesky factorisation failed.&#39;) from e
        return self._factor

    @property
    def grad_log_abs_det(self):
        return self.inv.array

    def grad_quadratic_form_inv(self, vector):
        inv_matrix_vector = self.inv @ vector
        return -np.outer(inv_matrix_vector, inv_matrix_vector)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mici.matrices._BaseTriangularFactoredDefiniteMatrix</li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.DensePositiveDefiniteMatrix" href="#mici.matrices.DensePositiveDefiniteMatrix">DensePositiveDefiniteMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.DenseDefiniteMatrix.factor"><code class="name">var <span class="ident">factor</span></code></dt>
<dd>
<section class="desc"><p>Triangular matrix with <code>matrix = sign * factor @ factor.T</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1065-L1073" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def factor(self):
    if self._factor is None:
        try:
            self._factor = TriangularMatrix(
                nla.cholesky(self._sign * self._array), lower=True)
        except nla.LinAlgError as e:
            raise LinAlgError(&#39;Cholesky factorisation failed.&#39;) from e
    return self._factor</code></pre>
</details>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1075-L1077" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def grad_log_abs_det(self):
    return self.inv.array</code></pre>
</details>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.DenseDefiniteMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.DenseDefiniteMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1079-L1081" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_quadratic_form_inv(self, vector):
    inv_matrix_vector = self.inv @ vector
    return -np.outer(inv_matrix_vector, inv_matrix_vector)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix"><code class="flex name class">
<span>class <span class="ident">DensePositiveDefiniteMatrix</span></span>
<span>(</span><span>array, factor=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Positive-definite matrix specified by a dense 2D array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D array specifying matrix entries.</dd>
<dt><strong><code>factor</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.TriangularMatrix" href="#mici.matrices.TriangularMatrix"><code>TriangularMatrix</code></a> or <a title="mici.matrices.InverseTriangularMatrix" href="#mici.matrices.InverseTriangularMatrix"><code>InverseTriangularMatrix</code></a></dt>
<dd>
<p>Optional argument giving the triangular factorisation of the
matrix such that <code>matrix = factor @ factor.T</code>. If not
pre-computed and specified at initialisation a factorisation
will only be computed when first required by an operation which
depends on the factor.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1084-L1107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DensePositiveDefiniteMatrix(DenseDefiniteMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Positive-definite matrix specified by a dense 2D array.&#34;&#34;&#34;

    def __init__(self, array, factor=None):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array specifying matrix entries.
            factor (None or TriangularMatrix or InverseTriangularMatrix):
                Optional argument giving the triangular factorisation of the
                matrix such that `matrix = factor @ factor.T`. If not
                pre-computed and specified at initialisation a factorisation
                will only be computed when first required by an operation which
                depends on the factor.
        &#34;&#34;&#34;
        super().__init__(array=array, factor=factor, is_posdef=True)

    @property
    def inv(self):
        return TriangularFactoredPositiveDefiniteMatrix(
            factor=self.factor.inv.T)

    @property
    def sqrt(self):
        return self.factor</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.DenseDefiniteMatrix" href="#mici.matrices.DenseDefiniteMatrix">DenseDefiniteMatrix</a></li>
<li>mici.matrices._BaseTriangularFactoredDefiniteMatrix</li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.DensePositiveDefiniteProductMatrix" href="#mici.matrices.DensePositiveDefiniteProductMatrix">DensePositiveDefiniteProductMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1100-L1103" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return TriangularFactoredPositiveDefiniteMatrix(
        factor=self.factor.inv.T)</code></pre>
</details>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1105-L1107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    return self.factor</code></pre>
</details>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.factor"><code class="name">var <span class="ident">factor</span></code></dt>
<dd>
<section class="desc"><p>Triangular matrix with <code>matrix = sign * factor @ factor.T</code></p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.DensePositiveDefiniteMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix"><code class="flex name class">
<span>class <span class="ident">DensePositiveDefiniteProductMatrix</span></span>
<span>(</span><span>rect_matrix, pos_def_matrix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Positive-definite matrix specified as a signed symmetric product.</p>
<p>The matrix is assumed to have the form</p>
<pre><code>matrix = rect_matrix @ pos_def_matrix @ rect_matrix.T
</code></pre>
<p>for a dense rectangular matrix <code>rect_matrix</code> with shape <code>(dim_0, dim_1)</code>
(<code>dim_1 &gt; dim_0</code>) positive definite matrix <code>pos_def_matrix</code> with shape
<code>(dim_1, dim_1)</code>, with the resulting matrix being positive definite under
the assumption that <code>rect_matrix</code> has full row rank.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rect_matrix</code></strong> :&ensp;<code>array</code> or <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Rectangular matrix of shape
<code>(dim_0, dim_1)</code> with it and its transpose forming the leftmost
and righmost term respectively in the symmetric matrix product
defining the matrix.</dd>
<dt><strong><code>pos_def_matrix</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a></dt>
<dd>Optional positive
positive definite matrix with shape <code>(dim_inner, dim_inner)</code>
specifying inner term in symmetric matrix product defining
matrix. If <code>None</code> an identity matrix is used.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1110-L1155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DensePositiveDefiniteProductMatrix(DensePositiveDefiniteMatrix):
    &#34;&#34;&#34;Positive-definite matrix specified as a signed symmetric product.

    The matrix is assumed to have the form

        matrix = rect_matrix @ pos_def_matrix @ rect_matrix.T

    for a dense rectangular matrix `rect_matrix` with shape `(dim_0, dim_1)`
    (`dim_1 &gt; dim_0`) positive definite matrix `pos_def_matrix` with shape
    `(dim_1, dim_1)`, with the resulting matrix being positive definite under
    the assumption that `rect_matrix` has full row rank.
    &#34;&#34;&#34;

    def __init__(self, rect_matrix, pos_def_matrix=None):
        &#34;&#34;&#34;
        Args:
            rect_matrix (array or Matrix): Rectangular matrix of shape
                `(dim_0, dim_1)` with it and its transpose forming the leftmost
                and righmost term respectively in the symmetric matrix product
                defining the matrix.
            pos_def_matrix (None or PositiveDefiniteMatrix): Optional positive
                positive definite matrix with shape `(dim_inner, dim_inner)`
                specifying inner term in symmetric matrix product defining
                matrix. If `None` an identity matrix is used.
        &#34;&#34;&#34;
        if not rect_matrix.shape[0] &lt; rect_matrix.shape[1]:
            raise ValueError(&#39;rect_matrix must have more columns than rows&#39;)
        if not isinstance(rect_matrix, Matrix):
            rect_matrix = DenseRectangularMatrix(rect_matrix)
        self._rect_matrix = rect_matrix
        if pos_def_matrix is None:
            pos_def_matrix = IdentityMatrix(rect_matrix.shape[1])
        self._pos_def_matrix = pos_def_matrix
        _array = rect_matrix @ (pos_def_matrix @ rect_matrix.T.array)
        super().__init__(_array)

    @property
    def grad_log_abs_det(self):
        return 2 * (self.inv @ (
            self._rect_matrix.array @ self._pos_def_matrix))

    def grad_quadratic_form_inv(self, vector):
        inv_matrix_vector = self.inv @ vector
        return -2 * np.outer(
            inv_matrix_vector,
            self._pos_def_matrix @ (self._rect_matrix.T @ inv_matrix_vector))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.DensePositiveDefiniteMatrix" href="#mici.matrices.DensePositiveDefiniteMatrix">DensePositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.DenseDefiniteMatrix" href="#mici.matrices.DenseDefiniteMatrix">DenseDefiniteMatrix</a></li>
<li>mici.matrices._BaseTriangularFactoredDefiniteMatrix</li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1146-L1149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def grad_log_abs_det(self):
    return 2 * (self.inv @ (
        self._rect_matrix.array @ self._pos_def_matrix))</code></pre>
</details>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.factor"><code class="name">var <span class="ident">factor</span></code></dt>
<dd>
<section class="desc"><p>Triangular matrix with <code>matrix = sign * factor @ factor.T</code></p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.DensePositiveDefiniteProductMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1151-L1155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_quadratic_form_inv(self, vector):
    inv_matrix_vector = self.inv @ vector
    return -2 * np.outer(
        inv_matrix_vector,
        self._pos_def_matrix @ (self._rect_matrix.T @ inv_matrix_vector))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.DenseSquareMatrix"><code class="flex name class">
<span>class <span class="ident">DenseSquareMatrix</span></span>
<span>(</span><span>array, lu_and_piv=None, lu_transposed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Dense non-singular square matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D array specifying matrix entries.</dd>
<dt><strong><code>lu_and_piv</code></strong> :&ensp;<code>Tuple</code>[<code>array</code>, <code>array</code>]</dt>
<dd>Pivoted LU factorisation
represented as a tuple with first element a 2D array containing
the lower and upper triangular factors (with the unit diagonal
of the lower triangular factor not stored) and the second
element a 1D array containing the pivot indices. Corresponds
to the output of <code>scipy.linalg.lu_factor</code> and input to
<code>scipy.linalg.lu_solve</code>.</dd>
<dt><strong><code>lu_transposed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether LU factorisation is of original array
or its transpose.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1158-L1212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DenseSquareMatrix(InvertibleMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Dense non-singular square matrix.&#34;&#34;&#34;

    def __init__(self, array, lu_and_piv=None, lu_transposed=None):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array specifying matrix entries.
            lu_and_piv (Tuple[array, array]): Pivoted LU factorisation
                represented as a tuple with first element a 2D array containing
                the lower and upper triangular factors (with the unit diagonal
                of the lower triangular factor not stored) and the second
                element a 1D array containing the pivot indices. Corresponds
                to the output of `scipy.linalg.lu_factor` and input to
                `scipy.linalg.lu_solve`.
            lu_transposed (bool): Whether LU factorisation is of original array
                or its transpose.
        &#34;&#34;&#34;
        super().__init__(array.shape, _array=array)
        self._lu_and_piv = lu_and_piv
        self._lu_transposed = lu_transposed

    def _scalar_multiply(self, scalar):
        if self._lu_and_piv is None or self._lu_transposed is None:
            return DenseSquareMatrix(scalar * self._array)
        else:
            old_lu, piv = self._lu_and_piv
            # Multiply upper-triangle by scalar
            new_lu = old_lu + (scalar - 1) * np.triu(old_lu)
            return DenseSquareMatrix(
                scalar * self._array, (new_lu, piv), self._lu_transposed)

    @property
    def lu_and_piv(self):
        &#34;&#34;&#34;Pivoted LU factorisation of matrix.&#34;&#34;&#34;
        if self._lu_and_piv is None:
            self._lu_and_piv = sla.lu_factor(self._array)
            self._lu_transposed = False
        return self._lu_and_piv

    @property
    def log_abs_det(self):
        lu, piv = self.lu_and_piv
        return np.log(np.abs(lu.diagonal())).sum()

    @property
    def T(self):
        lu_and_piv = self.lu_and_piv
        return DenseSquareMatrix(
            self._array.T, lu_and_piv, not self._lu_transposed)

    @property
    def inv(self):
        lu_and_piv = self.lu_and_piv
        return InverseLUFactoredSquareMatrix(
            self._array, lu_and_piv, self._lu_transposed)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.DenseSquareMatrix.lu_and_piv"><code class="name">var <span class="ident">lu_and_piv</span></code></dt>
<dd>
<section class="desc"><p>Pivoted LU factorisation of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1189-L1195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def lu_and_piv(self):
    &#34;&#34;&#34;Pivoted LU factorisation of matrix.&#34;&#34;&#34;
    if self._lu_and_piv is None:
        self._lu_and_piv = sla.lu_factor(self._array)
        self._lu_transposed = False
    return self._lu_and_piv</code></pre>
</details>
</dd>
<dt id="mici.matrices.DenseSquareMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1197-L1200" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    lu, piv = self.lu_and_piv
    return np.log(np.abs(lu.diagonal())).sum()</code></pre>
</details>
</dd>
<dt id="mici.matrices.DenseSquareMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1202-L1206" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    lu_and_piv = self.lu_and_piv
    return DenseSquareMatrix(
        self._array.T, lu_and_piv, not self._lu_transposed)</code></pre>
</details>
</dd>
<dt id="mici.matrices.DenseSquareMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1208-L1212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    lu_and_piv = self.lu_and_piv
    return InverseLUFactoredSquareMatrix(
        self._array, lu_and_piv, self._lu_transposed)</code></pre>
</details>
</dd>
<dt id="mici.matrices.DenseSquareMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.DenseSquareMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.DenseSquareMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.InverseLUFactoredSquareMatrix"><code class="flex name class">
<span>class <span class="ident">InverseLUFactoredSquareMatrix</span></span>
<span>(</span><span>inv_array, inv_lu_and_piv, inv_lu_transposed)</span>
</code></dt>
<dd>
<section class="desc"><p>Square matrix implicitly defined by LU factorisation of inverse.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inv_array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D array specifying inverse matrix entries.</dd>
<dt><strong><code>inv_lu_and_piv</code></strong> :&ensp;<code>Tuple</code>[<code>array</code>, <code>array</code>]</dt>
<dd>Pivoted LU factorisation
represented as a tuple with first element a 2D array containing
the lower and upper triangular factors (with the unit diagonal
of the lower triangular factor not stored) and the second
element a 1D array containing the pivot indices. Corresponds
to the output of <code>scipy.linalg.lu_factor</code> and input to
<code>scipy.linalg.lu_solve</code>.</dd>
<dt><strong><code>inv_lu_transposed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether LU factorisation is of inverse of
array or transpose of inverse of array.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1215-L1275" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InverseLUFactoredSquareMatrix(InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Square matrix implicitly defined by LU factorisation of inverse.&#34;&#34;&#34;

    def __init__(self, inv_array, inv_lu_and_piv, inv_lu_transposed):
        &#34;&#34;&#34;
        Args:
            inv_array (array): 2D array specifying inverse matrix entries.
            inv_lu_and_piv (Tuple[array, array]): Pivoted LU factorisation
                represented as a tuple with first element a 2D array containing
                the lower and upper triangular factors (with the unit diagonal
                of the lower triangular factor not stored) and the second
                element a 1D array containing the pivot indices. Corresponds
                to the output of `scipy.linalg.lu_factor` and input to
                `scipy.linalg.lu_solve`.
            inv_lu_transposed (bool): Whether LU factorisation is of inverse of
                array or transpose of inverse of array.
        &#34;&#34;&#34;
        super().__init__(inv_array.shape)
        self._inv_array = inv_array
        self._inv_lu_and_piv = inv_lu_and_piv
        self._inv_lu_transposed = inv_lu_transposed

    def _scalar_multiply(self, scalar):
        old_inv_lu, piv = self._inv_lu_and_piv
        # Divide upper-triangle by scalar
        new_inv_lu = old_inv_lu - (scalar - 1) / scalar * np.triu(old_inv_lu)
        return InverseLUFactoredSquareMatrix(
            self._inv_array / scalar, (new_inv_lu, piv),
            self._inv_lu_transposed)

    def _left_matrix_multiply(self, other):
        return sla.lu_solve(
            self._inv_lu_and_piv, other, self._inv_lu_transposed)

    def _right_matrix_multiply(self, other):
        return sla.lu_solve(
            self._inv_lu_and_piv, other.T, not self._inv_lu_transposed).T

    @property
    def log_abs_det(self):
        return -np.log(np.abs(self._inv_lu_and_piv[0].diagonal())).sum()

    def _construct_array(self):
        return self @ np.identity(self.shape[0])

    @property
    def inv(self):
        return DenseSquareMatrix(
            self._inv_array, self._inv_lu_and_piv, self._inv_lu_transposed)

    @property
    def T(self):
        return InverseLUFactoredSquareMatrix(
            self._inv_array.T, self._inv_lu_and_piv,
            not self._inv_lu_transposed)

    def _compute_hash(self):
        return hash_array(self._inv_array)

    def _check_equality(self, other):
        return np.array_equal(self._inv_array, other._inv_array)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.InverseLUFactoredSquareMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1253-L1255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return -np.log(np.abs(self._inv_lu_and_piv[0].diagonal())).sum()</code></pre>
</details>
</dd>
<dt id="mici.matrices.InverseLUFactoredSquareMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1260-L1263" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return DenseSquareMatrix(
        self._inv_array, self._inv_lu_and_piv, self._inv_lu_transposed)</code></pre>
</details>
</dd>
<dt id="mici.matrices.InverseLUFactoredSquareMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1265-L1269" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return InverseLUFactoredSquareMatrix(
        self._inv_array.T, self._inv_lu_and_piv,
        not self._inv_lu_transposed)</code></pre>
</details>
</dd>
<dt id="mici.matrices.InverseLUFactoredSquareMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.InverseLUFactoredSquareMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.InverseLUFactoredSquareMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.DenseSymmetricMatrix"><code class="flex name class">
<span>class <span class="ident">DenseSymmetricMatrix</span></span>
<span>(</span><span>array, eigvec=None, eigval=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Dense non-singular symmetric matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>array</code></dt>
<dd>Explicit 2D array representation of matrix.</dd>
<dt><strong><code>eigvec</code></strong> :&ensp;<code>None</code> or <code>array</code> or <a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix"><code>OrthogonalMatrix</code></a></dt>
<dd>Optional. If specified
either a 2D array or an <a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix"><code>OrthogonalMatrix</code></a> instance, in both
cases the columns of the matrix corresponding to the
orthonormal set of eigenvectors of the matrix being
constructed.</dd>
<dt><strong><code>eigval</code></strong> :&ensp;<code>None</code> or <code>array</code></dt>
<dd>Optional. If specified a 1D array
containing the eigenvalues of the matrix being constructed,
with <code>eigval[i]</code> the eigenvalue associated with column <code>i</code> of
<code>eigvec</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1278-L1309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DenseSymmetricMatrix(
        SymmetricMatrix, InvertibleMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Dense non-singular symmetric matrix.&#34;&#34;&#34;

    def __init__(self, array, eigvec=None, eigval=None):
        &#34;&#34;&#34;
        Args:
            array (array): Explicit 2D array representation of matrix.
            eigvec (None or array or OrthogonalMatrix): Optional. If specified
                either a 2D array or an `OrthogonalMatrix` instance, in both
                cases the columns of the matrix corresponding to the
                orthonormal set of eigenvectors of the matrix being
                constructed.
            eigval (None or array): Optional. If specified a 1D array
                containing the eigenvalues of the matrix being constructed,
                with `eigval[i]` the eigenvalue associated with column `i` of
                `eigvec`.
        &#34;&#34;&#34;
        super().__init__(array.shape, _array=array)
        if isinstance(eigvec, np.ndarray):
            eigvec = OrthogonalMatrix(eigvec)
        self._eigvec = eigvec
        self._eigval = eigval

    def _scalar_multiply(self, scalar):
        return DenseSymmetricMatrix(
            self.array * scalar, self._eigvec,
            None if self._eigval is None else self._eigval * scalar)

    @property
    def inv(self):
        return EigendecomposedSymmetricMatrix(self.eigvec, 1 / self.eigval)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.DenseSymmetricMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1307-L1309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return EigendecomposedSymmetricMatrix(self.eigvec, 1 / self.eigval)</code></pre>
</details>
</dd>
<dt id="mici.matrices.DenseSymmetricMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.DenseSymmetricMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.DenseSymmetricMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.DenseSymmetricMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.DenseSymmetricMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.DenseSymmetricMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.DenseSymmetricMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.OrthogonalMatrix"><code class="flex name class">
<span>class <span class="ident">OrthogonalMatrix</span></span>
<span>(</span><span>array)</span>
</code></dt>
<dd>
<section class="desc"><p>Square matrix with columns and rows that are orthogonal unit vectors.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>array</code></dt>
<dd>Explicit 2D array representation of matrix.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1312-L1335" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OrthogonalMatrix(InvertibleMatrix, ExplicitArrayMatrix):
    &#34;&#34;&#34;Square matrix with columns and rows that are orthogonal unit vectors.&#34;&#34;&#34;

    def __init__(self, array):
        &#34;&#34;&#34;
        Args:
            array (array): Explicit 2D array representation of matrix.
        &#34;&#34;&#34;
        super().__init__(array.shape, _array=array)

    def _scalar_multiply(self, scalar):
        return ScaledOrthogonalMatrix(scalar, self.array)

    @property
    def log_abs_det(self):
        return 0

    @property
    def T(self):
        return OrthogonalMatrix(self.array.T)

    @property
    def inv(self):
        return self.T</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.OrthogonalMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1325-L1327" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return 0</code></pre>
</details>
</dd>
<dt id="mici.matrices.OrthogonalMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1329-L1331" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return OrthogonalMatrix(self.array.T)</code></pre>
</details>
</dd>
<dt id="mici.matrices.OrthogonalMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1333-L1335" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return self.T</code></pre>
</details>
</dd>
<dt id="mici.matrices.OrthogonalMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.OrthogonalMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.OrthogonalMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.ScaledOrthogonalMatrix"><code class="flex name class">
<span>class <span class="ident">ScaledOrthogonalMatrix</span></span>
<span>(</span><span>scalar, orth_array)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix corresponding to orthogonal matrix multiplied by a scalar.</p>
<p>Matrix is assumed to have the paramterisation</p>
<pre><code>matrix = scalar * orth_array
</code></pre>
<p>where <code>scalar</code> is a real-valued scalar and <code>orth_array</code> is an orthogonal
matrix represented as a square 2D array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scalar</code></strong> :&ensp;<code>float</code></dt>
<dd>Scalar multiplier as a floating point value.</dd>
<dt><strong><code>orth_array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D array representation of orthogonal matrix.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1338-L1391" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ScaledOrthogonalMatrix(InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix corresponding to orthogonal matrix multiplied by a scalar.

    Matrix is assumed to have the paramterisation

        matrix = scalar * orth_array

    where `scalar` is a real-valued scalar and `orth_array` is an orthogonal
    matrix represented as a square 2D array.
    &#34;&#34;&#34;

    def __init__(self, scalar, orth_array):
        &#34;&#34;&#34;
        Args:
            scalar (float): Scalar multiplier as a floating point value.
            orth_array (array): 2D array representation of orthogonal matrix.
        &#34;&#34;&#34;
        super().__init__(orth_array.shape, _orth_array=orth_array)
        self._scalar = scalar

    def _left_matrix_multiply(self, other):
        return self._scalar * (self._orth_array @ other)

    def _right_matrix_multiply(self, other):
        return self._scalar * (other @ self._orth_array)

    def _scalar_multiply(self, scalar):
        return ScaledOrthogonalMatrix(scalar * self._scalar, self._orth_array)

    def _construct_array(self):
        return self._scalar * self._orth_array

    @property
    def diagonal(self):
        return self._scalar * self._orth_array.diagonal()

    @property
    def log_abs_det(self):
        return self.shape[0] * np.log(abs(self._scalar))

    @property
    def T(self):
        return ScaledOrthogonalMatrix(self._scalar, self._orth_array.T)

    @property
    def inv(self):
        return ScaledOrthogonalMatrix(1 / self._scalar, self._orth_array.T)

    def _compute_hash(self):
        return hash((self._scalar, hash_array(self._orth_array)))

    def _check_equality(self, other):
        return self._scalar == other._scalar and (
            np.array_equal(self._orth_array, other._orth_array))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.ScaledOrthogonalMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1370-L1372" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def diagonal(self):
    return self._scalar * self._orth_array.diagonal()</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledOrthogonalMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1374-L1376" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return self.shape[0] * np.log(abs(self._scalar))</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledOrthogonalMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1378-L1380" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return ScaledOrthogonalMatrix(self._scalar, self._orth_array.T)</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledOrthogonalMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1382-L1384" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return ScaledOrthogonalMatrix(1 / self._scalar, self._orth_array.T)</code></pre>
</details>
</dd>
<dt id="mici.matrices.ScaledOrthogonalMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.ScaledOrthogonalMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix"><code class="flex name class">
<span>class <span class="ident">EigendecomposedSymmetricMatrix</span></span>
<span>(</span><span>eigvec, eigval)</span>
</code></dt>
<dd>
<section class="desc"><p>Symmetric matrix parameterised by its eigendecomposition.</p>
<p>The matrix is assumed to have the parameterisation</p>
<pre><code>matrix = eigvec @ diag(eigval) @ eigvec.T
</code></pre>
<p>where <code>eigvec</code> is an orthogonal matrix, with columns corresponding to
the eigenvectors of <code>matrix</code> and <code>eigval</code> is 1D array of the corresponding
eigenvalues of <code>matrix</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>eigvec</code></strong> :&ensp;<code>array</code> or <a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix"><code>OrthogonalMatrix</code></a></dt>
<dd>Either a 2D array or an
<a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix"><code>OrthogonalMatrix</code></a> instance, in both cases the columns of the
matrix corresponding to the orthonormal set of eigenvectors of
the matrix being constructed.</dd>
<dt><strong><code>eigval</code></strong> :&ensp;<code>array</code></dt>
<dd>A 1D array containing the eigenvalues of the matrix
being constructed, with <code>eigval[i]</code> the eigenvalue associated
with column <code>i</code> of <code>eigvec</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1394-L1454" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EigendecomposedSymmetricMatrix(
        SymmetricMatrix, InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Symmetric matrix parameterised by its eigendecomposition.

    The matrix is assumed to have the parameterisation

        matrix = eigvec @ diag(eigval) @ eigvec.T

    where `eigvec` is an orthogonal matrix, with columns corresponding to
    the eigenvectors of `matrix` and `eigval` is 1D array of the corresponding
    eigenvalues of `matrix`.
    &#34;&#34;&#34;

    def __init__(self, eigvec, eigval):
        &#34;&#34;&#34;
        Args:
            eigvec (array or OrthogonalMatrix): Either a 2D array or an
                `OrthogonalMatrix` instance, in both cases the columns of the
                matrix corresponding to the orthonormal set of eigenvectors of
                the matrix being constructed.
            eigval (array): A 1D array containing the eigenvalues of the matrix
                being constructed, with `eigval[i]` the eigenvalue associated
                with column `i` of `eigvec`.
        &#34;&#34;&#34;
        if isinstance(eigvec, np.ndarray):
            eigvec = OrthogonalMatrix(eigvec)
        super().__init__(eigvec.shape)
        self._eigvec = eigvec
        self._eigval = eigval
        if not isinstance(eigval, np.ndarray) or eigval.size == 1:
            self.diag_eigval = ScaledIdentityMatrix(eigval)
        else:
            self.diag_eigval = DiagonalMatrix(eigval)

    def _scalar_multiply(self, scalar):
        return EigendecomposedSymmetricMatrix(
            self.eigvec, self.eigval * scalar)

    def _left_matrix_multiply(self, other):
        return self.eigvec @ (self.diag_eigval @ (self.eigvec.T @ other))

    def _right_matrix_multiply(self, other):
        return ((other @ self.eigvec) @ self.diag_eigval) @ self.eigvec.T

    @property
    def inv(self):
        return EigendecomposedSymmetricMatrix(self.eigvec, 1 / self.eigval)

    def _construct_array(self):
        if self.shape[0] is None:
            raise RuntimeError(
                &#39;Cannot get array representation for symmetric &#39;
                &#39;eigendecomposed matrix with implicit size.&#39;)
        return self @ np.identity(self.shape[0])

    def _compute_hash(self):
        return hash((hash_array(self.eigval), self.eigvec))

    def _check_equality(self, other):
        return np.array_equal(self.eigval, other.eigval) and (
            self.eigvec == other.eigvec)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix">EigendecomposedPositiveDefiniteMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1438-L1440" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return EigendecomposedSymmetricMatrix(self.eigvec, 1 / self.eigval)</code></pre>
</details>
</dd>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedSymmetricMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix"><code class="flex name class">
<span>class <span class="ident">EigendecomposedPositiveDefiniteMatrix</span></span>
<span>(</span><span>eigvec, eigval)</span>
</code></dt>
<dd>
<section class="desc"><p>Positive definite matrix parameterised by its eigendecomposition.</p>
<p>The matrix is assumed to have the parameterisation</p>
<pre><code>matrix = eigvec @ diag(eigval) @ eigvec.T
</code></pre>
<p>where <code>eigvec</code> is an orthogonal matrix, with columns corresponding to
the eigenvectors of <code>matrix</code> and <code>eigval</code> is 1D array of the corresponding
strictly positive eigenvalues of <code>matrix</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>eigvec</code></strong> :&ensp;<code>array</code> or <a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix"><code>OrthogonalMatrix</code></a></dt>
<dd>Either a 2D array or an
<a title="mici.matrices.OrthogonalMatrix" href="#mici.matrices.OrthogonalMatrix"><code>OrthogonalMatrix</code></a> instance, in both cases the columns of the
matrix corresponding to the orthonormal set of eigenvectors of
the matrix being constructed.</dd>
<dt><strong><code>eigval</code></strong> :&ensp;<code>array</code></dt>
<dd>A 1D array containing the eigenvalues of the matrix
being constructed, with <code>eigval[i]</code> the eigenvalue associated
with column <code>i</code> of <code>eigvec</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1457-L1489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EigendecomposedPositiveDefiniteMatrix(
        EigendecomposedSymmetricMatrix, PositiveDefiniteMatrix):
    &#34;&#34;&#34;Positive definite matrix parameterised by its eigendecomposition.

    The matrix is assumed to have the parameterisation

        matrix = eigvec @ diag(eigval) @ eigvec.T

    where `eigvec` is an orthogonal matrix, with columns corresponding to
    the eigenvectors of `matrix` and `eigval` is 1D array of the corresponding
    strictly positive eigenvalues of `matrix`.
    &#34;&#34;&#34;

    def __init__(self, eigvec, eigval):
        if not np.all(eigval &gt; 0):
            raise ValueError(&#39;Eigenvalues must all be positive.&#39;)
        super().__init__(eigvec, eigval)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return EigendecomposedPositiveDefiniteMatrix(
                self.eigvec, self.eigval * scalar)
        else:
            return super()._scalar_multiply(scalar)

    @property
    def inv(self):
        return EigendecomposedPositiveDefiniteMatrix(
            self.eigvec, 1 / self.eigval)

    @property
    def sqrt(self):
        return EigendecomposedSymmetricMatrix(self.eigvec, self.eigval**0.5)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.EigendecomposedSymmetricMatrix" href="#mici.matrices.EigendecomposedSymmetricMatrix">EigendecomposedSymmetricMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix" href="#mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix">SoftAbsRegularisedPositiveDefiniteMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1482-L1485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return EigendecomposedPositiveDefiniteMatrix(
        self.eigvec, 1 / self.eigval)</code></pre>
</details>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1487-L1489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    return EigendecomposedSymmetricMatrix(self.eigvec, self.eigval**0.5)</code></pre>
</details>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.EigendecomposedPositiveDefiniteMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix"><code class="flex name class">
<span>class <span class="ident">SoftAbsRegularisedPositiveDefiniteMatrix</span></span>
<span>(</span><span>symmetric_array, softabs_coeff)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix transformed to be positive definite by regularising eigenvalues.</p>
<p>Matrix is parameterised by a symmetric array <code>symmetric_array</code>, of which an
eigendecomposition is formed <code>eigvec, eigval = eigh(symmetric_array)</code>, with
the output matrix then <code>matrix = eigvec @ softabs(eigval) @ eigvec.T</code>
where <code>softabs</code> is a smooth approximation to the absolute function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symmetric_array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D square array with symmetric values,
i.e. <code>symmetric_array[i, j] == symmetric_array[j, i]</code> for all
indices <code>i</code> and <code>j</code> which represents symmetric matrix to
form eigenvalue-regularised transformation of.</dd>
<dt><strong><code>softabs_coeff</code></strong> :&ensp;<code>float</code></dt>
<dd>Positive regularisation coefficient for
smooth approximation to absolute value. As the value tends to
infinity the approximation becomes increasingly close to the
absolute function.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1492-L1544" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SoftAbsRegularisedPositiveDefiniteMatrix(
        EigendecomposedPositiveDefiniteMatrix, DifferentiableMatrix):
    &#34;&#34;&#34;Matrix transformed to be positive definite by regularising eigenvalues.

    Matrix is parameterised by a symmetric array `symmetric_array`, of which an
    eigendecomposition is formed `eigvec, eigval = eigh(symmetric_array)`, with
    the output matrix then `matrix = eigvec @ softabs(eigval) @ eigvec.T`
    where `softabs` is a smooth approximation to the absolute function.
    &#34;&#34;&#34;

    def __init__(self, symmetric_array, softabs_coeff):
        &#34;&#34;&#34;
        Args:
            symmetric_array (array): 2D square array with symmetric values,
                i.e. `symmetric_array[i, j] == symmetric_array[j, i]` for all
                indices `i` and `j` which represents symmetric matrix to
                form eigenvalue-regularised transformation of.
            softabs_coeff (float): Positive regularisation coefficient for
                smooth approximation to absolute value. As the value tends to
                infinity the approximation becomes increasingly close to the
                absolute function.
        &#34;&#34;&#34;
        if softabs_coeff &lt;= 0:
            raise ValueError(&#39;softabs_coeff must be positive.&#39;)
        self._softabs_coeff = softabs_coeff
        self.unreg_eigval, eigvec = nla.eigh(symmetric_array)
        eigval = self.softabs(self.unreg_eigval)
        super().__init__(eigvec, eigval)

    def softabs(self, x):
        &#34;&#34;&#34;Smooth approximation to absolute function.&#34;&#34;&#34;
        return x / np.tanh(x * self._softabs_coeff)

    def grad_softabs(self, x):
        &#34;&#34;&#34;Derivative of smooth approximation to absolute function.&#34;&#34;&#34;
        return (
            1. / np.tanh(self._softabs_coeff * x) -
            self._softabs_coeff * x / np.sinh(self._softabs_coeff * x)**2)

    @property
    def grad_log_abs_det(self):
        grad_eigval = self.grad_softabs(self.unreg_eigval) / self.eigval
        return EigendecomposedSymmetricMatrix(self.eigvec, grad_eigval).array

    def grad_quadratic_form_inv(self, vector):
        num_j_mtx = self.eigval[:, None] - self.eigval[None, :]
        num_j_mtx += np.diag(self.grad_softabs(self.unreg_eigval))
        den_j_mtx = self.unreg_eigval[:, None] - self.unreg_eigval[None, :]
        np.fill_diagonal(den_j_mtx, 1)
        j_mtx = num_j_mtx / den_j_mtx
        e_vct = (self.eigvec.T @ vector) / self.eigval
        return -(
            (self.eigvec @ (np.outer(e_vct, e_vct) * j_mtx)) @ self.eigvec.T)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.EigendecomposedPositiveDefiniteMatrix" href="#mici.matrices.EigendecomposedPositiveDefiniteMatrix">EigendecomposedPositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.EigendecomposedSymmetricMatrix" href="#mici.matrices.EigendecomposedSymmetricMatrix">EigendecomposedSymmetricMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1531-L1534" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def grad_log_abs_det(self):
    grad_eigval = self.grad_softabs(self.unreg_eigval) / self.eigval
    return EigendecomposedSymmetricMatrix(self.eigvec, grad_eigval).array</code></pre>
</details>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.softabs"><code class="name flex">
<span>def <span class="ident">softabs</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"><p>Smooth approximation to absolute function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1521-L1523" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def softabs(self, x):
    &#34;&#34;&#34;Smooth approximation to absolute function.&#34;&#34;&#34;
    return x / np.tanh(x * self._softabs_coeff)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_softabs"><code class="name flex">
<span>def <span class="ident">grad_softabs</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"><p>Derivative of smooth approximation to absolute function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1525-L1529" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_softabs(self, x):
    &#34;&#34;&#34;Derivative of smooth approximation to absolute function.&#34;&#34;&#34;
    return (
        1. / np.tanh(self._softabs_coeff * x) -
        self._softabs_coeff * x / np.sinh(self._softabs_coeff * x)**2)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SoftAbsRegularisedPositiveDefiniteMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1536-L1544" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_quadratic_form_inv(self, vector):
    num_j_mtx = self.eigval[:, None] - self.eigval[None, :]
    num_j_mtx += np.diag(self.grad_softabs(self.unreg_eigval))
    den_j_mtx = self.unreg_eigval[:, None] - self.unreg_eigval[None, :]
    np.fill_diagonal(den_j_mtx, 1)
    j_mtx = num_j_mtx / den_j_mtx
    e_vct = (self.eigvec.T @ vector) / self.eigval
    return -(
        (self.eigvec @ (np.outer(e_vct, e_vct) * j_mtx)) @ self.eigvec.T)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.BlockMatrix"><code class="flex name class">
<span>class <span class="ident">BlockMatrix</span></span>
<span>(</span><span>shape, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix with non-zero entries defined by a series of submatrix blocks.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>Shape of matrix <code>(num_rows, num_columns)</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1547-L1563" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BlockMatrix(ImplicitArrayMatrix):
    &#34;&#34;&#34;Matrix with non-zero entries defined by a series of submatrix blocks.&#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def blocks(self):
        &#34;&#34;&#34;Non-zero blocks of matrix as a tuple of Matrix instances&#34;&#34;&#34;

    def _compute_hash(self):
        return hash(tuple(block for block in self.blocks))

    def _check_equality(self, other):
        return (
            len(other.blocks) == len(self.blocks) and
            all(block_s == block_o for block_s, block_o
                in zip(self.blocks, other.blocks))
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.SquareBlockDiagonalMatrix" href="#mici.matrices.SquareBlockDiagonalMatrix">SquareBlockDiagonalMatrix</a></li>
<li><a title="mici.matrices.BlockRowMatrix" href="#mici.matrices.BlockRowMatrix">BlockRowMatrix</a></li>
<li><a title="mici.matrices.BlockColumnMatrix" href="#mici.matrices.BlockColumnMatrix">BlockColumnMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.BlockMatrix.blocks"><code class="name">var <span class="ident">blocks</span></code></dt>
<dd>
<section class="desc"><p>Non-zero blocks of matrix as a tuple of Matrix instances</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1550-L1553" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def blocks(self):
    &#34;&#34;&#34;Non-zero blocks of matrix as a tuple of Matrix instances&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mici.matrices.BlockMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p>
<p>Generally accessing this property should be avoided wherever possible
as the resulting array object may use a lot of memory and operations
with it will not be able to exploit any structure in the matrix.</p></section>
</dd>
<dt id="mici.matrices.BlockMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.BlockMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.BlockMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix"><code class="flex name class">
<span>class <span class="ident">SquareBlockDiagonalMatrix</span></span>
<span>(</span><span>blocks)</span>
</code></dt>
<dd>
<section class="desc"><p>Square matrix with non-zero values only in blocks along diagonal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blocks</code></strong> :&ensp;<code>Iterable</code>[<code>SquareMatrix</code>]</dt>
<dd>Sequence of square matrices
defining non-zero blocks along diagonal of matrix in order
left-to-right.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1566-L1640" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SquareBlockDiagonalMatrix(InvertibleMatrix, BlockMatrix):
    &#34;&#34;&#34;Square matrix with non-zero values only in blocks along diagonal.&#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[SquareMatrix]): Sequence of square matrices
                defining non-zero blocks along diagonal of matrix in order
                left-to-right.
        &#34;&#34;&#34;
        self._blocks = tuple(blocks)
        if not all(isinstance(block, SquareMatrix) for block in self._blocks):
            raise ValueError(&#39;All blocks must be square&#39;)
        sizes = tuple(block.shape[0] for block in self._blocks)
        total_size = sum(sizes)
        super().__init__((total_size, total_size))
        self._sizes = sizes
        self._splits = np.cumsum(sizes[:-1])

    @property
    def blocks(self):
        &#34;&#34;&#34;Blocks containing non-zero values left-to-right along diagonal.&#34;&#34;&#34;
        return self._blocks

    def _split(self, other, axis=0):
        assert other.shape[axis] == self.shape[0]
        return np.split(other, self._splits, axis=axis)

    def _left_matrix_multiply(self, other):
        return np.concatenate(
            [block @ part for block, part in
             zip(self._blocks, self._split(other, axis=0))], axis=0)

    def _right_matrix_multiply(self, other):
        return np.concatenate(
            [part @ block for block, part in
             zip(self._blocks, self._split(other, axis=-1))], axis=-1)

    def _scalar_multiply(self, scalar):
        return SquareBlockDiagonalMatrix(
            tuple(scalar * block for block in self._blocks))

    def _construct_array(self):
        return sla.block_diag(*(block.array for block in self._blocks))

    @property
    def T(self):
        return SquareBlockDiagonalMatrix(
            tuple(block.T for block in self._blocks))

    @property
    def sqrt(self):
        return SquareBlockDiagonalMatrix(
            tuple(block.sqrt for block in self._blocks))

    @property
    def diag(self):
        return np.concatenate([block.diagonal() for block in self._blocks])

    @property
    def inv(self):
        return type(self)(tuple(block.inv for block in self._blocks))

    @property
    def eigval(self):
        return np.concatenate([block.eigval for block in self._blocks])

    @property
    def eigvec(self):
        return SquareBlockDiagonalMatrix(
            tuple(block.eigvec for block in self._blocks))

    @property
    def log_abs_det(self):
        return sum(block.log_abs_det for block in self._blocks)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.BlockMatrix" href="#mici.matrices.BlockMatrix">BlockMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.SymmetricBlockDiagonalMatrix" href="#mici.matrices.SymmetricBlockDiagonalMatrix">SymmetricBlockDiagonalMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.blocks"><code class="name">var <span class="ident">blocks</span></code></dt>
<dd>
<section class="desc"><p>Blocks containing non-zero values left-to-right along diagonal.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1585-L1588" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def blocks(self):
    &#34;&#34;&#34;Blocks containing non-zero values left-to-right along diagonal.&#34;&#34;&#34;
    return self._blocks</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1611-L1614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return SquareBlockDiagonalMatrix(
        tuple(block.T for block in self._blocks))</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1616-L1619" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    return SquareBlockDiagonalMatrix(
        tuple(block.sqrt for block in self._blocks))</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.diag"><code class="name">var <span class="ident">diag</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1621-L1623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def diag(self):
    return np.concatenate([block.diagonal() for block in self._blocks])</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1625-L1627" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return type(self)(tuple(block.inv for block in self._blocks))</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1629-L1631" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigval(self):
    return np.concatenate([block.eigval for block in self._blocks])</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1633-L1636" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eigvec(self):
    return SquareBlockDiagonalMatrix(
        tuple(block.eigvec for block in self._blocks))</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1638-L1640" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return sum(block.log_abs_det for block in self._blocks)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.SquareBlockDiagonalMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.SymmetricBlockDiagonalMatrix"><code class="flex name class">
<span>class <span class="ident">SymmetricBlockDiagonalMatrix</span></span>
<span>(</span><span>blocks)</span>
</code></dt>
<dd>
<section class="desc"><p>Symmetric specialisation of <a title="mici.matrices.SquareBlockDiagonalMatrix" href="#mici.matrices.SquareBlockDiagonalMatrix"><code>SquareBlockDiagonalMatrix</code></a>.</p>
<p>All matrix blocks in diagonal are restricted to be symmetric, i.e.
<code>block.T == block</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blocks</code></strong> :&ensp;<code>Iterable</code>[<code>SymmetricMatrix</code>]</dt>
<dd>Sequence of symmetric matrices
defining non-zero blocks along diagonal of matrix in order
left-to-right.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1643-L1668" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SymmetricBlockDiagonalMatrix(SquareBlockDiagonalMatrix):
    &#34;&#34;&#34;Symmetric specialisation of `SquareBlockDiagonalMatrix`.

    All matrix blocks in diagonal are restricted to be symmetric, i.e.
    `block.T == block`.
    &#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[SymmetricMatrix]): Sequence of symmetric matrices
                defining non-zero blocks along diagonal of matrix in order
                left-to-right.
        &#34;&#34;&#34;
        blocks = tuple(blocks)
        if not all(isinstance(block, SymmetricMatrix) for block in blocks):
            raise ValueError(&#39;All blocks must be symmetric&#39;)
        super().__init__(blocks)

    def _scalar_multiply(self, scalar):
        return SymmetricBlockDiagonalMatrix(
            tuple(scalar * block for block in self._blocks))

    @property
    def T(self):
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SquareBlockDiagonalMatrix" href="#mici.matrices.SquareBlockDiagonalMatrix">SquareBlockDiagonalMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.BlockMatrix" href="#mici.matrices.BlockMatrix">BlockMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.PositiveDefiniteBlockDiagonalMatrix" href="#mici.matrices.PositiveDefiniteBlockDiagonalMatrix">PositiveDefiniteBlockDiagonalMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.SymmetricBlockDiagonalMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1666-L1668" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return self</code></pre>
</details>
</dd>
<dt id="mici.matrices.SymmetricBlockDiagonalMatrix.blocks"><code class="name">var <span class="ident">blocks</span></code></dt>
<dd>
<section class="desc"><p>Blocks containing non-zero values left-to-right along diagonal.</p></section>
</dd>
<dt id="mici.matrices.SymmetricBlockDiagonalMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
<dt id="mici.matrices.SymmetricBlockDiagonalMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.SymmetricBlockDiagonalMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.SymmetricBlockDiagonalMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.SymmetricBlockDiagonalMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix"><code class="flex name class">
<span>class <span class="ident">PositiveDefiniteBlockDiagonalMatrix</span></span>
<span>(</span><span>blocks)</span>
</code></dt>
<dd>
<section class="desc"><p>Positive definite specialisation of <a title="mici.matrices.SymmetricBlockDiagonalMatrix" href="#mici.matrices.SymmetricBlockDiagonalMatrix"><code>SymmetricBlockDiagonalMatrix</code></a>.</p>
<p>All matrix blocks in diagonal are restricted to be positive definite.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blocks</code></strong> :&ensp;<code>Iterable</code>[<code>PositiveDefinite</code>]</dt>
<dd>Sequence of positive-definite
matrices defining non-zero blocks along diagonal of matrix in
order left-to-right.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1671-L1721" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PositiveDefiniteBlockDiagonalMatrix(
        SymmetricBlockDiagonalMatrix, PositiveDefiniteMatrix,
        DifferentiableMatrix):
    &#34;&#34;&#34;Positive definite specialisation of `SymmetricBlockDiagonalMatrix`.

    All matrix blocks in diagonal are restricted to be positive definite.
    &#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[PositiveDefinite]): Sequence of positive-definite
                matrices defining non-zero blocks along diagonal of matrix in
                order left-to-right.
        &#34;&#34;&#34;
        blocks = tuple(blocks)
        if not all(isinstance(block, PositiveDefiniteMatrix)
                   for block in blocks):
            raise ValueError(&#39;All blocks must be positive definite&#39;)
        self.is_differentiable = all(
            [isinstance(block, DifferentiableMatrix) for block in blocks])
        super().__init__(blocks)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveDefiniteBlockDiagonalMatrix(
                tuple(scalar * block for block in self._blocks))
        else:
            return super()._scalar_multiply(scalar)

    @property
    def sqrt(self):
        return SquareBlockDiagonalMatrix(
            tuple(block.sqrt for block in self._blocks))

    @property
    def grad_log_abs_det(self):
        if self.is_differentiable:
            return tuple(
                block.grad_log_abs_det for block in self._blocks)
        else:
            raise RuntimeError(&#39;Not all blocks are differentiable&#39;)

    def grad_quadratic_form_inv(self, vector):
        if self.is_differentiable:
            return tuple(
                block.grad_quadratic_form_inv(vector_part)
                for block, vector_part in
                zip(self._blocks, self._split(vector, axis=0)))
        else:
            raise RuntimeError(&#39;Not all blocks are differentiable&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SymmetricBlockDiagonalMatrix" href="#mici.matrices.SymmetricBlockDiagonalMatrix">SymmetricBlockDiagonalMatrix</a></li>
<li><a title="mici.matrices.SquareBlockDiagonalMatrix" href="#mici.matrices.SquareBlockDiagonalMatrix">SquareBlockDiagonalMatrix</a></li>
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.BlockMatrix" href="#mici.matrices.BlockMatrix">BlockMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1701-L1704" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    return SquareBlockDiagonalMatrix(
        tuple(block.sqrt for block in self._blocks))</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1706-L1712" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def grad_log_abs_det(self):
    if self.is_differentiable:
        return tuple(
            block.grad_log_abs_det for block in self._blocks)
    else:
        raise RuntimeError(&#39;Not all blocks are differentiable&#39;)</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.blocks"><code class="name">var <span class="ident">blocks</span></code></dt>
<dd>
<section class="desc"><p>Blocks containing non-zero values left-to-right along diagonal.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.PositiveDefiniteBlockDiagonalMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1714-L1721" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_quadratic_form_inv(self, vector):
    if self.is_differentiable:
        return tuple(
            block.grad_quadratic_form_inv(vector_part)
            for block, vector_part in
            zip(self._blocks, self._split(vector, axis=0)))
    else:
        raise RuntimeError(&#39;Not all blocks are differentiable&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.matrices.DenseRectangularMatrix"><code class="flex name class">
<span>class <span class="ident">DenseRectangularMatrix</span></span>
<span>(</span><span>array)</span>
</code></dt>
<dd>
<section class="desc"><p>Dense rectangular matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>array</code></dt>
<dd>2D array specifying matrix entries.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1724-L1739" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DenseRectangularMatrix(ExplicitArrayMatrix):
    &#34;&#34;&#34;Dense rectangular matrix.&#34;&#34;&#34;

    def __init__(self, array):
        &#34;&#34;&#34;
        Args:
            array (array): 2D array specifying matrix entries.
        &#34;&#34;&#34;
        super().__init__(array.shape, _array=array)

    def _scalar_multiply(self, scalar):
        return DenseRectangularMatrix(scalar * self.array)

    @property
    def T(self):
        return DenseRectangularMatrix(self.array.T)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.ExplicitArrayMatrix" href="#mici.matrices.ExplicitArrayMatrix">ExplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.DenseRectangularMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1737-L1739" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return DenseRectangularMatrix(self.array.T)</code></pre>
</details>
</dd>
<dt id="mici.matrices.DenseRectangularMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.DenseRectangularMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.DenseRectangularMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.BlockRowMatrix"><code class="flex name class">
<span>class <span class="ident">BlockRowMatrix</span></span>
<span>(</span><span>blocks)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix composed of horizontal concatenation of a series of blocks.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blocks</code></strong> :&ensp;<code>Iterable</code>[<code>Matrix</code>]</dt>
<dd>Sequence of matrices defining a row of
blocks in order left-to-right which when horizontally
concatenated give the overall matrix.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1742-L1786" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BlockRowMatrix(BlockMatrix):
    &#34;&#34;&#34;Matrix composed of horizontal concatenation of a series of blocks.&#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[Matrix]): Sequence of matrices defining a row of
                blocks in order left-to-right which when horizontally
                concatenated give the overall matrix.
        &#34;&#34;&#34;
        self._blocks = tuple(blocks)
        if not all(isinstance(block, Matrix) for block in self._blocks):
            raise ValueError(&#39;All blocks must be matrices&#39;)
        if len(set([block.shape[0] for block in self._blocks])) &gt; 1:
            raise ValueError(&#39;All blocks must have same row-dimension.&#39;)
        col_dims = tuple(block.shape[1] for block in self._blocks)
        super().__init__(shape=(self._blocks[0].shape[0], sum(col_dims)))
        self._splits = np.cumsum(col_dims[:-1])

    @property
    def blocks(self):
        &#34;&#34;&#34;Blocks of matrix in left-to-right order.&#34;&#34;&#34;
        return self._blocks

    def _left_matrix_multiply(self, other):
        assert other.shape[0] == self.shape[1]
        return sum(
            [block @ part for block, part in
             zip(self._blocks, np.split(other, self._splits, axis=0))])

    def _right_matrix_multiply(self, other):
        return np.concatenate(
            [other @ block for block in self._blocks], axis=-1)

    def _scalar_multiply(self, scalar):
        return BlockRowMatrix(
            tuple(scalar * block for block in self._blocks))

    def _construct_array(self):
        return np.concatenate([block.array for block in self._blocks], axis=1)

    @property
    def T(self):
        return BlockColumnMatrix(
            tuple(block.T for block in self._blocks))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.BlockMatrix" href="#mici.matrices.BlockMatrix">BlockMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.BlockRowMatrix.blocks"><code class="name">var <span class="ident">blocks</span></code></dt>
<dd>
<section class="desc"><p>Blocks of matrix in left-to-right order.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1761-L1764" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def blocks(self):
    &#34;&#34;&#34;Blocks of matrix in left-to-right order.&#34;&#34;&#34;
    return self._blocks</code></pre>
</details>
</dd>
<dt id="mici.matrices.BlockRowMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1783-L1786" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return BlockColumnMatrix(
        tuple(block.T for block in self._blocks))</code></pre>
</details>
</dd>
<dt id="mici.matrices.BlockRowMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p>
<p>Generally accessing this property should be avoided wherever possible
as the resulting array object may use a lot of memory and operations
with it will not be able to exploit any structure in the matrix.</p></section>
</dd>
<dt id="mici.matrices.BlockRowMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.BlockRowMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.BlockColumnMatrix"><code class="flex name class">
<span>class <span class="ident">BlockColumnMatrix</span></span>
<span>(</span><span>blocks)</span>
</code></dt>
<dd>
<section class="desc"><p>Matrix composed of vertical concatenation of a series of blocks.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blocks</code></strong> :&ensp;<code>Iterable</code>[<code>Matrix</code>]</dt>
<dd>Sequence of matrices defining a column
of blocks in order top-to-bottom which when vertically
concatenated give the overall matrix.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1789-L1833" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BlockColumnMatrix(BlockMatrix):
    &#34;&#34;&#34;Matrix composed of vertical concatenation of a series of blocks.&#34;&#34;&#34;

    def __init__(self, blocks):
        &#34;&#34;&#34;
        Args:
            blocks (Iterable[Matrix]): Sequence of matrices defining a column
                of blocks in order top-to-bottom which when vertically
                concatenated give the overall matrix.
        &#34;&#34;&#34;
        self._blocks = tuple(blocks)
        if not all(isinstance(block, Matrix) for block in self._blocks):
            raise ValueError(&#39;All blocks must be matrices&#39;)
        if len(set([block.shape[1] for block in self._blocks])) &gt; 1:
            raise ValueError(&#39;All blocks must have same column-dimension.&#39;)
        row_dims = tuple(block.shape[0] for block in self._blocks)
        super().__init__(shape=(sum(row_dims), self._blocks[0].shape[1]))
        self._splits = np.cumsum(row_dims[:-1])

    @property
    def blocks(self):
        &#34;&#34;&#34;Blocks of matrix in top-to-bottom order.&#34;&#34;&#34;
        return self._blocks

    def _left_matrix_multiply(self, other):
        return np.concatenate(
            [block @ other for block in self._blocks], axis=0)

    def _right_matrix_multiply(self, other):
        assert other.shape[-1] == self.shape[0]
        return sum(
            [part @ block for block, part in
             zip(self._blocks, np.split(other, self._splits, axis=-1))])

    def _scalar_multiply(self, scalar):
        return BlockColumnMatrix(
            tuple(scalar * block for block in self._blocks))

    def _construct_array(self):
        return np.concatenate([block.array for block in self._blocks], axis=0)

    @property
    def T(self):
        return BlockRowMatrix(
            tuple(block.T for block in self._blocks))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.BlockMatrix" href="#mici.matrices.BlockMatrix">BlockMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.BlockColumnMatrix.blocks"><code class="name">var <span class="ident">blocks</span></code></dt>
<dd>
<section class="desc"><p>Blocks of matrix in top-to-bottom order.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1808-L1811" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def blocks(self):
    &#34;&#34;&#34;Blocks of matrix in top-to-bottom order.&#34;&#34;&#34;
    return self._blocks</code></pre>
</details>
</dd>
<dt id="mici.matrices.BlockColumnMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1830-L1833" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return BlockRowMatrix(
        tuple(block.T for block in self._blocks))</code></pre>
</details>
</dd>
<dt id="mici.matrices.BlockColumnMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p>
<p>Generally accessing this property should be avoided wherever possible
as the resulting array object may use a lot of memory and operations
with it will not be able to exploit any structure in the matrix.</p></section>
</dd>
<dt id="mici.matrices.BlockColumnMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.BlockColumnMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.SquareLowRankUpdateMatrix"><code class="flex name class">
<span>class <span class="ident">SquareLowRankUpdateMatrix</span></span>
<span>(</span><span>left_factor_matrix, right_factor_matrix, square_matrix, inner_square_matrix=None, capacitance_matrix=None, sign=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Square matrix equal to a low-rank update to a square matrix.</p>
<p>The matrix is assumed to have the parametrisation</p>
<pre><code>matrix = (
    square_matrix + sign *
    left_factor_matrix @ inner_square_matrix @ right_factor_matrix)
</code></pre>
<p>where <code>left_factor_matrix</code> and <code>right_factor_matrix</code> are rectangular
with shapes <code>(dim_outer, dim_inner)</code> and <code>(dim_inner, dim_outer)</code>
resp., <code>square_matrix</code> is square with shape <code>(dim_outer, dim_outer)</code>,
<code>inner_square_matrix</code> is square with shape <code>(dim_inner, dim_inner)</code> and
<code>sign</code> is one of {-1, +1} and determines whether a low-rank update
(<code>sign = 1</code>) or 'downdate' (<code>sign = -1</code>) is peformed.</p>
<p>By exploiting the Woodbury matrix identity and matrix determinant lemma the
inverse and determinant of the matrix can be computed at a cost of
<code>O(dim_inner**3 + dim_inner**2 * dim_outer)</code> plus the cost of inverting /
evaluating the determinant of <code>square_matrix</code>, which for <code>square_matrix</code>
instances with special structure such as diagonality or with an existing
factorisation, will typically be cheaper than the <code>O(dim_outer**3)</code> cost
of evaluating the inverse or determinant directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>left_factor_matrix</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Rectangular matrix with shape
<code>(dim_outer, dim_inner)</code> forming leftmost term in matrix
product defining low-rank update.</dd>
<dt><strong><code>right_factor_matrix</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Rectangular matrix with shape
<code>(dim_inner, dim_outer)</code> forming rightmost term in matrix
product defining low-rank update.</dd>
<dt><strong><code>square_matrix</code></strong> :&ensp;<a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix"><code>SquareMatrix</code></a></dt>
<dd>Square matrix to perform low-rank
update (or downdate) to.</dd>
<dt><strong><code>inner_square_matrix</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix"><code>SquareMatrix</code></a></dt>
<dd>Optional square matrix
with shape <code>(dim_inner, dim_inner)</code> specifying inner term in
matrix product defining low-rank update. If <code>None</code> an identity
matrix is used.</dd>
<dt><strong><code>capacitance_matrix</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix"><code>SquareMatrix</code></a></dt>
<dd>Square matrix equal to
<code>inner_square_matrix.inv + right_factor_matrix @
square_matrix.inv @ left_factor_matrix</code> and with shape
<code>(dim_inner, dim_inner)</code> which is used in constructing inverse
and computation of determinant of the low-rank updated matrix,
with this argument optional and typically only passed when
this matrix has already been computed in a previous
computation.</dd>
<dt><strong><code>sign</code></strong> :&ensp;<code>int</code></dt>
<dd>One of {-1, +1}, determining whether a low-rank update
(<code>sign = 1</code>) or 'downdate' (<code>sign = -1</code>) is peformed.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1836-L1983" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SquareLowRankUpdateMatrix(InvertibleMatrix, ImplicitArrayMatrix):
    &#34;&#34;&#34;Square matrix equal to a low-rank update to a square matrix.

    The matrix is assumed to have the parametrisation

        matrix = (
            square_matrix + sign *
            left_factor_matrix @ inner_square_matrix @ right_factor_matrix)

    where `left_factor_matrix` and `right_factor_matrix` are rectangular
    with shapes `(dim_outer, dim_inner)` and `(dim_inner, dim_outer)`
    resp., `square_matrix` is square with shape `(dim_outer, dim_outer)`,
    `inner_square_matrix` is square with shape `(dim_inner, dim_inner)` and
    `sign` is one of {-1, +1} and determines whether a low-rank update
    (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.

    By exploiting the Woodbury matrix identity and matrix determinant lemma the
    inverse and determinant of the matrix can be computed at a cost of
    `O(dim_inner**3 + dim_inner**2 * dim_outer)` plus the cost of inverting /
    evaluating the determinant of `square_matrix`, which for `square_matrix`
    instances with special structure such as diagonality or with an existing
    factorisation, will typically be cheaper than the `O(dim_outer**3)` cost
    of evaluating the inverse or determinant directly.
    &#34;&#34;&#34;

    def __init__(self, left_factor_matrix, right_factor_matrix, square_matrix,
                 inner_square_matrix=None, capacitance_matrix=None, sign=1):
        &#34;&#34;&#34;
        Args:
            left_factor_matrix (Matrix): Rectangular matrix with shape
                `(dim_outer, dim_inner)` forming leftmost term in matrix
                product defining low-rank update.
            right_factor_matrix (Matrix): Rectangular matrix with shape
                `(dim_inner, dim_outer)` forming rightmost term in matrix
                product defining low-rank update.
            square_matrix (SquareMatrix): Square matrix to perform low-rank
                update (or downdate) to.
            inner_square_matrix (None or SquareMatrix): Optional square matrix
                with shape `(dim_inner, dim_inner)` specifying inner term in
                matrix product defining low-rank update. If `None` an identity
                matrix is used.
            capacitance_matrix (None or SquareMatrix): Square matrix equal to
                `inner_square_matrix.inv + right_factor_matrix @
                square_matrix.inv @ left_factor_matrix` and with shape
                `(dim_inner, dim_inner)` which is used in constructing inverse
                and computation of determinant of the low-rank updated matrix,
                with this argument optional and typically only passed when
                this matrix has already been computed in a previous
                computation.
            sign (int): One of {-1, +1}, determining whether a low-rank update
                (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.
        &#34;&#34;&#34;
        dim_outer, dim_inner = left_factor_matrix.shape
        if square_matrix.shape[0] != dim_outer:
            raise ValueError(f&#39;Inconsistent factor and square matrix shapes: &#39;
                             f&#39;outer dimensions {dim_outer} and &#39;
                             f&#39;{square_matrix.shape[0]}.&#39;)
        if square_matrix.shape[0] != square_matrix.shape[1]:
            raise ValueError(&#39;square_matrix argument must be square&#39;)
        if right_factor_matrix.shape != (dim_inner, dim_outer):
            raise ValueError(f&#39;Inconsistent factor matrix shapes: &#39;
                             f&#39;{left_factor_matrix.shape} and &#39;
                             f&#39;{right_factor_matrix.shape}.&#39;)
        if inner_square_matrix is None:
            inner_square_matrix = IdentityMatrix(dim_inner)
        elif inner_square_matrix.shape != (dim_inner, dim_inner):
            raise ValueError(f&#39;inner_square matrix must be square and of shape&#39;
                             f&#39; {(dim_inner, dim_inner)}.&#39;)
        self.left_factor_matrix = left_factor_matrix
        self.right_factor_matrix = right_factor_matrix
        self.square_matrix = square_matrix
        self.inner_square_matrix = inner_square_matrix
        self._capacitance_matrix = capacitance_matrix
        self._sign = sign
        super().__init__((dim_outer, dim_outer))

    def _left_matrix_multiply(self, other):
        return self.square_matrix @ other + (
            self._sign * self.left_factor_matrix @ (
                self.inner_square_matrix @ (self.right_factor_matrix @ other)))

    def _right_matrix_multiply(self, other):
        return other @ self.square_matrix + (
            self._sign * (
                other @ self.left_factor_matrix) @ self.inner_square_matrix
            ) @ self.right_factor_matrix

    def _scalar_multiply(self, scalar):
        return type(self)(
            self.left_factor_matrix, self.right_factor_matrix,
            scalar * self.square_matrix, scalar * self.inner_square_matrix,
            self._capacitance_matrix / scalar
            if self._capacitance_matrix is not None else None, self._sign)

    def _construct_array(self):
        return self.square_matrix.array + (
            self._sign * self.left_factor_matrix @ (
                self.inner_square_matrix @ self.right_factor_matrix.array))

    @property
    def capacitance_matrix(self):
        if self._capacitance_matrix is None:
            self._capacitance_matrix = DenseSquareMatrix(
                self.inner_square_matrix.inv.array +
                self.right_factor_matrix @ (
                    self.square_matrix.inv @ self.left_factor_matrix.array))
        return self._capacitance_matrix

    @property
    def diagonal(self):
        return self.square_matrix.diagonal + self._sign * (
            (self.left_factor_matrix.array @ self.inner_square_matrix) *
            self.right_factor_matrix.T.array).sum(1)

    @property
    def T(self):
        return type(self)(
            self.right_factor_matrix.T, self.left_factor_matrix.T,
            self.square_matrix.T, self.inner_square_matrix.T,
            self._capacitance_matrix.T
            if self._capacitance_matrix is not None else None,
            self._sign)

    @property
    def inv(self):
        return type(self)(
            self.square_matrix.inv @ self.left_factor_matrix,
            self.right_factor_matrix @ self.square_matrix.inv,
            self.square_matrix.inv, self.capacitance_matrix.inv,
            self.inner_square_matrix.inv, -self._sign)

    @property
    def log_abs_det(self):
        return (
            self.square_matrix.log_abs_det +
            self.inner_square_matrix.log_abs_det +
            self.capacitance_matrix.log_abs_det)

    def _compute_hash(self):
        return hash((self.left_factor_matrix, self.right_factor_matrix,
                     self.square_matrix, self.inner_square_matrix))

    def _check_equality(self, other):
        return (
            self.left_factor_matrix == other.left_factor_matrix and
            self.right_factor_matrix == other.right_factor_matrix and
            self.square_matrix == other.square_matrix and
            self.inner_square_matrix == other.inner_square_matrix)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.SymmetricLowRankUpdateMatrix" href="#mici.matrices.SymmetricLowRankUpdateMatrix">SymmetricLowRankUpdateMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.SquareLowRankUpdateMatrix.capacitance_matrix"><code class="name">var <span class="ident">capacitance_matrix</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1935-L1942" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def capacitance_matrix(self):
    if self._capacitance_matrix is None:
        self._capacitance_matrix = DenseSquareMatrix(
            self.inner_square_matrix.inv.array +
            self.right_factor_matrix @ (
                self.square_matrix.inv @ self.left_factor_matrix.array))
    return self._capacitance_matrix</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareLowRankUpdateMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1944-L1948" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def diagonal(self):
    return self.square_matrix.diagonal + self._sign * (
        (self.left_factor_matrix.array @ self.inner_square_matrix) *
        self.right_factor_matrix.T.array).sum(1)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareLowRankUpdateMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1950-L1957" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return type(self)(
        self.right_factor_matrix.T, self.left_factor_matrix.T,
        self.square_matrix.T, self.inner_square_matrix.T,
        self._capacitance_matrix.T
        if self._capacitance_matrix is not None else None,
        self._sign)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareLowRankUpdateMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1959-L1965" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return type(self)(
        self.square_matrix.inv @ self.left_factor_matrix,
        self.right_factor_matrix @ self.square_matrix.inv,
        self.square_matrix.inv, self.capacitance_matrix.inv,
        self.inner_square_matrix.inv, -self._sign)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareLowRankUpdateMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1967-L1972" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_abs_det(self):
    return (
        self.square_matrix.log_abs_det +
        self.inner_square_matrix.log_abs_det +
        self.capacitance_matrix.log_abs_det)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SquareLowRankUpdateMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.SquareLowRankUpdateMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix"><code class="flex name class">
<span>class <span class="ident">SymmetricLowRankUpdateMatrix</span></span>
<span>(</span><span>factor_matrix, symmetric_matrix, inner_symmetric_matrix=None, capacitance_matrix=None, sign=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Symmetric matrix equal to a low-rank update to a symmetric matrix.</p>
<p>The matrix is assumed to have the parametrisation</p>
<pre><code>matrix = (
    symmetric_matrix +
    sign * factor_matrix @ inner_symmetric_matrix @ factor_matrix.T)
</code></pre>
<p>where <code>factor_matrix</code> is rectangular with shape <code>(dim_outer, dim_inner)</code>,
<code>symmetric_matrix</code> is symmetric with shape <code>(dim_outer, dim_outer)</code>,
<code>inner_symmetric_matrix</code> is symmetric with shape <code>(dim_inner, dim_inner)</code>
and <code>sign</code> is one of {-1, +1} and determines whether a low-rank update
(<code>sign = 1</code>) or 'downdate' (<code>sign = -1</code>) is peformed.</p>
<p>By exploiting the Woodbury matrix identity and matrix determinant lemma the
inverse and determinant of the matrix can be computed at a cost of
<code>O(dim_inner**3 + dim_inner**2 * dim_outer)</code> plus the cost of inverting /
evaluating the determinant of <code>square_matrix</code>, which for <code>square_matrix</code>
instances with special structure such as diagonality or with an existing
factorisation, will typically be cheaper than the <code>O(dim_outer**3)</code> cost
of evaluating the inverse or determinant directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factor_matrix</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Rectangular matrix with shape
<code>(dim_outer, dim_inner)</code> with it and its transpose forming the
leftmost and righmost term respectively in the matrix product
defining the low-rank update.</dd>
<dt><strong><code>symmetric_matrix</code></strong> :&ensp;<a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix"><code>SymmetricMatrix</code></a></dt>
<dd>Symmetric matrix to perform
low-rank update (or downdate) to.</dd>
<dt><strong><code>inner_symmetric_matrix</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix"><code>SymmetricMatrix</code></a></dt>
<dd>Optional
symmetric matrix with shape <code>(dim_inner, dim_inner)</code> specifying
inner term in matrix product defining low-rank update. If
<code>None</code> an identity matrix is used.</dd>
<dt><strong><code>capacitance_matrix</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix"><code>SymmetricMatrix</code></a></dt>
<dd>Symmetric matrix
equal to <code>inner_symmetric_matrix.inv + factor_matrix.T @
symmetric_matrix.inv @ factor_matrix</code> and with shape
<code>(dim_inner, dim_inner)</code> which is used in constructing inverse
and computation of determinant of the low-rank updated matrix,
with this argument optional and typically only passed when
this matrix has already been computed in a previous
computation.</dd>
<dt><strong><code>sign</code></strong> :&ensp;<code>int</code></dt>
<dd>One of {-1, +1}, determining whether a low-rank update
(<code>sign = 1</code>) or 'downdate' (<code>sign = -1</code>) is peformed.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L1986-L2082" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SymmetricLowRankUpdateMatrix(
        SquareLowRankUpdateMatrix, SymmetricMatrix, InvertibleMatrix):
    &#34;&#34;&#34;Symmetric matrix equal to a low-rank update to a symmetric matrix.

    The matrix is assumed to have the parametrisation

        matrix = (
            symmetric_matrix +
            sign * factor_matrix @ inner_symmetric_matrix @ factor_matrix.T)

    where `factor_matrix` is rectangular with shape `(dim_outer, dim_inner)`,
    `symmetric_matrix` is symmetric with shape `(dim_outer, dim_outer)`,
    `inner_symmetric_matrix` is symmetric with shape `(dim_inner, dim_inner)`
    and `sign` is one of {-1, +1} and determines whether a low-rank update
    (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.

    By exploiting the Woodbury matrix identity and matrix determinant lemma the
    inverse and determinant of the matrix can be computed at a cost of
    `O(dim_inner**3 + dim_inner**2 * dim_outer)` plus the cost of inverting /
    evaluating the determinant of `square_matrix`, which for `square_matrix`
    instances with special structure such as diagonality or with an existing
    factorisation, will typically be cheaper than the `O(dim_outer**3)` cost
    of evaluating the inverse or determinant directly.
    &#34;&#34;&#34;

    def __init__(self, factor_matrix, symmetric_matrix,
                 inner_symmetric_matrix=None, capacitance_matrix=None, sign=1):
        &#34;&#34;&#34;
        Args:
            factor_matrix (Matrix): Rectangular matrix with shape
                `(dim_outer, dim_inner)` with it and its transpose forming the
                leftmost and righmost term respectively in the matrix product
                defining the low-rank update.
            symmetric_matrix (SymmetricMatrix): Symmetric matrix to perform
                low-rank update (or downdate) to.
            inner_symmetric_matrix (None or SymmetricMatrix): Optional
                symmetric matrix with shape `(dim_inner, dim_inner)` specifying
                inner term in matrix product defining low-rank update. If
                `None` an identity matrix is used.
            capacitance_matrix (None or SymmetricMatrix): Symmetric matrix
                equal to `inner_symmetric_matrix.inv + factor_matrix.T @
                symmetric_matrix.inv @ factor_matrix` and with shape
                `(dim_inner, dim_inner)` which is used in constructing inverse
                and computation of determinant of the low-rank updated matrix,
                with this argument optional and typically only passed when
                this matrix has already been computed in a previous
                computation.
            sign (int): One of {-1, +1}, determining whether a low-rank update
                (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.
        &#34;&#34;&#34;
        if symmetric_matrix.T is not symmetric_matrix:
            raise ValueError(&#39;symmetric_matrix must be symmetric&#39;)
        if inner_symmetric_matrix.T is not inner_symmetric_matrix:
            raise ValueError(&#39;inner_symmetric_matrix must be symmetric&#39;)
        self.factor_matrix = factor_matrix
        self.symmetric_matrix = symmetric_matrix
        self.inner_symmetric_matrix = inner_symmetric_matrix
        super().__init__(
            factor_matrix, factor_matrix.T, symmetric_matrix,
            inner_symmetric_matrix, capacitance_matrix, sign)

    def _scalar_multiply(self, scalar):
        return type(self)(
            self.factor_matrix, scalar * self.symmetric_matrix,
            scalar * self.inner_symmetric_matrix,
            self._capacitance_matrix / scalar
            if self._capacitance_matrix is not None else None, self._sign)

    @property
    def capacitance_matrix(self):
        if self._capacitance_matrix is None:
            self._capacitance_matrix = DenseSymmetricMatrix(
                self.inner_symmetric_matrix.inv.array +
                self.factor_matrix.T @ (
                    self.symmetric_matrix.inv @ self.factor_matrix.array))
        return self._capacitance_matrix

    @property
    def inv(self):
        return type(self)(
            self.symmetric_matrix.inv @ self.factor_matrix,
            self.symmetric_matrix.inv, self.capacitance_matrix.inv,
            self.inner_symmetric_matrix.inv, -self._sign)

    @property
    def T(self):
        return self

    def _compute_hash(self):
        return hash((
            self.factor_matrix, self.square_matrix, self.inner_square_matrix))

    def _check_equality(self, other):
        return (
            self.factor_matrix == other.factor_matrix and
            self.square_matrix == other.square_matrix and
            self.inner_square_matrix == other.inner_square_matrix)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.SquareLowRankUpdateMatrix" href="#mici.matrices.SquareLowRankUpdateMatrix">SquareLowRankUpdateMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.matrices.PositiveDefiniteLowRankUpdateMatrix" href="#mici.matrices.PositiveDefiniteLowRankUpdateMatrix">PositiveDefiniteLowRankUpdateMatrix</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.capacitance_matrix"><code class="name">var <span class="ident">capacitance_matrix</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L2054-L2061" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def capacitance_matrix(self):
    if self._capacitance_matrix is None:
        self._capacitance_matrix = DenseSymmetricMatrix(
            self.inner_symmetric_matrix.inv.array +
            self.factor_matrix.T @ (
                self.symmetric_matrix.inv @ self.factor_matrix.array))
    return self._capacitance_matrix</code></pre>
</details>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L2063-L2068" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def inv(self):
    return type(self)(
        self.symmetric_matrix.inv @ self.factor_matrix,
        self.symmetric_matrix.inv, self.capacitance_matrix.inv,
        self.inner_symmetric_matrix.inv, -self._sign)</code></pre>
</details>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L2070-L2072" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def T(self):
    return self</code></pre>
</details>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.SymmetricLowRankUpdateMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
</dl>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix"><code class="flex name class">
<span>class <span class="ident">PositiveDefiniteLowRankUpdateMatrix</span></span>
<span>(</span><span>factor_matrix, pos_def_matrix, inner_pos_def_matrix=None, capacitance_matrix=None, sign=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Positive-definite matrix equal to low-rank update to a square matrix.</p>
<p>The matrix is assumed to have the parametrisation</p>
<pre><code>matrix = (
    pos_def_matrix +
    sign * factor_matrix @ inner_pos_def_matrix @ factor_matrix.T)
</code></pre>
<p>where <code>factor_matrix</code> is rectangular with shape <code>(dim_outer, dim_inner)</code>,
<code>pos_def_matrix</code> is positive-definite with shape <code>(dim_outer, dim_outer)</code>,
<code>inner_pos_def_matrix</code> is positive-definite with shape
<code>(dim_inner, dim_inner)</code> and <code>sign</code> is one of {-1, +1} and determines
whether a low-rank update (<code>sign = 1</code>) or 'downdate' (<code>sign = -1</code>) is
peformed.</p>
<p>By exploiting the Woodbury matrix identity and matrix determinant lemma the
inverse, determinant and square-root of the matrix can all be computed at a
cost of <code>O(dim_inner**3 + dim_inner**2 * dim_outer)</code> plus the cost of
inverting / evaluating the determinant / square_root of <code>pos_def_matrix</code>,
which for <code>pos_def_matrix</code> instances with special structure such as
diagonality or with an existing factorisation, will typically be cheaper
than the <code>O(dim_outer**3)</code> cost of evaluating the inverse, determinant or
square-root directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factor_matrix</code></strong> :&ensp;<a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a></dt>
<dd>Rectangular matrix with shape
<code>(dim_outer, dim_inner)</code> with it and its transpose forming the
leftmost and righmost term respectively in the matrix product
defining the low-rank update.</dd>
<dt><strong><code>pos_def_matrix</code></strong> :&ensp;<a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a></dt>
<dd>Positive-definite matrix
to perform low-rank update (or downdate) to.</dd>
<dt><strong><code>inner_pos_def_matrix</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a></dt>
<dd>Optional
positive definite matrix with shape <code>(dim_inner, dim_inner)</code>
specifying inner term in matrix product defining low-rank
update. If <code>None</code> an identity matrix is used.</dd>
<dt><strong><code>capacitance_matrix</code></strong> :&ensp;<code>None</code> or <a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix"><code>PositiveDefiniteMatrix</code></a></dt>
<dd>Positive-
definite matrix equal to <code>inner_pos_def_matrix.inv +
factor_matrix.T @ pos_def_matrix.inv @ factor_matrix</code> and with
shape <code>(dim_inner, dim_inner)</code> which is used in constructing
inverse and computation of determinant of the low-rank updated
matrix, with this argument optional and typically only passed
when this matrix has already been computed in a previous
computation.</dd>
<dt><strong><code>sign</code></strong> :&ensp;<code>int</code></dt>
<dd>One of {-1, +1}, determining whether a low-rank update
(<code>sign = 1</code>) or 'downdate' (<code>sign = -1</code>) is peformed.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L2085-L2195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PositiveDefiniteLowRankUpdateMatrix(
        PositiveDefiniteMatrix, DifferentiableMatrix,
        SymmetricLowRankUpdateMatrix):
    &#34;&#34;&#34;Positive-definite matrix equal to low-rank update to a square matrix.

    The matrix is assumed to have the parametrisation

        matrix = (
            pos_def_matrix +
            sign * factor_matrix @ inner_pos_def_matrix @ factor_matrix.T)

    where `factor_matrix` is rectangular with shape `(dim_outer, dim_inner)`,
    `pos_def_matrix` is positive-definite with shape `(dim_outer, dim_outer)`,
    `inner_pos_def_matrix` is positive-definite with shape
    `(dim_inner, dim_inner)` and `sign` is one of {-1, +1} and determines
    whether a low-rank update (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is
    peformed.

    By exploiting the Woodbury matrix identity and matrix determinant lemma the
    inverse, determinant and square-root of the matrix can all be computed at a
    cost of `O(dim_inner**3 + dim_inner**2 * dim_outer)` plus the cost of
    inverting / evaluating the determinant / square_root of `pos_def_matrix`,
    which for `pos_def_matrix` instances with special structure such as
    diagonality or with an existing factorisation, will typically be cheaper
    than the `O(dim_outer**3)` cost of evaluating the inverse, determinant or
    square-root directly.
    &#34;&#34;&#34;

    def __init__(self, factor_matrix, pos_def_matrix,
                 inner_pos_def_matrix=None, capacitance_matrix=None, sign=1):
        &#34;&#34;&#34;
        Args:
            factor_matrix (Matrix): Rectangular matrix with shape
                `(dim_outer, dim_inner)` with it and its transpose forming the
                leftmost and righmost term respectively in the matrix product
                defining the low-rank update.
            pos_def_matrix (PositiveDefiniteMatrix): Positive-definite matrix
                to perform low-rank update (or downdate) to.
            inner_pos_def_matrix (None or PositiveDefiniteMatrix): Optional
                positive definite matrix with shape `(dim_inner, dim_inner)`
                specifying inner term in matrix product defining low-rank
                update. If `None` an identity matrix is used.
            capacitance_matrix (None or PositiveDefiniteMatrix): Positive-
                definite matrix equal to `inner_pos_def_matrix.inv +
                factor_matrix.T @ pos_def_matrix.inv @ factor_matrix` and with
                shape `(dim_inner, dim_inner)` which is used in constructing
                inverse and computation of determinant of the low-rank updated
                matrix, with this argument optional and typically only passed
                when this matrix has already been computed in a previous
                computation.
            sign (int): One of {-1, +1}, determining whether a low-rank update
                (`sign = 1`) or &#39;downdate&#39; (`sign = -1`) is peformed.
        &#34;&#34;&#34;
        self.factor_matrix = factor_matrix
        self.pos_def_matrix = pos_def_matrix
        self.inner_pos_def_matrix = inner_pos_def_matrix
        super().__init__(
            factor_matrix, pos_def_matrix, inner_pos_def_matrix,
            capacitance_matrix, sign)

    def _scalar_multiply(self, scalar):
        if scalar &gt; 0:
            return PositiveDefiniteLowRankUpdateMatrix(
                self.factor_matrix, scalar * self.pos_def_matrix,
                scalar * self.inner_pos_def_matrix,
                self._capacitance_matrix / scalar
                if self._capacitance_matrix is not None else None, self._sign)
        else:
            return SymmetricLowRankUpdateMatrix(
                self.factor_matrix, scalar * self.pos_def_matrix,
                scalar * self.inner_pos_def_matrix,
                self._capacitance_matrix / scalar
                if self._capacitance_matrix is not None else None, self._sign)

    @property
    def capacitance_matrix(self):
        if self._capacitance_matrix is None:
            self._capacitance_matrix = DensePositiveDefiniteMatrix(
                self.inner_pos_def_matrix.inv.array +
                self.factor_matrix.T @ (
                    self.pos_def_matrix.inv @
                    self.factor_matrix.array))
        return self._capacitance_matrix

    @property
    def sqrt(self):
        # Uses O(dim_inner**3 + dim_inner**2 * dim_outer) cost implementation
        # proposed in
        #   Ambikasaran, O&#39;Neill &amp; Singh (2016). Fast symmetric factorization
        #   of hierarchical matrices with applications. arxiv:1405.0223.
        # Variable naming below follows notation in Algorithm 1 in paper
        W = self.pos_def_matrix.sqrt
        K = self.inner_pos_def_matrix
        U = W.inv @ self.factor_matrix
        L = TriangularMatrix(nla.cholesky(U.T @ U.array))
        I_outer, I_inner = IdentityMatrix(U.shape[0]), np.identity(U.shape[1])
        M = sla.sqrtm(I_inner + L.T @ (K @ L.array))
        X = DenseSymmetricMatrix(L.inv.T @ ((M - I_inner) @ L.inv))
        return W @ SymmetricLowRankUpdateMatrix(U, I_outer, X)

    @property
    def grad_log_abs_det(self):
        return 2 * (self.inv @ (
            self.factor_matrix.array @ self.inner_pos_def_matrix))

    def grad_quadratic_form_inv(self, vector):
        inv_matrix_vector = self.inv @ vector
        return -2 * np.outer(
            inv_matrix_vector,
            self.inner_pos_def_matrix @ (
                self.factor_matrix.T @ inv_matrix_vector))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.matrices.PositiveDefiniteMatrix" href="#mici.matrices.PositiveDefiniteMatrix">PositiveDefiniteMatrix</a></li>
<li><a title="mici.matrices.DifferentiableMatrix" href="#mici.matrices.DifferentiableMatrix">DifferentiableMatrix</a></li>
<li><a title="mici.matrices.SymmetricLowRankUpdateMatrix" href="#mici.matrices.SymmetricLowRankUpdateMatrix">SymmetricLowRankUpdateMatrix</a></li>
<li><a title="mici.matrices.SquareLowRankUpdateMatrix" href="#mici.matrices.SquareLowRankUpdateMatrix">SquareLowRankUpdateMatrix</a></li>
<li><a title="mici.matrices.SymmetricMatrix" href="#mici.matrices.SymmetricMatrix">SymmetricMatrix</a></li>
<li><a title="mici.matrices.InvertibleMatrix" href="#mici.matrices.InvertibleMatrix">InvertibleMatrix</a></li>
<li><a title="mici.matrices.SquareMatrix" href="#mici.matrices.SquareMatrix">SquareMatrix</a></li>
<li><a title="mici.matrices.ImplicitArrayMatrix" href="#mici.matrices.ImplicitArrayMatrix">ImplicitArrayMatrix</a></li>
<li><a title="mici.matrices.Matrix" href="#mici.matrices.Matrix">Matrix</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.capacitance_matrix"><code class="name">var <span class="ident">capacitance_matrix</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L2159-L2167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def capacitance_matrix(self):
    if self._capacitance_matrix is None:
        self._capacitance_matrix = DensePositiveDefiniteMatrix(
            self.inner_pos_def_matrix.inv.array +
            self.factor_matrix.T @ (
                self.pos_def_matrix.inv @
                self.factor_matrix.array))
    return self._capacitance_matrix</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.sqrt"><code class="name">var <span class="ident">sqrt</span></code></dt>
<dd>
<section class="desc"><p>Square-root of matrix satisfying <code>matrix == sqrt @ sqrt.T</code>.</p>
<p>This will in general not correspond to the unique, if defined,
symmetric square root of a symmetric matrix but instead may return any
matrix satisfying the above property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L2169-L2183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sqrt(self):
    # Uses O(dim_inner**3 + dim_inner**2 * dim_outer) cost implementation
    # proposed in
    #   Ambikasaran, O&#39;Neill &amp; Singh (2016). Fast symmetric factorization
    #   of hierarchical matrices with applications. arxiv:1405.0223.
    # Variable naming below follows notation in Algorithm 1 in paper
    W = self.pos_def_matrix.sqrt
    K = self.inner_pos_def_matrix
    U = W.inv @ self.factor_matrix
    L = TriangularMatrix(nla.cholesky(U.T @ U.array))
    I_outer, I_inner = IdentityMatrix(U.shape[0]), np.identity(U.shape[1])
    M = sla.sqrtm(I_inner + L.T @ (K @ L.array))
    X = DenseSymmetricMatrix(L.inv.T @ ((M - I_inner) @ L.inv))
    return W @ SymmetricLowRankUpdateMatrix(U, I_outer, X)</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.grad_log_abs_det"><code class="name">var <span class="ident">grad_log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Gradient of logarithm of absolute value of determinant of matrix.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L2185-L2188" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def grad_log_abs_det(self):
    return 2 * (self.inv @ (
        self.factor_matrix.array @ self.inner_pos_def_matrix))</code></pre>
</details>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.eigval"><code class="name">var <span class="ident">eigval</span></code></dt>
<dd>
<section class="desc"><p>Eigenvalues of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.eigvec"><code class="name">var <span class="ident">eigvec</span></code></dt>
<dd>
<section class="desc"><p>Eigenvectors of matrix stacked as columns of a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<section class="desc"><p>Transpose of matrix.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.log_abs_det"><code class="name">var <span class="ident">log_abs_det</span></code></dt>
<dd>
<section class="desc"><p>Logarithm of absolute value of determinant of matrix.</p>
<p>For matrix representations of metrics it is proportional to the
logarithm of the density of then Riemannian measure associated with
metric with respect to the Lebesgue measure.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Shape of matrix as a tuple <code>(num_rows, num_columns)</code>.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<section class="desc"><p>Full dense representation of matrix as a 2D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.diagonal"><code class="name">var <span class="ident">diagonal</span></code></dt>
<dd>
<section class="desc"><p>Diagonal of matrix as a 1D array.</p></section>
</dd>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.inv"><code class="name">var <span class="ident">inv</span></code></dt>
<dd>
<section class="desc"><p>Inverse of matrix as a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object.</p>
<p>This will not necessarily form an explicit representation of the
inverse matrix but may instead return a <a title="mici.matrices.Matrix" href="#mici.matrices.Matrix"><code>Matrix</code></a> object that implements
the matrix multiplication operators by solving the linear system
defined by the original matrix object.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.matrices.PositiveDefiniteLowRankUpdateMatrix.grad_quadratic_form_inv"><code class="name flex">
<span>def <span class="ident">grad_quadratic_form_inv</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Gradient of quadratic form <code>vector @ matrix.inv @ vector</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>array</code></dt>
<dd>1D array representing vector to evaluate quadratic
form at.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/be3c4cd91f60faf5182ee5704e8e9e61e5dc5b23/mici/matrices.py#L2190-L2195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grad_quadratic_form_inv(self, vector):
    inv_matrix_vector = self.inv @ vector
    return -2 * np.outer(
        inv_matrix_vector,
        self.inner_pos_def_matrix @ (
            self.factor_matrix.T @ inv_matrix_vector))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
Copyright © 2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2.dev0+g1b644f6.d20200507</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad(); hljs.configure({languages: ["python"]});</script>
</body>
</html>