<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2.dev0+g1b644f6.d20200630" />
<title>mici.states API documentation</title>
<meta name="description" content="Objects for recording state of a Markov chain." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding-top:5px;padding-bottom:5px;padding-right:10px;padding-left:35px;text-indent:-25px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:1000px){#sidebar{width:540px;position:fixed;z-index:1;top:0;bottom:0;overflow-x:hidden;overflow-y:auto}#content{margin-left:540px;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}#footer{margin-left:540px}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mici.states.cache_in_state" href="#mici.states.cache_in_state">cache_in_state</a></code></li>
<li><code><a title="mici.states.multi_cache_in_state" href="#mici.states.multi_cache_in_state">multi_cache_in_state</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<code><a title="mici.states.ChainState" href="#mici.states.ChainState">ChainState</a></code>
<ul class="">
<li><code><a title="mici.states.ChainState.copy" href="#mici.states.ChainState.copy">copy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Module <code>mici.states</code></h1>
</header>
<section id="section-intro">
<p>Objects for recording state of a Markov chain.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/states.py#L0-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Objects for recording state of a Markov chain.&#34;&#34;&#34;

import copy
from functools import wraps
from mici.errors import ReadOnlyStateError


def cache_in_state(*depends_on):
    &#34;&#34;&#34;Decorator to memoize / cache output of a function of state variable(s).

    Used to wrap functions of a chain state vaiable(s) to allow caching of
    the values computed to prevent recomputation when possible.

    Args:
       *depends_on: One or more strings defining which state variables the
           computed values depend on e.g. &#39;pos&#39;, &#39;mom&#39;, such that the cache is
           correctly cleared when one of these parent dependency&#39;s value
           changes.
    &#34;&#34;&#34;
    def cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            key = type(self).__name__ + &#39;.&#39; + method.__name__
            if key not in state._cache:
                for dep in depends_on:
                    state._dependencies[dep].add(key)
            if key not in state._cache or state._cache[key] is None:
                state._cache[key] = method(self, state)
                if state._call_counts is not None:
                    if key not in state._call_counts:
                        state._call_counts[key] = 1
                    else:
                        state._call_counts[key] += 1
            return state._cache[key]
        return wrapper
    return cache_in_state_decorator


def multi_cache_in_state(depends_on, variables, primary_index=0):
    &#34;&#34;&#34;Decorator to cache multiple outputs of a function of state variable(s).

    Used to wrap functions of a chain state vaiable(s) to allow caching of
    the values computed to prevent recomputation when possible.

    This variant allows for functions which also cache intermediate computed
    results which may be used separately elsewhere for example the value of a
    function calculate in the forward pass of a reverse-mode automatic-
    differentation implementation of its gradient.

    Args:
        depends_on (List[str]): A list of strings defining which state
            variables the computed values depend on e.g. `[&#39;pos&#39;, &#39;mom&#39;]`, such
            that the cache is correctly cleared when one of these parent
            dependency&#39;s value changes.
        variables (List[str]): A list of strings defining the variables in the
            state cache dict corresponding to the outputs of the wrapped
            function (method) in the corresponding returned order.
        primary_index (int): Index of primary output of function (i.e. value to
            be returned) in `variables` list / position in output of function.
    &#34;&#34;&#34;
    def multi_cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            type_prefix = type(self).__name__ + &#39;.&#39;
            prim_key = type_prefix + variables[primary_index]
            keys = [type_prefix + v for v in variables]
            for i, key in enumerate(keys):
                if key not in state._cache:
                    for dep in depends_on:
                        state._dependencies[dep].add(key)
            if prim_key not in state._cache or state._cache[prim_key] is None:
                vals = method(self, state)
                if isinstance(vals, tuple):
                    for k, v in zip(keys, vals):
                        state._cache[k] = v
                else:
                    state._cache[prim_key] = vals
                if state._call_counts is not None:
                    if prim_key not in state._call_counts:
                        state._call_counts[prim_key] = 1
                    else:
                        state._call_counts[prim_key] += 1
            return state._cache[prim_key]
        return wrapper
    return multi_cache_in_state_decorator


class ChainState(object):
    &#34;&#34;&#34;Markov chain state.

    As well as recording the chain state variable values, the state object is
    also used to cache derived quantities to avoid recalculation if these
    values are subsequently reused.
    &#34;&#34;&#34;

    def __init__(self, _dependencies=None, _cache=None, _call_counts=None,
                 _read_only=False, **variables):
        &#34;&#34;&#34;Create a new `ChainState` instance.

        Any keyword arguments passed to the constructor will be used to set
        state variable attributes of state object for example

            state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)

        will return a `ChainState` instance `state` with variable attributes
        `state.pos`, `state.mom` and `state.dir` with initial values set to
        `pos_val`, `mom_val` and `dir_val` respectively. The keyword arguments
        `_dependencies`, `_cache`, `_call_counts` and `_read_only` are reserved
        respectively for the dependency set, cache dictionary, call count
        dictionary and a flag to make the state read-only and cannot be used as
        state variable names.
        &#34;&#34;&#34;
        # Set attributes by directly writing to __dict__ to ensure set before
        # any call to __setattr__
        self.__dict__[&#39;_variables&#39;] = variables
        if _dependencies is None:
            _dependencies = {name: set() for name in variables}
        self.__dict__[&#39;_dependencies&#39;] = _dependencies
        if _cache is None:
            _cache = {}
        self.__dict__[&#39;_cache&#39;] = _cache
        self.__dict__[&#39;_call_counts&#39;] = _call_counts
        self.__dict__[&#39;_read_only&#39;] = _read_only

    def __getattr__(self, name):
        if name in self._variables:
            return self._variables[name]
        else:
            raise AttributeError(
                f&#34;&#39;{type(self).__name__}&#39; object has no attribute &#39;{name}&#39;&#34;)

    def __setattr__(self, name, value):
        if self._read_only:
            raise ReadOnlyStateError(&#39;ChainState instance is read-only.&#39;)
        if name in self._variables:
            self._variables[name] = value
            # clear any dependent cached values
            for dep in self._dependencies[name]:
                self._cache[dep] = None
        else:
            return super().__setattr__(name, value)

    def __contains__(self, name):
        return name in self._variables

    def copy(self, read_only=False):
        &#34;&#34;&#34;Create a deep copy of the state object.

        Args:
            read_only (bool): Whether the state copy should be read-only.

        Returns:
            state_copy (ChainState): A copy of the state object with variable
                attributes that are independent copies of the original state
                object&#39;s variables.
        &#34;&#34;&#34;
        return type(self)(
            _dependencies=self._dependencies, _cache=self._cache.copy(),
            _call_counts=self._call_counts, _read_only=read_only,
            **{name: copy.copy(val) for name, val in self._variables.items()})

    def __str__(self):
        return (
            &#39;(\n &#39; +
            &#39;,\n &#39;.join([f&#39;{k}={v}&#39; for k, v in self._variables.items()]) +
            &#39;)&#39;
        )

    def __repr__(self):
        return type(self).__name__ + str(self)

    def __getstate__(self):
        return {
            &#39;variables&#39;: self._variables,
            &#39;dependencies&#39;: self._dependencies,
            # Don&#39;t pickle callable cached &#39;variables&#39; such as derivative
            # functions
            &#39;cache&#39;: {k: v for k, v in self._cache.items() if not callable(v)},
            &#39;call_counts&#39;: self._call_counts,
            &#39;read_only&#39;: self._read_only}

    def __setstate__(self, state):
        self.__dict__[&#39;_variables&#39;] = state[&#39;variables&#39;]
        self.__dict__[&#39;_dependencies&#39;] = state[&#39;dependencies&#39;]
        self.__dict__[&#39;_cache&#39;] = state[&#39;cache&#39;]
        self.__dict__[&#39;_call_counts&#39;] = state[&#39;call_counts&#39;]
        self.__dict__[&#39;_read_only&#39;] = state[&#39;read_only&#39;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mici.states.cache_in_state"><code class="name flex">
<span>def <span class="ident">cache_in_state</span></span>(<span>*depends_on)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator to memoize / cache output of a function of state variable(s).</p>
<p>Used to wrap functions of a chain state vaiable(s) to allow caching of
the values computed to prevent recomputation when possible.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*depends_on</code></strong></dt>
<dd>One or more strings defining which state variables the
computed values depend on e.g. 'pos', 'mom', such that the cache is
correctly cleared when one of these parent dependency's value
changes.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/states.py#L8-L36" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cache_in_state(*depends_on):
    &#34;&#34;&#34;Decorator to memoize / cache output of a function of state variable(s).

    Used to wrap functions of a chain state vaiable(s) to allow caching of
    the values computed to prevent recomputation when possible.

    Args:
       *depends_on: One or more strings defining which state variables the
           computed values depend on e.g. &#39;pos&#39;, &#39;mom&#39;, such that the cache is
           correctly cleared when one of these parent dependency&#39;s value
           changes.
    &#34;&#34;&#34;
    def cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            key = type(self).__name__ + &#39;.&#39; + method.__name__
            if key not in state._cache:
                for dep in depends_on:
                    state._dependencies[dep].add(key)
            if key not in state._cache or state._cache[key] is None:
                state._cache[key] = method(self, state)
                if state._call_counts is not None:
                    if key not in state._call_counts:
                        state._call_counts[key] = 1
                    else:
                        state._call_counts[key] += 1
            return state._cache[key]
        return wrapper
    return cache_in_state_decorator</code></pre>
</details>
</dd>
<dt id="mici.states.multi_cache_in_state"><code class="name flex">
<span>def <span class="ident">multi_cache_in_state</span></span>(<span>depends_on, variables, primary_index=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator to cache multiple outputs of a function of state variable(s).</p>
<p>Used to wrap functions of a chain state vaiable(s) to allow caching of
the values computed to prevent recomputation when possible.</p>
<p>This variant allows for functions which also cache intermediate computed
results which may be used separately elsewhere for example the value of a
function calculate in the forward pass of a reverse-mode automatic-
differentation implementation of its gradient.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>depends_on</code></strong> :&ensp;<code>List</code>[<code>str</code>]</dt>
<dd>A list of strings defining which state
variables the computed values depend on e.g. <code>['pos', 'mom']</code>, such
that the cache is correctly cleared when one of these parent
dependency's value changes.</dd>
<dt><strong><code>variables</code></strong> :&ensp;<code>List</code>[<code>str</code>]</dt>
<dd>A list of strings defining the variables in the
state cache dict corresponding to the outputs of the wrapped
function (method) in the corresponding returned order.</dd>
<dt><strong><code>primary_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of primary output of function (i.e. value to
be returned) in <code>variables</code> list / position in output of function.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/states.py#L39-L85" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def multi_cache_in_state(depends_on, variables, primary_index=0):
    &#34;&#34;&#34;Decorator to cache multiple outputs of a function of state variable(s).

    Used to wrap functions of a chain state vaiable(s) to allow caching of
    the values computed to prevent recomputation when possible.

    This variant allows for functions which also cache intermediate computed
    results which may be used separately elsewhere for example the value of a
    function calculate in the forward pass of a reverse-mode automatic-
    differentation implementation of its gradient.

    Args:
        depends_on (List[str]): A list of strings defining which state
            variables the computed values depend on e.g. `[&#39;pos&#39;, &#39;mom&#39;]`, such
            that the cache is correctly cleared when one of these parent
            dependency&#39;s value changes.
        variables (List[str]): A list of strings defining the variables in the
            state cache dict corresponding to the outputs of the wrapped
            function (method) in the corresponding returned order.
        primary_index (int): Index of primary output of function (i.e. value to
            be returned) in `variables` list / position in output of function.
    &#34;&#34;&#34;
    def multi_cache_in_state_decorator(method):
        @wraps(method)
        def wrapper(self, state):
            type_prefix = type(self).__name__ + &#39;.&#39;
            prim_key = type_prefix + variables[primary_index]
            keys = [type_prefix + v for v in variables]
            for i, key in enumerate(keys):
                if key not in state._cache:
                    for dep in depends_on:
                        state._dependencies[dep].add(key)
            if prim_key not in state._cache or state._cache[prim_key] is None:
                vals = method(self, state)
                if isinstance(vals, tuple):
                    for k, v in zip(keys, vals):
                        state._cache[k] = v
                else:
                    state._cache[prim_key] = vals
                if state._call_counts is not None:
                    if prim_key not in state._call_counts:
                        state._call_counts[prim_key] = 1
                    else:
                        state._call_counts[prim_key] += 1
            return state._cache[prim_key]
        return wrapper
    return multi_cache_in_state_decorator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.states.ChainState"><code class="flex name class">
<span>class <span class="ident">ChainState</span></span>
<span>(</span><span>**variables)</span>
</code></dt>
<dd>
<section class="desc"><p>Markov chain state.</p>
<p>As well as recording the chain state variable values, the state object is
also used to cache derived quantities to avoid recalculation if these
values are subsequently reused.</p>
<p>Create a new <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instance.</p>
<p>Any keyword arguments passed to the constructor will be used to set
state variable attributes of state object for example</p>
<pre><code>state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)
</code></pre>
<p>will return a <a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a> instance <code>state</code> with variable attributes
<code>state.pos</code>, <code>state.mom</code> and <code>state.dir</code> with initial values set to
<code>pos_val</code>, <code>mom_val</code> and <code>dir_val</code> respectively. The keyword arguments
<code>_dependencies</code>, <code>_cache</code>, <code>_call_counts</code> and <code>_read_only</code> are reserved
respectively for the dependency set, cache dictionary, call count
dictionary and a flag to make the state read-only and cannot be used as
state variable names.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/states.py#L88-L187" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ChainState(object):
    &#34;&#34;&#34;Markov chain state.

    As well as recording the chain state variable values, the state object is
    also used to cache derived quantities to avoid recalculation if these
    values are subsequently reused.
    &#34;&#34;&#34;

    def __init__(self, _dependencies=None, _cache=None, _call_counts=None,
                 _read_only=False, **variables):
        &#34;&#34;&#34;Create a new `ChainState` instance.

        Any keyword arguments passed to the constructor will be used to set
        state variable attributes of state object for example

            state = ChainState(pos=pos_val, mom=mom_val, dir=dir_val)

        will return a `ChainState` instance `state` with variable attributes
        `state.pos`, `state.mom` and `state.dir` with initial values set to
        `pos_val`, `mom_val` and `dir_val` respectively. The keyword arguments
        `_dependencies`, `_cache`, `_call_counts` and `_read_only` are reserved
        respectively for the dependency set, cache dictionary, call count
        dictionary and a flag to make the state read-only and cannot be used as
        state variable names.
        &#34;&#34;&#34;
        # Set attributes by directly writing to __dict__ to ensure set before
        # any call to __setattr__
        self.__dict__[&#39;_variables&#39;] = variables
        if _dependencies is None:
            _dependencies = {name: set() for name in variables}
        self.__dict__[&#39;_dependencies&#39;] = _dependencies
        if _cache is None:
            _cache = {}
        self.__dict__[&#39;_cache&#39;] = _cache
        self.__dict__[&#39;_call_counts&#39;] = _call_counts
        self.__dict__[&#39;_read_only&#39;] = _read_only

    def __getattr__(self, name):
        if name in self._variables:
            return self._variables[name]
        else:
            raise AttributeError(
                f&#34;&#39;{type(self).__name__}&#39; object has no attribute &#39;{name}&#39;&#34;)

    def __setattr__(self, name, value):
        if self._read_only:
            raise ReadOnlyStateError(&#39;ChainState instance is read-only.&#39;)
        if name in self._variables:
            self._variables[name] = value
            # clear any dependent cached values
            for dep in self._dependencies[name]:
                self._cache[dep] = None
        else:
            return super().__setattr__(name, value)

    def __contains__(self, name):
        return name in self._variables

    def copy(self, read_only=False):
        &#34;&#34;&#34;Create a deep copy of the state object.

        Args:
            read_only (bool): Whether the state copy should be read-only.

        Returns:
            state_copy (ChainState): A copy of the state object with variable
                attributes that are independent copies of the original state
                object&#39;s variables.
        &#34;&#34;&#34;
        return type(self)(
            _dependencies=self._dependencies, _cache=self._cache.copy(),
            _call_counts=self._call_counts, _read_only=read_only,
            **{name: copy.copy(val) for name, val in self._variables.items()})

    def __str__(self):
        return (
            &#39;(\n &#39; +
            &#39;,\n &#39;.join([f&#39;{k}={v}&#39; for k, v in self._variables.items()]) +
            &#39;)&#39;
        )

    def __repr__(self):
        return type(self).__name__ + str(self)

    def __getstate__(self):
        return {
            &#39;variables&#39;: self._variables,
            &#39;dependencies&#39;: self._dependencies,
            # Don&#39;t pickle callable cached &#39;variables&#39; such as derivative
            # functions
            &#39;cache&#39;: {k: v for k, v in self._cache.items() if not callable(v)},
            &#39;call_counts&#39;: self._call_counts,
            &#39;read_only&#39;: self._read_only}

    def __setstate__(self, state):
        self.__dict__[&#39;_variables&#39;] = state[&#39;variables&#39;]
        self.__dict__[&#39;_dependencies&#39;] = state[&#39;dependencies&#39;]
        self.__dict__[&#39;_cache&#39;] = state[&#39;cache&#39;]
        self.__dict__[&#39;_call_counts&#39;] = state[&#39;call_counts&#39;]
        self.__dict__[&#39;_read_only&#39;] = state[&#39;read_only&#39;]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mici.states.ChainState.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, read_only=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a deep copy of the state object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>read_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the state copy should be read-only.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>state_copy</code></strong> :&ensp;<a title="mici.states.ChainState" href="#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>A copy of the state object with variable
attributes that are independent copies of the original state
object's variables.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/39019d0bfc441dc54a297e7623bac13534f7c2c1/mici/states.py#L146-L160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def copy(self, read_only=False):
    &#34;&#34;&#34;Create a deep copy of the state object.

    Args:
        read_only (bool): Whether the state copy should be read-only.

    Returns:
        state_copy (ChainState): A copy of the state object with variable
            attributes that are independent copies of the original state
            object&#39;s variables.
    &#34;&#34;&#34;
    return type(self)(
        _dependencies=self._dependencies, _cache=self._cache.copy(),
        _call_counts=self._call_counts, _read_only=read_only,
        **{name: copy.copy(val) for name, val in self._variables.items()})</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
Copyright © 2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2.dev0+g1b644f6.d20200630</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad(); hljs.configure({languages: ["python"]});</script>
</body>
</html>