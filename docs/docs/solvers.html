<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2.dev0+g1b644f6.d20200630" />
<title>mici.solvers API documentation</title>
<meta name="description" content="Solvers for non-linear systems of equations for implicit integrators." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding-top:5px;padding-bottom:5px;padding-right:10px;padding-left:35px;text-indent:-25px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:1000px){#sidebar{width:540px;position:fixed;z-index:1;top:0;bottom:0;overflow-x:hidden;overflow-y:auto}#content{margin-left:540px;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}#footer{margin-left:540px}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../images/mici-logo-rectangular.svg" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mici.solvers.euclidean_norm" href="#mici.solvers.euclidean_norm">euclidean_norm</a></code></li>
<li><code><a title="mici.solvers.maximum_norm" href="#mici.solvers.maximum_norm">maximum_norm</a></code></li>
<li><code><a title="mici.solvers.solve_fixed_point_direct" href="#mici.solvers.solve_fixed_point_direct">solve_fixed_point_direct</a></code></li>
<li><code><a title="mici.solvers.solve_fixed_point_steffensen" href="#mici.solvers.solve_fixed_point_steffensen">solve_fixed_point_steffensen</a></code></li>
<li><code><a title="mici.solvers.solve_projection_onto_manifold_quasi_newton" href="#mici.solvers.solve_projection_onto_manifold_quasi_newton">solve_projection_onto_manifold_quasi_newton</a></code></li>
<li><code><a title="mici.solvers.solve_projection_onto_manifold_newton" href="#mici.solvers.solve_projection_onto_manifold_newton">solve_projection_onto_manifold_newton</a></code></li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Module <code>mici.solvers</code></h1>
</header>
<section id="section-intro">
<p>Solvers for non-linear systems of equations for implicit integrators.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/056095624298b0e017652794677e9ba43f7f5ed8/mici/solvers.py#L0-L291" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Solvers for non-linear systems of equations for implicit integrators.&#34;&#34;&#34;

from mici.errors import ConvergenceError, LinAlgError
import numpy as np


def euclidean_norm(vct):
    &#34;&#34;&#34;Calculate the Euclidean (L-2) norm of a vector.&#34;&#34;&#34;
    return np.sum(vct**2)**0.5


def maximum_norm(vct):
    &#34;&#34;&#34;Calculate the maximum (L-infinity) norm of a vector.&#34;&#34;&#34;
    return np.max(abs(vct))


def solve_fixed_point_direct(
        func, x0, convergence_tol=1e-9, divergence_tol=1e10, max_iters=100,
        norm=maximum_norm):
    &#34;&#34;&#34;Solve fixed point equation `func(x) = x` using direct iteration.

    Args:
        func (Callable[[array], array]): Function to find fixed point of.
        x0 (array): Initial state (function argument).
        convergence_tol (float): Convergence tolerance - solver successfully
            terminates when `norm(func(x) - x) &lt; convergence_tol`.
        divergence_tol (float): Divergence tolerance - solver aborts if
            `norm(func(x) - x) &gt; divergence_tol` on any iteration.
        max_iters (int): Maximum number of iterations before raising exception.
        norm (Callable[[array], float]): Norm to use to assess convergence.

    Returns:
        Solution to fixed point equation with
        `norm(func(x) - x) &lt; convergence_tol`.

    Raises:
        `mici.errors.ConvergenceError` if solver does not converge within
        `max_iters` iterations, diverges or encounters a `ValueError` during
        the iteration.
    &#34;&#34;&#34;
    for i in range(max_iters):
        try:
            x = func(x0)
            error = norm(x - x0)
            if error &gt; divergence_tol or np.isnan(error):
                raise ConvergenceError(
                    f&#39;Fixed point iteration diverged on iteration {i}.&#39;
                    f&#39;Last error={error:.1e}.&#39;)
            if error &lt; convergence_tol:
                return x
            x0 = x
        except (ValueError, LinAlgError) as e:
            # Make robust to errors in intermediate linear algebra ops
            raise ConvergenceError(
                f&#39;{type(e)} at iteration {i} of fixed point solver ({e}).&#39;)
    raise ConvergenceError(
        f&#39;Fixed point iteration did not converge. Last error={error:.1e}.&#39;)


def solve_fixed_point_steffensen(
        func, x0, convergence_tol=1e-9, divergence_tol=1e10, max_iters=100,
        norm=maximum_norm):
    &#34;&#34;&#34;Solve fixed point equation `func(x) = x` using Steffensen&#39;s method.

    Steffennsen&#39;s method [1] achieves quadratic convergence but at the cost of
    two function evaluations per iteration so for functions where convergence
    is achieved in a small number of iterations, direct iteration may be
    cheaper.

    [1] : https://en.wikipedia.org/wiki/Steffensen%27s_method

    Args:
        func (Callable[[array], array]): Function to find fixed point of.
        x0 (array): Initial state (function argument).
        convergence_tol (float): Convergence tolerance - solver successfully
            terminates when `norm(func(x) - x) &lt; convergence_tol`.
        divergence_tol (float): Divergence tolerance - solver aborts if
            `norm(func(x) - x) &gt; divergence_tol` on any iteration.
        max_iters (int): Maximum number of iterations before raising exception.
        norm (Callable[[array], float]): Norm to use to assess convergence.

    Returns:
        Solution to fixed point equation with
        `norm(func(x) - x) &lt; convergence_tol`.

    Raises:
        `mici.errors.ConvergenceError` if solver does not converge within
        `max_iters` iterations, diverges or encounters a `ValueError` during
        the iteration.
    &#34;&#34;&#34;
    for i in range(max_iters):
        try:
            x1 = func(x0)
            x2 = func(x1)
            denom = x2 - 2 * x1 + x0
            # Set any zero values in denominator of update term to smalllest
            # floating point value to prevent divide-by-zero errors
            denom[abs(denom) == 0.] = np.finfo(x0.dtype).eps
            x = x0 - (x1 - x0)**2 / denom
            error = norm(x - x0)
            if error &gt; divergence_tol or np.isnan(error):
                raise ConvergenceError(
                    f&#39;Fixed point iteration diverged on iteration {i}.&#39;
                    f&#39;Last error={error:.1e}.&#39;)
            if error &lt; convergence_tol:
                return x
            x0 = x
        except (ValueError, LinAlgError) as e:
            # Make robust to errors in intermediate linear algebra ops
            raise ConvergenceError(
                f&#39;{type(e)} at iteration {i} of fixed point solver ({e}).&#39;)
    raise ConvergenceError(
        f&#39;Fixed point iteration did not converge. Last error={error:.1e}.&#39;)


def solve_projection_onto_manifold_quasi_newton(
        state, state_prev, dt, system, constraint_tol=1e-9, position_tol=1e-8,
        divergence_tol=1e10, max_iters=50, norm=maximum_norm):
    &#34;&#34;&#34;Solve constraint equation using quasi-Newton method.

    Uses a quasi-Newton iteration to solve the non-linear system of equations
    in `λ`

        system.constr(
            state.pos + dh2_flow_pos_dmom @
                system.jacob_constr(state_prev).T @ λ) == 0

    where `dh2_flow_pos_dmom = system.dh2_flow_dmom(dt)[0]` is the derivative
    of the action of the (linear) `system.h2_flow` map on the state momentum
    component with respect to the position component, `state` is a post
    (unconstrained) `system.h2_flow` update state with position component
    outside of the manifold and `state_prev` is the corresponding pre-update
    state in the co-tangent bundle.

    Only requires re-evaluating the constraint function `system.constr` within
    the solver loop and no recomputation of matrix decompositions on each
    iteration.

    Args:
        state (mici.states.ChainState): Post `h2_flow `update state to project.
        state_prev (mici.states.ChainState): Previous state in co-tangent
            bundle manifold before `h2_flow` update which defines the
            co-tangent space to perform projection in.
        dt (float): Integrator time step used in `h2_flow` update.
        system (mici.systems.ConstrainedEuclideanMetricSystem): Hamiltonian
           system defining `h2_flow` and `constr` functions used to define
           constraint equation to solve.
        constraint_tol (float): Convergence tolerance in constraint space.
           Iteration will continue until `norm(constr(pos)) &lt; constraint_tol`
           where `pos` is the position at the current iteration.
        position_tol (float): Convergence tolerance in position space.
           Iteration will continue until `norm(delt_pos) &lt; position_tol`
           where `delta_pos` is the change in the position in the current
           iteration.
        divergence_tol (float): Divergence tolerance - solver aborts if
            `norm(constr(pos)) &gt; divergence_tol` on any iteration where `pos`
            is the position at the current iteration and raises
            `mici.errors.ConvergenceError`.
        max_iters (int): Maximum number of iterations to perform before
            aborting and raising `mici.errors.ConvergenceError`.
        norm (Callable[[array], float]): Norm to use to test for convergence.

    Returns:
        Updated `state` object with position component satisfying constraint
        equation to within `constraint_tol`, i.e.
        `norm(system.constr(state.pos)) &lt; constraint_tol`.

    Raises:
        `mici.errors.ConvergenceError` if solver does not converge within
        `max_iters` iterations, diverges or encounters a `ValueError` during
        the iteration.
    &#34;&#34;&#34;
    mu = np.zeros_like(state.pos)
    jacob_constr_prev = system.jacob_constr(state_prev)
    # Use absolute value of dt and adjust for sign of dt in mom update below
    dh2_flow_pos_dmom, dh2_flow_mom_dmom = system.dh2_flow_dmom(abs(dt))
    inv_jacob_constr_inner_product = system.jacob_constr_inner_product(
        jacob_constr_prev, dh2_flow_pos_dmom).inv
    for i in range(max_iters):
        try:
            constr = system.constr(state)
            error = norm(constr)
            delta_mu = jacob_constr_prev.T @ (
                inv_jacob_constr_inner_product @ constr)
            delta_pos = dh2_flow_pos_dmom @ delta_mu
            if error &gt; divergence_tol or np.isnan(error):
                raise ConvergenceError(
                    f&#39;Quasi-Newton solver diverged on iteration {i}. &#39;
                    f&#39;Last |constr|={error:.1e}, &#39;
                    f&#39;|delta_pos|={norm(delta_pos):.1e}.&#39;)
            elif error &lt; constraint_tol and norm(delta_pos) &lt; position_tol:
                state.mom -= np.sign(dt) * dh2_flow_mom_dmom @ mu
                return state
            mu += delta_mu
            state.pos -= delta_pos
        except (ValueError, LinAlgError) as e:
            # Make robust to errors in intermediate linear algebra ops
            raise ConvergenceError(
                f&#39;{type(e)} at iteration {i} of quasi-Newton solver ({e}).&#39;)
    raise ConvergenceError(
        f&#39;Quasi-Newton solver did not converge with {max_iters} iterations. &#39;
        f&#39;Last |constr|={error:.1e}, |delta_pos|={norm(delta_pos)}.&#39;)


def solve_projection_onto_manifold_newton(
        state, state_prev, dt, system, constraint_tol=1e-9, position_tol=1e-8,
        divergence_tol=1e10, max_iters=50, norm=maximum_norm):
    &#34;&#34;&#34;Solve constraint equation using Newton method.

    Uses a Newton iteration to solve the non-linear system of equations in `λ`

        system.constr(
            state.pos + dh2_flow_pos_dmom @
                system.jacob_constr(state_prev).T @ λ) == 0

    where `dh2_flow_pos_dmom = system.dh2_flow_dmom(dt)[0]` is the derivative
    of the action of the (linear) `system.h2_flow` map on the state momentum
    component with respect to the position component, `state` is a post
    (unconstrained) `system.h2_flow` update state with position component
    outside of the manifold and `state_prev` is the corresponding pre-update
    state in the co-tangent bundle.

    Requires re-evaluating both the constraint function `system.constr` and
    constraint Jacobian `system.jacob_constr` within the solver loop and
    computation of matrix decompositions of a preconditioned matrix on each
    iteration.

    Args:
        state (mici.states.ChainState): Post `h2_flow `update state to project.
        state_prev (mici.states.ChainState): Previous state in co-tangent
            bundle manifold before `h2_flow` update which defines the
            co-tangent space to perform projection in.
        dt (float): Integrator time step used in `h2_flow` update.
        system (mici.systems.ConstrainedEuclideanMetricSystem): Hamiltonian
           system defining `h2_flow` and `constr` functions used to define
           constraint equation to solve.
        constraint_tol (float): Convergence tolerance in constraint space.
           Iteration will continue until `norm(constr(pos)) &lt; constraint_tol`
           where `pos` is the position at the current iteration.
        position_tol (float): Convergence tolerance in position space.
           Iteration will continue until `norm(delt_pos) &lt; position_tol`
           where `delta_pos` is the change in the position in the current
           iteration.
        divergence_tol (float): Divergence tolerance - solver aborts if
            `norm(constr(pos)) &gt; divergence_tol` on any iteration where `pos`
            is the position at the current iteration and raises
            `mici.errors.ConvergenceError`.
        max_iters (int): Maximum number of iterations to perform before
            aborting and raising `mici.errors.ConvergenceError`.
        norm (Callable[[array], float]): Norm to use to test for convergence.

    Returns:
        Updated `state` object with position component satisfying constraint
        equation to within `constraint_tol`, i.e.
        `norm(system.constr(state.pos)) &lt; constraint_tol`.

    Raises:
        `mici.errors.ConvergenceError` if solver does not converge within
        `max_iters` iterations, diverges or encounters a `ValueError` during
        the iteration.
    &#34;&#34;&#34;
    mu = np.zeros_like(state.pos)
    jacob_constr_prev = system.jacob_constr(state_prev)
    # Use absolute value of dt and adjust for sign of dt in mom update below
    dh2_flow_pos_dmom, dh2_flow_mom_dmom = system.dh2_flow_dmom(abs(dt))
    for i in range(max_iters):
        try:
            jacob_constr = system.jacob_constr(state)
            constr = system.constr(state)
            error = norm(constr)
            delta_mu = jacob_constr_prev.T @ (
                system.jacob_constr_inner_product(
                    jacob_constr, dh2_flow_pos_dmom, jacob_constr_prev).inv @
                constr)
            delta_pos = dh2_flow_pos_dmom @ delta_mu
            if error &gt; divergence_tol or np.isnan(error):
                raise ConvergenceError(
                    f&#39;Newton solver diverged at iteration {i}. &#39;
                    f&#39;Last |constr|={error:.1e}, &#39;
                    f&#39;|delta_pos|={norm(delta_pos):.1e}.&#39;)
            if error &lt; constraint_tol and norm(delta_pos) &lt; position_tol:
                state.mom -= np.sign(dt) * dh2_flow_mom_dmom @ mu
                return state
            mu += delta_mu
            state.pos -= delta_pos
        except (ValueError, LinAlgError) as e:
            # Make robust to errors in intermediate linear algebra ops
            raise ConvergenceError(
                f&#39;{type(e)} at iteration {i} of Newton solver ({e}).&#39;)
    raise ConvergenceError(
        f&#39;Newton solver did not converge in {max_iters} iterations. &#39;
        f&#39;Last |constr|={error:.1e}, |delta_pos|={norm(delta_pos)}.&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mici.solvers.euclidean_norm"><code class="name flex">
<span>def <span class="ident">euclidean_norm</span></span>(<span>vct)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the Euclidean (L-2) norm of a vector.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/056095624298b0e017652794677e9ba43f7f5ed8/mici/solvers.py#L7-L9" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def euclidean_norm(vct):
    &#34;&#34;&#34;Calculate the Euclidean (L-2) norm of a vector.&#34;&#34;&#34;
    return np.sum(vct**2)**0.5</code></pre>
</details>
</dd>
<dt id="mici.solvers.maximum_norm"><code class="name flex">
<span>def <span class="ident">maximum_norm</span></span>(<span>vct)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the maximum (L-infinity) norm of a vector.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/056095624298b0e017652794677e9ba43f7f5ed8/mici/solvers.py#L12-L14" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maximum_norm(vct):
    &#34;&#34;&#34;Calculate the maximum (L-infinity) norm of a vector.&#34;&#34;&#34;
    return np.max(abs(vct))</code></pre>
</details>
</dd>
<dt id="mici.solvers.solve_fixed_point_direct"><code class="name flex">
<span>def <span class="ident">solve_fixed_point_direct</span></span>(<span>func, x0, convergence_tol=1e-09, divergence_tol=10000000000.0, max_iters=100, norm=&lt;function maximum_norm&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Solve fixed point equation <code>func(x) = x</code> using direct iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function to find fixed point of.</dd>
<dt><strong><code>x0</code></strong> :&ensp;<code>array</code></dt>
<dd>Initial state (function argument).</dd>
<dt><strong><code>convergence_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Convergence tolerance - solver successfully
terminates when <code>norm(func(x) - x) &lt; convergence_tol</code>.</dd>
<dt><strong><code>divergence_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Divergence tolerance - solver aborts if
<code>norm(func(x) - x) &gt; divergence_tol</code> on any iteration.</dd>
<dt><strong><code>max_iters</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of iterations before raising exception.</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Norm to use to assess convergence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Solution</code> <code>to</code> <code>fixed</code> <code>point</code> <code>equation</code> <code>with</code></dt>
<dd>&nbsp;</dd>
</dl>
<p><code>norm(func(x) - x) &lt; convergence_tol</code>.</p>
<h2 id="raises">Raises</h2>
<p><a title="mici.errors.ConvergenceError" href="errors.html#mici.errors.ConvergenceError"><code>ConvergenceError</code></a> if solver does not converge within
<code>max_iters</code> iterations, diverges or encounters a <code>ValueError</code> during
the iteration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/056095624298b0e017652794677e9ba43f7f5ed8/mici/solvers.py#L17-L57" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def solve_fixed_point_direct(
        func, x0, convergence_tol=1e-9, divergence_tol=1e10, max_iters=100,
        norm=maximum_norm):
    &#34;&#34;&#34;Solve fixed point equation `func(x) = x` using direct iteration.

    Args:
        func (Callable[[array], array]): Function to find fixed point of.
        x0 (array): Initial state (function argument).
        convergence_tol (float): Convergence tolerance - solver successfully
            terminates when `norm(func(x) - x) &lt; convergence_tol`.
        divergence_tol (float): Divergence tolerance - solver aborts if
            `norm(func(x) - x) &gt; divergence_tol` on any iteration.
        max_iters (int): Maximum number of iterations before raising exception.
        norm (Callable[[array], float]): Norm to use to assess convergence.

    Returns:
        Solution to fixed point equation with
        `norm(func(x) - x) &lt; convergence_tol`.

    Raises:
        `mici.errors.ConvergenceError` if solver does not converge within
        `max_iters` iterations, diverges or encounters a `ValueError` during
        the iteration.
    &#34;&#34;&#34;
    for i in range(max_iters):
        try:
            x = func(x0)
            error = norm(x - x0)
            if error &gt; divergence_tol or np.isnan(error):
                raise ConvergenceError(
                    f&#39;Fixed point iteration diverged on iteration {i}.&#39;
                    f&#39;Last error={error:.1e}.&#39;)
            if error &lt; convergence_tol:
                return x
            x0 = x
        except (ValueError, LinAlgError) as e:
            # Make robust to errors in intermediate linear algebra ops
            raise ConvergenceError(
                f&#39;{type(e)} at iteration {i} of fixed point solver ({e}).&#39;)
    raise ConvergenceError(
        f&#39;Fixed point iteration did not converge. Last error={error:.1e}.&#39;)</code></pre>
</details>
</dd>
<dt id="mici.solvers.solve_fixed_point_steffensen"><code class="name flex">
<span>def <span class="ident">solve_fixed_point_steffensen</span></span>(<span>func, x0, convergence_tol=1e-09, divergence_tol=10000000000.0, max_iters=100, norm=&lt;function maximum_norm&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Solve fixed point equation <code>func(x) = x</code> using Steffensen's method.</p>
<p>Steffennsen's method [1] achieves quadratic convergence but at the cost of
two function evaluations per iteration so for functions where convergence
is achieved in a small number of iterations, direct iteration may be
cheaper.</p>
<p>[1] : <a href="https://en.wikipedia.org/wiki/Steffensen%27s_method">https://en.wikipedia.org/wiki/Steffensen%27s_method</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>array</code>]</dt>
<dd>Function to find fixed point of.</dd>
<dt><strong><code>x0</code></strong> :&ensp;<code>array</code></dt>
<dd>Initial state (function argument).</dd>
<dt><strong><code>convergence_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Convergence tolerance - solver successfully
terminates when <code>norm(func(x) - x) &lt; convergence_tol</code>.</dd>
<dt><strong><code>divergence_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Divergence tolerance - solver aborts if
<code>norm(func(x) - x) &gt; divergence_tol</code> on any iteration.</dd>
<dt><strong><code>max_iters</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of iterations before raising exception.</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Norm to use to assess convergence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Solution</code> <code>to</code> <code>fixed</code> <code>point</code> <code>equation</code> <code>with</code></dt>
<dd>&nbsp;</dd>
</dl>
<p><code>norm(func(x) - x) &lt; convergence_tol</code>.</p>
<h2 id="raises">Raises</h2>
<p><a title="mici.errors.ConvergenceError" href="errors.html#mici.errors.ConvergenceError"><code>ConvergenceError</code></a> if solver does not converge within
<code>max_iters</code> iterations, diverges or encounters a <code>ValueError</code> during
the iteration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/056095624298b0e017652794677e9ba43f7f5ed8/mici/solvers.py#L60-L113" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def solve_fixed_point_steffensen(
        func, x0, convergence_tol=1e-9, divergence_tol=1e10, max_iters=100,
        norm=maximum_norm):
    &#34;&#34;&#34;Solve fixed point equation `func(x) = x` using Steffensen&#39;s method.

    Steffennsen&#39;s method [1] achieves quadratic convergence but at the cost of
    two function evaluations per iteration so for functions where convergence
    is achieved in a small number of iterations, direct iteration may be
    cheaper.

    [1] : https://en.wikipedia.org/wiki/Steffensen%27s_method

    Args:
        func (Callable[[array], array]): Function to find fixed point of.
        x0 (array): Initial state (function argument).
        convergence_tol (float): Convergence tolerance - solver successfully
            terminates when `norm(func(x) - x) &lt; convergence_tol`.
        divergence_tol (float): Divergence tolerance - solver aborts if
            `norm(func(x) - x) &gt; divergence_tol` on any iteration.
        max_iters (int): Maximum number of iterations before raising exception.
        norm (Callable[[array], float]): Norm to use to assess convergence.

    Returns:
        Solution to fixed point equation with
        `norm(func(x) - x) &lt; convergence_tol`.

    Raises:
        `mici.errors.ConvergenceError` if solver does not converge within
        `max_iters` iterations, diverges or encounters a `ValueError` during
        the iteration.
    &#34;&#34;&#34;
    for i in range(max_iters):
        try:
            x1 = func(x0)
            x2 = func(x1)
            denom = x2 - 2 * x1 + x0
            # Set any zero values in denominator of update term to smalllest
            # floating point value to prevent divide-by-zero errors
            denom[abs(denom) == 0.] = np.finfo(x0.dtype).eps
            x = x0 - (x1 - x0)**2 / denom
            error = norm(x - x0)
            if error &gt; divergence_tol or np.isnan(error):
                raise ConvergenceError(
                    f&#39;Fixed point iteration diverged on iteration {i}.&#39;
                    f&#39;Last error={error:.1e}.&#39;)
            if error &lt; convergence_tol:
                return x
            x0 = x
        except (ValueError, LinAlgError) as e:
            # Make robust to errors in intermediate linear algebra ops
            raise ConvergenceError(
                f&#39;{type(e)} at iteration {i} of fixed point solver ({e}).&#39;)
    raise ConvergenceError(
        f&#39;Fixed point iteration did not converge. Last error={error:.1e}.&#39;)</code></pre>
</details>
</dd>
<dt id="mici.solvers.solve_projection_onto_manifold_quasi_newton"><code class="name flex">
<span>def <span class="ident">solve_projection_onto_manifold_quasi_newton</span></span>(<span>state, state_prev, dt, system, constraint_tol=1e-09, position_tol=1e-08, divergence_tol=10000000000.0, max_iters=50, norm=&lt;function maximum_norm&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Solve constraint equation using quasi-Newton method.</p>
<p>Uses a quasi-Newton iteration to solve the non-linear system of equations
in <code>λ</code></p>
<pre><code>system.constr(
    state.pos + dh2_flow_pos_dmom @
        system.jacob_constr(state_prev).T @ λ) == 0
</code></pre>
<p>where <code>dh2_flow_pos_dmom = system.dh2_flow_dmom(dt)[0]</code> is the derivative
of the action of the (linear) <code>system.h2_flow</code> map on the state momentum
component with respect to the position component, <code>state</code> is a post
(unconstrained) <code>system.h2_flow</code> update state with position component
outside of the manifold and <code>state_prev</code> is the corresponding pre-update
state in the co-tangent bundle.</p>
<p>Only requires re-evaluating the constraint function <code>system.constr</code> within
the solver loop and no recomputation of matrix decompositions on each
iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Post <code>h2_flow</code>update state to project.</dd>
<dt><strong><code>state_prev</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Previous state in co-tangent
bundle manifold before <code>h2_flow</code> update which defines the
co-tangent space to perform projection in.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Integrator time step used in <code>h2_flow</code> update.</dd>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.ConstrainedEuclideanMetricSystem" href="systems.html#mici.systems.ConstrainedEuclideanMetricSystem"><code>ConstrainedEuclideanMetricSystem</code></a></dt>
<dd>Hamiltonian
system defining <code>h2_flow</code> and <code>constr</code> functions used to define
constraint equation to solve.</dd>
<dt><strong><code>constraint_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Convergence tolerance in constraint space.
Iteration will continue until <code>norm(constr(pos)) &lt; constraint_tol</code>
where <code>pos</code> is the position at the current iteration.</dd>
<dt><strong><code>position_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Convergence tolerance in position space.
Iteration will continue until <code>norm(delt_pos) &lt; position_tol</code>
where <code>delta_pos</code> is the change in the position in the current
iteration.</dd>
<dt><strong><code>divergence_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Divergence tolerance - solver aborts if
<code>norm(constr(pos)) &gt; divergence_tol</code> on any iteration where <code>pos</code>
is the position at the current iteration and raises
<a title="mici.errors.ConvergenceError" href="errors.html#mici.errors.ConvergenceError"><code>ConvergenceError</code></a>.</dd>
<dt><strong><code>max_iters</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of iterations to perform before
aborting and raising <a title="mici.errors.ConvergenceError" href="errors.html#mici.errors.ConvergenceError"><code>ConvergenceError</code></a>.</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Norm to use to test for convergence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Updated <code>state</code> object with position component satisfying constraint
equation to within <code>constraint_tol</code>, i.e.
<code>norm(system.constr(state.pos)) &lt; constraint_tol</code>.</p>
<h2 id="raises">Raises</h2>
<p><a title="mici.errors.ConvergenceError" href="errors.html#mici.errors.ConvergenceError"><code>ConvergenceError</code></a> if solver does not converge within
<code>max_iters</code> iterations, diverges or encounters a <code>ValueError</code> during
the iteration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/056095624298b0e017652794677e9ba43f7f5ed8/mici/solvers.py#L116-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def solve_projection_onto_manifold_quasi_newton(
        state, state_prev, dt, system, constraint_tol=1e-9, position_tol=1e-8,
        divergence_tol=1e10, max_iters=50, norm=maximum_norm):
    &#34;&#34;&#34;Solve constraint equation using quasi-Newton method.

    Uses a quasi-Newton iteration to solve the non-linear system of equations
    in `λ`

        system.constr(
            state.pos + dh2_flow_pos_dmom @
                system.jacob_constr(state_prev).T @ λ) == 0

    where `dh2_flow_pos_dmom = system.dh2_flow_dmom(dt)[0]` is the derivative
    of the action of the (linear) `system.h2_flow` map on the state momentum
    component with respect to the position component, `state` is a post
    (unconstrained) `system.h2_flow` update state with position component
    outside of the manifold and `state_prev` is the corresponding pre-update
    state in the co-tangent bundle.

    Only requires re-evaluating the constraint function `system.constr` within
    the solver loop and no recomputation of matrix decompositions on each
    iteration.

    Args:
        state (mici.states.ChainState): Post `h2_flow `update state to project.
        state_prev (mici.states.ChainState): Previous state in co-tangent
            bundle manifold before `h2_flow` update which defines the
            co-tangent space to perform projection in.
        dt (float): Integrator time step used in `h2_flow` update.
        system (mici.systems.ConstrainedEuclideanMetricSystem): Hamiltonian
           system defining `h2_flow` and `constr` functions used to define
           constraint equation to solve.
        constraint_tol (float): Convergence tolerance in constraint space.
           Iteration will continue until `norm(constr(pos)) &lt; constraint_tol`
           where `pos` is the position at the current iteration.
        position_tol (float): Convergence tolerance in position space.
           Iteration will continue until `norm(delt_pos) &lt; position_tol`
           where `delta_pos` is the change in the position in the current
           iteration.
        divergence_tol (float): Divergence tolerance - solver aborts if
            `norm(constr(pos)) &gt; divergence_tol` on any iteration where `pos`
            is the position at the current iteration and raises
            `mici.errors.ConvergenceError`.
        max_iters (int): Maximum number of iterations to perform before
            aborting and raising `mici.errors.ConvergenceError`.
        norm (Callable[[array], float]): Norm to use to test for convergence.

    Returns:
        Updated `state` object with position component satisfying constraint
        equation to within `constraint_tol`, i.e.
        `norm(system.constr(state.pos)) &lt; constraint_tol`.

    Raises:
        `mici.errors.ConvergenceError` if solver does not converge within
        `max_iters` iterations, diverges or encounters a `ValueError` during
        the iteration.
    &#34;&#34;&#34;
    mu = np.zeros_like(state.pos)
    jacob_constr_prev = system.jacob_constr(state_prev)
    # Use absolute value of dt and adjust for sign of dt in mom update below
    dh2_flow_pos_dmom, dh2_flow_mom_dmom = system.dh2_flow_dmom(abs(dt))
    inv_jacob_constr_inner_product = system.jacob_constr_inner_product(
        jacob_constr_prev, dh2_flow_pos_dmom).inv
    for i in range(max_iters):
        try:
            constr = system.constr(state)
            error = norm(constr)
            delta_mu = jacob_constr_prev.T @ (
                inv_jacob_constr_inner_product @ constr)
            delta_pos = dh2_flow_pos_dmom @ delta_mu
            if error &gt; divergence_tol or np.isnan(error):
                raise ConvergenceError(
                    f&#39;Quasi-Newton solver diverged on iteration {i}. &#39;
                    f&#39;Last |constr|={error:.1e}, &#39;
                    f&#39;|delta_pos|={norm(delta_pos):.1e}.&#39;)
            elif error &lt; constraint_tol and norm(delta_pos) &lt; position_tol:
                state.mom -= np.sign(dt) * dh2_flow_mom_dmom @ mu
                return state
            mu += delta_mu
            state.pos -= delta_pos
        except (ValueError, LinAlgError) as e:
            # Make robust to errors in intermediate linear algebra ops
            raise ConvergenceError(
                f&#39;{type(e)} at iteration {i} of quasi-Newton solver ({e}).&#39;)
    raise ConvergenceError(
        f&#39;Quasi-Newton solver did not converge with {max_iters} iterations. &#39;
        f&#39;Last |constr|={error:.1e}, |delta_pos|={norm(delta_pos)}.&#39;)</code></pre>
</details>
</dd>
<dt id="mici.solvers.solve_projection_onto_manifold_newton"><code class="name flex">
<span>def <span class="ident">solve_projection_onto_manifold_newton</span></span>(<span>state, state_prev, dt, system, constraint_tol=1e-09, position_tol=1e-08, divergence_tol=10000000000.0, max_iters=50, norm=&lt;function maximum_norm&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Solve constraint equation using Newton method.</p>
<p>Uses a Newton iteration to solve the non-linear system of equations in <code>λ</code></p>
<pre><code>system.constr(
    state.pos + dh2_flow_pos_dmom @
        system.jacob_constr(state_prev).T @ λ) == 0
</code></pre>
<p>where <code>dh2_flow_pos_dmom = system.dh2_flow_dmom(dt)[0]</code> is the derivative
of the action of the (linear) <code>system.h2_flow</code> map on the state momentum
component with respect to the position component, <code>state</code> is a post
(unconstrained) <code>system.h2_flow</code> update state with position component
outside of the manifold and <code>state_prev</code> is the corresponding pre-update
state in the co-tangent bundle.</p>
<p>Requires re-evaluating both the constraint function <code>system.constr</code> and
constraint Jacobian <code>system.jacob_constr</code> within the solver loop and
computation of matrix decompositions of a preconditioned matrix on each
iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Post <code>h2_flow</code>update state to project.</dd>
<dt><strong><code>state_prev</code></strong> :&ensp;<a title="mici.states.ChainState" href="states.html#mici.states.ChainState"><code>ChainState</code></a></dt>
<dd>Previous state in co-tangent
bundle manifold before <code>h2_flow</code> update which defines the
co-tangent space to perform projection in.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Integrator time step used in <code>h2_flow</code> update.</dd>
<dt><strong><code>system</code></strong> :&ensp;<a title="mici.systems.ConstrainedEuclideanMetricSystem" href="systems.html#mici.systems.ConstrainedEuclideanMetricSystem"><code>ConstrainedEuclideanMetricSystem</code></a></dt>
<dd>Hamiltonian
system defining <code>h2_flow</code> and <code>constr</code> functions used to define
constraint equation to solve.</dd>
<dt><strong><code>constraint_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Convergence tolerance in constraint space.
Iteration will continue until <code>norm(constr(pos)) &lt; constraint_tol</code>
where <code>pos</code> is the position at the current iteration.</dd>
<dt><strong><code>position_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Convergence tolerance in position space.
Iteration will continue until <code>norm(delt_pos) &lt; position_tol</code>
where <code>delta_pos</code> is the change in the position in the current
iteration.</dd>
<dt><strong><code>divergence_tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Divergence tolerance - solver aborts if
<code>norm(constr(pos)) &gt; divergence_tol</code> on any iteration where <code>pos</code>
is the position at the current iteration and raises
<a title="mici.errors.ConvergenceError" href="errors.html#mici.errors.ConvergenceError"><code>ConvergenceError</code></a>.</dd>
<dt><strong><code>max_iters</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of iterations to perform before
aborting and raising <a title="mici.errors.ConvergenceError" href="errors.html#mici.errors.ConvergenceError"><code>ConvergenceError</code></a>.</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>Callable</code>[[<code>array</code>], <code>float</code>]</dt>
<dd>Norm to use to test for convergence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Updated <code>state</code> object with position component satisfying constraint
equation to within <code>constraint_tol</code>, i.e.
<code>norm(system.constr(state.pos)) &lt; constraint_tol</code>.</p>
<h2 id="raises">Raises</h2>
<p><a title="mici.errors.ConvergenceError" href="errors.html#mici.errors.ConvergenceError"><code>ConvergenceError</code></a> if solver does not converge within
<code>max_iters</code> iterations, diverges or encounters a <code>ValueError</code> during
the iteration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/056095624298b0e017652794677e9ba43f7f5ed8/mici/solvers.py#L205-L292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def solve_projection_onto_manifold_newton(
        state, state_prev, dt, system, constraint_tol=1e-9, position_tol=1e-8,
        divergence_tol=1e10, max_iters=50, norm=maximum_norm):
    &#34;&#34;&#34;Solve constraint equation using Newton method.

    Uses a Newton iteration to solve the non-linear system of equations in `λ`

        system.constr(
            state.pos + dh2_flow_pos_dmom @
                system.jacob_constr(state_prev).T @ λ) == 0

    where `dh2_flow_pos_dmom = system.dh2_flow_dmom(dt)[0]` is the derivative
    of the action of the (linear) `system.h2_flow` map on the state momentum
    component with respect to the position component, `state` is a post
    (unconstrained) `system.h2_flow` update state with position component
    outside of the manifold and `state_prev` is the corresponding pre-update
    state in the co-tangent bundle.

    Requires re-evaluating both the constraint function `system.constr` and
    constraint Jacobian `system.jacob_constr` within the solver loop and
    computation of matrix decompositions of a preconditioned matrix on each
    iteration.

    Args:
        state (mici.states.ChainState): Post `h2_flow `update state to project.
        state_prev (mici.states.ChainState): Previous state in co-tangent
            bundle manifold before `h2_flow` update which defines the
            co-tangent space to perform projection in.
        dt (float): Integrator time step used in `h2_flow` update.
        system (mici.systems.ConstrainedEuclideanMetricSystem): Hamiltonian
           system defining `h2_flow` and `constr` functions used to define
           constraint equation to solve.
        constraint_tol (float): Convergence tolerance in constraint space.
           Iteration will continue until `norm(constr(pos)) &lt; constraint_tol`
           where `pos` is the position at the current iteration.
        position_tol (float): Convergence tolerance in position space.
           Iteration will continue until `norm(delt_pos) &lt; position_tol`
           where `delta_pos` is the change in the position in the current
           iteration.
        divergence_tol (float): Divergence tolerance - solver aborts if
            `norm(constr(pos)) &gt; divergence_tol` on any iteration where `pos`
            is the position at the current iteration and raises
            `mici.errors.ConvergenceError`.
        max_iters (int): Maximum number of iterations to perform before
            aborting and raising `mici.errors.ConvergenceError`.
        norm (Callable[[array], float]): Norm to use to test for convergence.

    Returns:
        Updated `state` object with position component satisfying constraint
        equation to within `constraint_tol`, i.e.
        `norm(system.constr(state.pos)) &lt; constraint_tol`.

    Raises:
        `mici.errors.ConvergenceError` if solver does not converge within
        `max_iters` iterations, diverges or encounters a `ValueError` during
        the iteration.
    &#34;&#34;&#34;
    mu = np.zeros_like(state.pos)
    jacob_constr_prev = system.jacob_constr(state_prev)
    # Use absolute value of dt and adjust for sign of dt in mom update below
    dh2_flow_pos_dmom, dh2_flow_mom_dmom = system.dh2_flow_dmom(abs(dt))
    for i in range(max_iters):
        try:
            jacob_constr = system.jacob_constr(state)
            constr = system.constr(state)
            error = norm(constr)
            delta_mu = jacob_constr_prev.T @ (
                system.jacob_constr_inner_product(
                    jacob_constr, dh2_flow_pos_dmom, jacob_constr_prev).inv @
                constr)
            delta_pos = dh2_flow_pos_dmom @ delta_mu
            if error &gt; divergence_tol or np.isnan(error):
                raise ConvergenceError(
                    f&#39;Newton solver diverged at iteration {i}. &#39;
                    f&#39;Last |constr|={error:.1e}, &#39;
                    f&#39;|delta_pos|={norm(delta_pos):.1e}.&#39;)
            if error &lt; constraint_tol and norm(delta_pos) &lt; position_tol:
                state.mom -= np.sign(dt) * dh2_flow_mom_dmom @ mu
                return state
            mu += delta_mu
            state.pos -= delta_pos
        except (ValueError, LinAlgError) as e:
            # Make robust to errors in intermediate linear algebra ops
            raise ConvergenceError(
                f&#39;{type(e)} at iteration {i} of Newton solver ({e}).&#39;)
    raise ConvergenceError(
        f&#39;Newton solver did not converge in {max_iters} iterations. &#39;
        f&#39;Last |constr|={error:.1e}, |delta_pos|={norm(delta_pos)}.&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
</main>
<footer id="footer">
Copyright © 2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2.dev0+g1b644f6.d20200630</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad(); hljs.configure({languages: ["python"]});</script>
</body>
</html>